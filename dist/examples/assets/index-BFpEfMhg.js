import{U as q,T as A,E as I,D as S,F as _,C as H}from"./index-CE6-3cgY.js";import{m as n,v as z,M as e}from"./Math-Cr7J2GA5.js";class Y{#e;#n=new Float32Array(16);#t;#i;constructor(t){this.#e=t??"Cube"}async CreatePipeline(t,i){const o=`${this.#e} Pipeline`;return Array.isArray(i)||typeof i=="string"?i={shader:i,pipelineName:o}:i instanceof GPUShaderModule?i={module:i,pipelineName:o}:i.pipelineName??=o,this.SetRenderPipeline(await t.CreatePipeline(i))}SetRenderPipeline(t){return this.#t=t,this.#r(),this.#o(),this.#a(),this.#t}#r(){this.#i=this.#t.CreateBuffer({size:this.#n.length*Float32Array.BYTES_PER_ELEMENT,label:`${this.#e} Uniform Buffer`,usage:q.UNIFORM})}#o(){const t=new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),i=this.#t.CreateVertexBuffer(t,{label:`${this.#e} Vertex Buffer`});this.#t.WriteBuffer(i,t),this.#t.SetVertexBuffers(i)}#a(){const t=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),i=this.#t.CreateIndexBuffer(t,{label:`${this.#e} Index Buffer`});this.#t.WriteBuffer(i,t),this.#t.SetIndexBuffer(i,"uint16"),this.#t.SetDrawParams(t.length)}Update(){this.#t.WriteBuffer(this.#i,this.#n)}#s(t){const i=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]),o=t.CreateVertexBuffer(i,{label:`${this.#e} Texture Buffer`});t.WriteBuffer(o,i),t.AddVertexBuffers(o)}AddVertexBuffers(t,i,o){!this.#t&&A(I.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Cube.CreatePipeline` or `Cube.SetRenderPipeline` method before adding vertex buffers."),this.#t.AddVertexBuffers(t,i,o)}GetPositionBufferLayout(t,i="position"){const o=t??this.#t;return!o&&A(I.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Pass it as argument to `Cube.GetPositionBufferLayout` method or call `Cube.CreatePipeline`\n            or `Cube.SetRenderPipeline` before getting position buffer layout."),o.CreateVertexBufferLayout({name:i,format:"float32x3"})}GetTextureCoordsBufferLayout(t,i="textureCoords"){const o=t??this.#t;return!o&&A(I.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Pass it as argument to `Cube.GetTextureCoordsBufferLayout` method or call `Cube.CreatePipeline`\n            or `Cube.SetRenderPipeline` before getting texture coord buffer layout."),this.#s(o),o.CreateVertexBufferLayout(i)}get ProjectionBuffer(){return this.#i}get Projection(){return this.#n}get Pipeline(){return this.#t}Destroy(){this.#t.Destroy(),this.#i.destroy(),this.#i=void 0}}class W{Matrix=n.identity();Projection=n.identity();ResetProjection(){return this.Projection=n.identity(),this}ResetMatrix(){return this.Matrix=n.identity(),this}get Matrix(){return this.Matrix}get Projection(){return this.Projection}}class k extends W{#e=1;#n=1e3;#t=0;#i=innerWidth;#r=innerHeight;#o=0;constructor(t=1,i=1e3,o=0,p=innerWidth,d=innerHeight,h=0){if(super(),this.#e=t,this.#n=i,this.#t=o,this.#o=h,typeof p!="number"){const[c,P]=p.CanvasSize;this.#i=c,this.#r=P}else this.#i=p,this.#r=d;this.UpdateProjection()}UpdateProjection(){return n.ortho(this.#o,this.#i,this.#r,this.#t,this.#e,this.#n,this.Projection)}set Near(t){this.#e=t,this.UpdateProjection()}get Near(){return this.#e}set Far(t){this.#n=t,this.UpdateProjection()}get Far(){return this.#n}set Top(t){this.#t=t,this.UpdateProjection()}get Top(){return this.#t}set Right(t){this.#i=t,this.UpdateProjection()}get Right(){return this.#i}set Bottom(t){this.#r=t,this.UpdateProjection()}get Bottom(){return this.#r}set Left(t){this.#o=t,this.UpdateProjection()}get Left(){return this.#o}}class J extends W{#e=z.set(0,1,0);#n=z.zero();#t=n.identity();#i=n.identity();#r=60;#o=1;#a=1e3;#s=innerWidth/innerHeight;constructor(t=60,i=1,o=1e3,p=innerWidth/innerHeight){super(),this.#r=t,this.#o=i,this.#a=o,this.#s=typeof p!="number"?p.AspectRatio:p,this.UpdateProjection()}UpdateProjection(){const t=e.DegreesToRadians(this.#r);return n.perspective(t,this.#s,this.#o,this.#a,this.Projection)}UpdateViewProjection(t=!0){return t&&n.inverse(this.Matrix,this.#t),n.multiply(this.Projection,this.#t,this.#i)}LookAt(t,i=this.#e){return n.lookAt(this.Position,t,i,this.#t),this}Translate(t){return n.translate(this.Matrix,t,this.Matrix),this}SetRotationAxis(t,i){return n.rotation(t,i,this.Matrix),this}RotateAxis(t,i){return n.rotate(this.Matrix,t,i,this.Matrix),this}RotateX(t){return n.rotateX(this.Matrix,t,this.Matrix),this}RotateY(t){return n.rotateY(this.Matrix,t,this.Matrix),this}RotateZ(t){return n.rotateZ(this.Matrix,t,this.Matrix),this}set FieldOfView(t){this.#r=t,this.UpdateProjection()}get FieldOfView(){return this.#r}set Near(t){this.#o=t,this.UpdateProjection()}get Near(){return this.#o}set Far(t){this.#a=t,this.UpdateProjection()}get Far(){return this.#a}set AspectRatio(t){this.#s=typeof t!="number"?t.AspectRatio:t,this.UpdateProjection()}get AspectRatio(){return this.#s}set Position(t){n.setTranslation(this.Matrix,t,this.Matrix)}get Position(){return n.getTranslation(this.Matrix,this.#n)}set RotationX(t){n.rotationX(t,this.Matrix)}set RotationY(t){n.rotationY(t,this.Matrix)}set RotationZ(t){n.rotationZ(t,this.Matrix)}}const K=""+new URL("dice-Vcs4qiRq.jpg",import.meta.url).href;var Q="struct VertexOutput{@location(0)textureCoords: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@group(0)@binding(2)var<uniform>projection: mat4x4f;@vertex fn vertex(@location(0)position: vec4f,@location(1)textureCoords: vec2f)->VertexOutput{var output: VertexOutput;output.position=projection*position;output.textureCoords=textureCoords;return output;}@fragment fn fragment(@location(0)textureCoords: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoords);}";/**
 * @example Cube / Cameras
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is developed by using a version listed below.
 * Please note that this code may be simplified in future
 * thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */let j,u,v,L;async function it(C){try{u=new(await S.Renderer(C,"Cube / Cameras"))}catch(l){alert(l)}let t,i,o,p=1/0;const d=e.Vec3.create(),h=e.Vec3.create(),c=new u.Pipeline,P=new Y,y=new Y,M=new J,B=new k,F=c.CreateShaderModule(Q),N=e.Vec3.create(),b=e.Vec3.create(),V=e.Vec3.create(),E=e.Vec3.create(),w=e.Vec3.create(),g=e.Vec3.create(),x=e.Vec3.create(),f=e.Vec3.create();y.SetRenderPipeline(c),P.SetRenderPipeline(c),await u.AddPipeline(c,{primitive:c.CreatePrimitiveState(),fragment:c.CreateFragmentState(F),multisample:c.CreateMultisampleState(),depthStencil:c.CreateDepthStencilState(),vertex:c.CreateVertexState(F,[P.GetPositionBufferLayout(),P.GetTextureCoordsBufferLayout()])});const X=M.UpdateViewProjection(),R=new(await S.Texture(u)),Z=await R.CreateImageBitmap(K);v=await R.CopyImageToTexture(Z),c.AddBindGroupFromResources([R.CreateSampler({filter:_.LINEAR}),v.createView(),P.ProjectionBuffer]),c.AddBindGroupFromResources([R.CreateSampler({filter:_.LINEAR}),v.createView(),y.ProjectionBuffer]),u.CreatePassDescriptor(u.CreateColorAttachment(new H(1657907)),u.CreateDepthStencilAttachment());function $(){p=1/0,clearTimeout(o),cancelAnimationFrame(j)}function O(){o=setTimeout(()=>{const l=-t||0,a=e.RandomInt(-2,2)||1/0,s=e.RandomInt(-2,2)||1/0,r=e.RandomInt(-2,2)||1/0;x[0]=Math.PI/a,x[1]=Math.PI/s,x[2]=Math.PI/r,f[0]=Math.PI/a+t,f[1]=!isFinite(a)&&t||Math.abs(a)<2&&l,f[2]=Math.abs(a)===2&&Math.sign(a)*l,f[1]&&=f[1]+Math.PI/s,f[2]&&=f[2]+Math.PI/r,p=Date.now()},1e3)}function D(l){j=requestAnimationFrame(D),l=(Date.now()-p)/1e3;const a=e.SmoothStep(l);let s=e.SmootherStep(l*2);.5<=a&&(s=(.5-(a-.5))*2,a===1&&(e.Vec3.copy(f,g),e.Vec3.copy(x,V),p=1/0,O()));{const r=P.Projection;e.Mat4.copy(X,r),e.Vec3.copy(b,d),d[1]=e.Lerp(b[1],4,s),e.Mat4.translate(r,d,r),h[0]=e.Lerp(V[0],x[0],a),h[1]=e.Lerp(V[1],x[1],a),h[2]=e.Lerp(V[2],x[2],a),e.Mat4.rotateX(r,h[0],r),e.Mat4.rotateY(r,h[1],r),e.Mat4.rotateZ(r,h[2],r),e.Mat4.scale(r,N,r),c.SetActiveBindGroups(0),P.Update(),u.Render(!1)}{const r=y.Projection;e.Mat4.copy(B.Projection,r),e.Vec3.copy(w,d),d[1]=e.Lerp(w[1],i,s),e.Mat4.translate(r,d,r),h[0]=e.Lerp(g[0],f[0],a),h[1]=e.Lerp(g[1],f[1],a),h[2]=e.Lerp(g[2],f[2],a),e.Mat4.rotateX(r,h[0],r),e.Mat4.rotateY(r,h[1],r),e.Mat4.rotateZ(r,h[2],r),e.Mat4.scale(r,E,r),c.SetActiveBindGroups(1),y.Update(),u.Render()}}L=new ResizeObserver(l=>{for(const a of l){let{inlineSize:s,blockSize:r}=a.contentBoxSize[0];s=s<=960&&s||s-240,u.SetCanvasSize(s,r),u.MultisampleTexture=R.CreateMultisampleTexture(),M.AspectRatio=u.AspectRatio,M.Position=[s/360,2,8],M.UpdateViewProjection(),B.Bottom=r,B.Right=s,B.Near=-100;const G=r-r/3.6,T=(s-360)/1320;t=T*.2+.1,i=G*.39;const m=T+1;e.Vec3.set(m,m,m,N),e.Vec3.set(0,0,0,b);const U=(1-(r-1e3)/-400)*36+72;e.Vec3.set(U*m,U*m,U*m,E),e.Vec3.set(.2,t,0,g),e.Vec3.set(s-(T*250+100),G,0,w)}$(),O(),j=requestAnimationFrame(D)}),L.observe(document.body)}function rt(){S.OnLost=()=>{},cancelAnimationFrame(j),L.disconnect(),u.Destroy(),S.Destroy(void 0,v)}export{rt as destroy,it as run};
