import{D as p,C as F}from"./index-DHkQdOh-.js";import{S as I,a as B,b as L}from"./Shape-4-l3O7pN.js";import{M as v}from"./Math-Cr7J2GA5.js";var M="struct VertexOutput{@location(0)textureCoord: vec2f,@builtin(position)position: vec4f,@location(1)@interpolate(flat)instance: u32};@group(1)@binding(0)var Sampler: sampler;@group(1)@binding(1)var Texture: texture_2d<f32>;@group(1)@binding(2)var<storage,read>visible: array<u32>;@vertex fn textureVertex(@location(0)position: vec2f,@location(1)translation: vec2f,@builtin(instance_index)instance: u32)->VertexOutput{var output: VertexOutput;let dpr=resolution.z*2.75;let aspect=resolution.xy/resolution.y;let clipSpace=GetVertexClipSpace(position).xy;output.position=vec4f(clipSpace+translation,0,1);output.textureCoord=clipSpace*aspect*dpr+0.5;output.instance=instance;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f,@location(1)@interpolate(flat)instance: u32)->@location(0)vec4f{if(visible[instance]==0){discard;}return textureSample(Texture,Sampler,textureCoord);}";const O=""+new URL("logo-DEvozEyj.jpg",import.meta.url).href;/**
 * @example Textures / Instancing
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is developed by using a version listed below.
 * Please note that this code may be simplified in future
 * thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */let l,n,S,w,f,_;async function G(d){try{n=new(await p.Renderer(d,"Textures / Instancing"))}catch(e){alert(e)}const m=128,s=256,t=new n.Pipeline;let u,y,c,x,o=512,g=performance.now()-o;const h=t.CreateShaderModule([I,M]);n.CreatePassDescriptor(n.CreateColorAttachment(new F(1651532)));const{buffer:C,layout:T}=t.CreateVertexBuffer("translation",s,"instance","textureVertex");t.WriteBuffer(C,z()),await n.AddPipeline(t,{fragment:t.CreateFragmentState(h),vertex:t.CreateVertexState(h,[B.GetPositionBufferLayout(t),T],void 0,"textureVertex")});function R(){cancelAnimationFrame(l),clearTimeout(y),g=performance.now()-o}async function V(){A(),P(),await D(),requestAnimationFrame(b),y=setTimeout(()=>o=~(c=-1),o*3)}function A(){const e=new L({radius:m}),[i,r]=n.CanvasSize,a=new B(e);a.SetRenderPipeline(t,n.ResolutionBuffer),t.SetDrawParams(e.Vertices,s),a.AddVertexBuffers(C),a.Position=[i/2,r/2],a.Rotation=Math.PI/4,a.Update()}function P(){const e=t.CreateStorageBuffer("visible",s);t.WriteBuffer(e.buffer,e.visible),x=(u=e.visible).length-1,f=e.buffer}function z(){const e=new Float32Array(s*2),i=1-Math.sqrt(2)*m/d.offsetWidth,r=1-Math.sqrt(2)*m/d.offsetHeight;for(let a=s;a--;)e.set([v.Random(-i,i),v.Random(-r,r)],a*2);return e}async function D(){const e=new(await p.Texture());w=await e.CopyImageToTexture(await e.CreateImageBitmap(O),{flipY:!0,create:{mipmaps:!1}}),t.AddBindGroupFromResources([e.CreateSampler(),w.createView(),f],0,1)}function b(e){l=requestAnimationFrame(b),!(e-g<o)&&(o?u.fill(0)&&(c=v.RandomInt(0,x)):++c===x&&cancelAnimationFrame(l),g=e,u[c]=1,t.WriteBuffer(f,u),n.Render())}S=new ResizeObserver(e=>{for(const i of e){let{inlineSize:r,blockSize:a}=i.contentBoxSize[0];r=r<=960&&r||r-240,n.SetCanvasSize(r,a)}R(),V()}),S.observe(document.body)}function j(){p.OnLost=()=>{},cancelAnimationFrame(l),S.disconnect(),n.Destroy(),p.Destroy([f,_],w)}export{j as destroy,G as run};
