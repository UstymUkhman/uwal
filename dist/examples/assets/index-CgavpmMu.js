var Y=Object.defineProperty;var H=(o,e,t)=>e in o?Y(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var b=(o,e,t)=>(H(o,typeof e!="symbol"?e+"":e,t),t),x=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var a=(o,e,t)=>(x(o,e,"read from private field"),t?t.call(o):e.get(o)),u=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},d=(o,e,t,n)=>(x(o,e,"write to private field"),n?n.call(o,t):e.set(o,t),t);var v=(o,e,t)=>(x(o,e,"access private method"),t);function w(o){const e={};for(let t in o)e[t]={value:o[t]};return Object.freeze(Object.create(null,e))}const J=w({DEVICE_LOST:"Device::Lost"}),l=w({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND"}),z=w({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder."}),K=w({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7});function Z(o,e){console.warn(z[o]+(e??""))}function m(o,e){throw new Error(z[o]+(e??""),{cause:K[o]})}var h,N,g;class ${constructor(e,t){u(this,h,void 0);u(this,N,void 0);b(this,"Device");b(this,"BindGroups",[]);u(this,g,void 0);!e&&m(l.DEVICE_NOT_REQUESTED),this.Device=e,d(this,h,t),d(this,N,this.CreateProgramLabel("Command Encoder"))}CreateProgramLabel(e){return a(this,h)&&e&&`${a(this,h)} ${e}`||""}CreateBuffer(e){const t=e.label??this.CreateProgramLabel("Buffer");return this.Device.createBuffer({...e,label:t})}WriteBuffer(e,t,n=0,i,s){this.Device.queue.writeBuffer(e,n,t,i,s)}CopyBufferToBuffer(e,t,n,i=0,s=0){this.CommandEncoder.copyBufferToBuffer(e,i,t,s,n)}CreateShaderModule(e,t,n,i){t??(t=this.CreateProgramLabel("Shader Module"));const s=Array.isArray(e)&&e.join(`

`)||e;return this.Device.createShaderModule({label:t,code:s,sourceMap:n,compilationHints:i})}CreateBindGroupEntries(e){return Array.isArray(e)&&e.map((t,n)=>({binding:n,resource:t}))||[{binding:0,resource:e}]}CreateBindGroup(e){const t=e.label??this.CreateProgramLabel("Bind Group");return this.Device.createBindGroup({...e,label:t})}AddBindGroups(e){this.BindGroups=Array.isArray(e)&&e||[e]}CreateCommandEncoder(){return d(this,g,this.Device.createCommandEncoder({label:a(this,N)}))}SubmitCommandBuffer(){this.Device.queue.submit([this.CommandEncoder.finish()])}set CommandEncoderLabel(e){d(this,N,e)}get CommandEncoder(){if(!a(this,g)){const e=` ${a(this,N)&&`Label: "${a(this,N)}". `}`;return Z(l.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one."),this.CreateCommandEncoder()}return a(this,g)}get ProgramName(){return a(this,h)}}h=new WeakMap,N=new WeakMap,g=new WeakMap;var S,C;class ee extends ${constructor(t,n,i){super(t,n);u(this,S,void 0);u(this,C,void 0);d(this,S,i)}CreateColorAttachment(t,n="load",i="store",s,c,D){return{view:t,loadOp:n,storeOp:i,clearValue:s,resolveTarget:c,depthSlice:D}}CreateRenderPassDescriptor(t,n,i,s,c,D){const T=Array.isArray(t)&&t||[t];return n??(n=this.CreateProgramLabel("Render Pass")),{colorAttachments:T,depthStencilAttachment:i,occlusionQuerySet:s,timestampWrites:c,maxDrawCount:D,label:n}}CreateVertexState(t,n="vertex",i,s){return{module:t,entryPoint:n,constants:i,buffers:s}}CreateFragmentState(t,n="fragment",i,s){return i??(i=[{format:a(this,S)}]),{module:t,entryPoint:n,targets:i,constants:s}}CreateRenderPipeline(t){const n=t.layout??"auto",i=t.label??this.CreateProgramLabel("Render Pipeline");return this.Device.createRenderPipeline({...t,label:i,layout:n})}Render(t,n,i,s=!0){if(!a(this,C)){const c=this.CreateCommandEncoder();d(this,C,c.beginRenderPass(t)),a(this,C).setPipeline(n)}for(let c=0,D=this.BindGroups.length;c<D;++c)a(this,C).setBindGroup(c,this.BindGroups[c]);a(this,C).draw(...Array.isArray(i)&&i||[i]),s&&(a(this,C).end(),d(this,C,void 0),this.SubmitCommandBuffer())}get CurrentPass(){return a(this,C)}}S=new WeakMap,C=new WeakMap;var F;class te extends ${constructor(t,n){super(t,n);u(this,F,[1])}CreateComputePassDescriptor(t,n,i,s){return t??(t=this.CreateProgramLabel("Compute Pass")),{label:t,timestampWrites:n?{querySet:n,beginningOfPassWriteIndex:i,endOfPassWriteIndex:s}:void 0}}CreateComputePipeline(t){const n=t.layout??"auto",i=t.label??this.CreateProgramLabel("Compute Pipeline");return this.Device.createComputePipeline({label:i,layout:n,compute:t})}Compute(t,n){const i=this.CommandEncoder.beginComputePass(n);i.setPipeline(t);for(let s=0,c=this.BindGroups.length;s<c;++s)i.setBindGroup(s,this.BindGroups[s]);i.dispatchWorkgroups(...a(this,F)),i.end()}set Workgroups(t){d(this,F,Array.isArray(t)&&t||[t])}}F=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.2
 * @license MIT
 */var U,f,E,P,B,A,O,y,M,_,q,V,Q,G,k;const r=class r{static SetAdapterOptions(e,t=!1){a(r,A).powerPreference=e,a(r,A).forceFallbackAdapter=t}static SetDeviceDescriptor(e,t=[],n={}){a(r,O).label=e,a(r,O).requiredFeatures=t,a(r,O).requiredLimits=n}static SetCanvasSize(e=innerWidth,t=innerHeight){!a(r,E)&&m(l.CANVAS_NOT_FOUND),!a(r,f)&&m(l.DEVICE_NOT_FOUND);const{maxTextureDimension2D:n}=a(r,f).limits;e=Math.max(1,Math.min(e,n)),t=Math.max(1,Math.min(t,n)),(a(r,E).width!==e||a(r,E).height!==t)&&(a(r,E).height=t,a(r,E).width=e)}static RenderPipeline(e,t="",n={}){return a(r,O).label=v(this,y,M).call(this,t),(async()=>{const i=await r.Device,s=e.getContext("webgpu");!s&&m(l.CONTEXT_NOT_FOUND);const c=n.format??a(r,B),D={...n,format:c};return s.configure({device:i,...D}),d(r,E,e),d(r,P,s),new Proxy(ee,{construct(T){return new T(i,t,c)}})})()}static ComputePipeline(e=""){return a(r,O).label=v(this,y,M).call(this,e),(async()=>{const t=await r.Device;return new Proxy(te,{construct(n){return new n(t,e)}})})()}static Destroy(e,t,n){var i,s;e=Array.isArray(e)&&e||[e],e.forEach(c=>c==null?void 0:c.destroy()),t=Array.isArray(t)&&t||[t],t.forEach(c=>c==null?void 0:c.destroy()),n=Array.isArray(n)&&n||[n],n.forEach(c=>c==null?void 0:c.destroy()),(i=a(r,P))==null||i.unconfigure(),(s=a(r,f))==null||s.destroy()}static get Adapter(){return(async()=>{var e;return a(r,U)??await v(e=r,_,q).call(e)()})()}static get Device(){return(async()=>{var e;return a(r,f)??await v(e=r,V,Q).call(e)()})()}static get Canvas(){return a(r,E)}static get Context(){return a(r,P)}static get AspectRatio(){return!a(r,E)&&m(l.CANVAS_NOT_FOUND),a(r,E).width/a(r,E).height}static get CurrentTexture(){return a(r,P).getCurrentTexture()}static get CurrentTextureView(){return r.CurrentTexture.createView()}static get VERSION(){return"0.0.2"}};U=new WeakMap,f=new WeakMap,E=new WeakMap,P=new WeakMap,B=new WeakMap,A=new WeakMap,O=new WeakMap,y=new WeakSet,M=function(e){return a(r,O).label??(e&&`${e} Device`||"")},_=new WeakSet,q=function(){return!navigator.gpu&&m(l.WEBGPU_NOT_SUPPORTED),d(r,B,navigator.gpu.getPreferredCanvasFormat()),async()=>{const e=await navigator.gpu.requestAdapter(a(r,A));return!e&&m(l.ADAPTER_NOT_FOUND),d(r,U,e)}},V=new WeakSet,Q=function(){return async()=>{const{requiredFeatures:e,requiredLimits:t,label:n}=a(r,O),i=await(await r.Adapter).requestDevice({requiredFeatures:e,requiredLimits:t,defaultQueue:{label:n}});return!i&&m(l.DEVICE_NOT_FOUND),i.lost.then(v(r,G,k)),d(r,f,i)}},G=new WeakSet,k=function(e){if(r.OnDeviceLost)return r.OnDeviceLost(e);a(r,E).dispatchEvent(new CustomEvent(J.DEVICE_LOST,{detail:e}));const t=(e.message&&` | Message: ${e.message}`)??".";m(l.DEVICE_LOST,` Reason: ${e.reason}`+t)},u(r,y),u(r,_),u(r,V),u(r,G),u(r,U,null),u(r,f,null),u(r,E,void 0),u(r,P,void 0),u(r,B,void 0),u(r,A,{powerPreference:void 0,forceFallbackAdapter:!1}),u(r,O,{label:void 0,requiredFeatures:[],requiredLimits:{}}),b(r,"OnDeviceLost");let p=r;console.info(`%cUWAL v${p.VERSION}`,"background:#005a9c;padding:3px;color:#fff;");var re="struct Screen{color: vec3f,time: f32};struct VertexOutput{@location(0)coords: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>screen: Screen;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=array(vec2f(-1.0,-1.0),vec2f(1.0,-1.0),vec2f(1.0,1.0),vec2f(1.0,1.0),vec2f(-1.0,1.0),vec2f(-1.0,-1.0));var output: VertexOutput;let coords=position[index];output.position=vec4f(coords,0,1);output.coords=coords;return output;}@fragment fn fragment(@location(0)coords: vec2f)->@location(0)vec4f {return vec4f(cos(coords.xyx+screen.time)*0.2+screen.color+0.4,1);}";/**
 * @example Screen Shader
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is inspired by OGL's Triangle Screen Shader
 * {@link https://oframe.github.io/ogl/examples/?src=triangle-screen-shader.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.2
 * @license MIT
 */let I;async function ie(o){let e;try{e=new(await p.RenderPipeline(o,"Screen Shader"))}catch(R){alert(R)}const t=e.CreateRenderPassDescriptor(e.CreateColorAttachment()),n=e.CreateShaderModule(re),i=e.CreateRenderPipeline({vertex:e.CreateVertexState(n),fragment:e.CreateFragmentState(n)}),s=Float32Array.BYTES_PER_ELEMENT+Float32Array.BYTES_PER_ELEMENT*3,c=e.CreateBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),D=e.CreateBindGroup({layout:i.getBindGroupLayout(0),entries:e.CreateBindGroupEntries({buffer:c})}),T=new Float32Array(s/Float32Array.BYTES_PER_ELEMENT);T.set([0,.3515625,.609375]);function L(R){T.set([R*.001],3),p.SetCanvasSize(o.width,o.height),t.colorAttachments[0].view=p.CurrentTextureView,e.WriteBuffer(c,T),e.Render(t,i,6),I=requestAnimationFrame(L)}new ResizeObserver(R=>{for(const W of R){const{inlineSize:X,blockSize:j}=W.contentBoxSize[0];p.SetCanvasSize(X,j)}e.AddBindGroups(D),I=requestAnimationFrame(L)}).observe(o)}function oe(){cancelAnimationFrame(I),p.Destroy()}export{oe as destroy,ie as run};
