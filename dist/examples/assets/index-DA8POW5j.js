import{D as p,C as L}from"./index-CE6-3cgY.js";import{a as T,b as R,S as M}from"./Shape-DlQiQpme.js";import{M as v}from"./Math-Cr7J2GA5.js";var O="struct VertexOutput{@location(0)textureCoord: vec2f,@builtin(position)position: vec4f,@location(1)@interpolate(flat)instance: u32};@group(1)@binding(0)var Sampler: sampler;@group(1)@binding(1)var Texture: texture_2d<f32>;@group(1)@binding(2)var<storage,read>visible: array<u32>;@vertex fn textureVertex(@location(0)position: vec2f,@location(1)translation: vec2f,@builtin(instance_index)instance: u32)->VertexOutput{var output: VertexOutput;let dpr=resolution.z*2.75;let aspect=resolution.xy/resolution.y;let clipSpace=GetVertexClipSpace(position).xy;output.position=vec4f(clipSpace+translation,0,1);output.textureCoord=clipSpace*aspect*dpr+0.5;output.instance=instance;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f,@location(1)@interpolate(flat)instance: u32)->@location(0)vec4f{if(visible[instance]==0){discard;}return textureSample(Texture,Sampler,textureCoord);}";const _=""+new URL("logo-DEvozEyj.jpg",import.meta.url).href;/**
 * @example Textures / Instancing
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is developed by using a version listed below.
 * Please note that this code may be simplified in future
 * thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */let l,a,S,w,f,q;async function j(d){try{a=new(await p.Renderer(d,"Textures / Instancing"))}catch(e){alert(e)}const m=128,s=256,y=new T(new R),t=new a.Pipeline;let u,h,c,x,o=512,g=performance.now()-o;const C=t.CreateShaderModule([M,O]);a.CreatePassDescriptor(a.CreateColorAttachment(new L(1651532)));const{buffer:b,layout:V}=t.CreateVertexBuffer("translation",s,"instance","textureVertex");t.WriteBuffer(b,F()),await a.AddPipeline(t,{fragment:t.CreateFragmentState(C),vertex:t.CreateVertexState(C,[y.GetPositionBufferLayout(t),V],void 0,"textureVertex")});function A(){cancelAnimationFrame(l),clearTimeout(h),g=performance.now()-o}async function D(){P(),y.Destroy(),z(),await I(),requestAnimationFrame(B),h=setTimeout(()=>o=~(c=-1),o*3)}function P(){const e=new R({radius:m}),[i,r]=a.CanvasSize,n=new T(e);n.SetRenderPipeline(t,a.ResolutionBuffer),t.SetDrawParams(e.Vertices,s),n.AddVertexBuffers(b),n.Position=[i/2,r/2],n.Rotation=Math.PI/4,n.Update()}function z(){const e=t.CreateStorageBuffer("visible",s);t.WriteBuffer(e.buffer,e.visible),x=(u=e.visible).length-1,f=e.buffer}function F(){const e=new Float32Array(s*2),i=1-Math.sqrt(2)*m/d.offsetWidth,r=1-Math.sqrt(2)*m/d.offsetHeight;for(let n=s;n--;)e.set([v.Random(-i,i),v.Random(-r,r)],n*2);return e}async function I(){const e=new(await p.Texture());w=await e.CopyImageToTexture(await e.CreateImageBitmap(_),{flipY:!0,create:{mipmaps:!1}}),t.AddBindGroupFromResources([e.CreateSampler(),w.createView(),f],0,1)}function B(e){l=requestAnimationFrame(B),!(e-g<o)&&(o?u.fill(0)&&(c=v.RandomInt(0,x)):++c===x&&cancelAnimationFrame(l),g=e,u[c]=1,t.WriteBuffer(f,u),a.Render())}S=new ResizeObserver(e=>{for(const i of e){let{inlineSize:r,blockSize:n}=i.contentBoxSize[0];r=r<=960&&r||r-240,a.SetCanvasSize(r,n)}A(),D()}),S.observe(document.body)}function E(){p.OnLost=()=>{},cancelAnimationFrame(l),S.disconnect(),a.Destroy(),p.Destroy([f,q],w)}export{E as destroy,j as run};
