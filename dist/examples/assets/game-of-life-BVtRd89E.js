import{d as e,p as t}from"./lib-B0aPbQsN.js";var n=`@group(0)@binding(0)var<uniform>grid: vec2f;@group(0)@binding(1)var<storage>cellStateIn: array<u32>;@group(0)@binding(2)var<storage,read_write>cellStateOut: array<u32>;fn cellIndex(cell: vec2u)->u32{return(cell.x % u32(grid.x))+(cell.y % u32(grid.y))*u32(grid.x);}fn cellActive(x: u32,y: u32)->u32{return cellStateIn[cellIndex(vec2(x,y))];}@compute @workgroup_size(8,8)fn compute(@builtin(global_invocation_id)cell: vec3u){let activeNeighbors=cellActive(cell.x+1,cell.y+1)+cellActive(cell.x+1,cell.y)+cellActive(cell.x+1,cell.y-1)+cellActive(cell.x,cell.y-1)+cellActive(cell.x-1,cell.y-1)+cellActive(cell.x-1,cell.y)+cellActive(cell.x-1,cell.y+1)+cellActive(cell.x,cell.y+1);let i=cellIndex(cell.xy);switch activeNeighbors{case 2:{cellStateOut[i]=cellStateIn[i];}case 3:{cellStateOut[i]=1;}default:{cellStateOut[i]=0;}}}`,r=`struct VertexOutput{@location(0)cell: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>grid: vec2f;@group(0)@binding(1)var<storage>state: array<u32>;@vertex fn vertex(@location(0)position: vec2f,@builtin(instance_index)instance: u32)->VertexOutput{let fInstance=f32(instance);let state=f32(state[instance]);let cell=vec2f(fInstance % grid.x,floor(fInstance/grid.x));var output: VertexOutput;output.position=vec4f((position*state+1)/grid-1+cell/grid*2,0,1);output.cell=cell;return output;}@fragment fn fragment(@location(0)cell: vec2f)->@location(0)vec4f {let rg=cell/grid;return vec4f(rg,1-rg.g,1);}`,i,a,o,s,c=[];async function l(l){try{a=new(await(t.Renderer(l,`Game Of Life Renderer`))),o=new(await(t.Computation(`Game Of Life Computation`)))}catch(e){alert(e)}let u=new a.Pipeline,d=new o.Pipeline,f=0,p=performance.now()-200,m=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX;a.CreatePassDescriptor(a.CreateColorAttachment(new e(102)));let h=d.CreatePipelineLayout(d.CreateBindGroupLayout([o.CreateBufferBindingLayout(`uniform`,!1,0,m|GPUShaderStage.FRAGMENT),o.CreateBufferBindingLayout(`read-only-storage`,!1,0,m),o.CreateBufferBindingLayout(`storage`)])),g=u.CreateShaderModule(r);await o.AddPipeline(d,{layout:h,module:d.CreateShaderModule(n)});let{layout:_,buffer:v}=u.CreateVertexBuffer(`position`,6);await a.AddPipeline(u,{layout:h,fragment:u.CreateFragmentState(g),vertex:u.CreateVertexState(g,_)}),u.WriteBuffer(v,new Float32Array([-.8,-.8,.8,-.8,.8,.8,.8,.8,-.8,.8,-.8,-.8])),u.SetVertexBuffers(v);function y(){cancelAnimationFrame(i),c.forEach(e=>e?.destroy()),p=performance.now()-200}function b(e=48){let t=a.AspectRatio,[n,r]=a.CanvasSize,{grid:s,buffer:l}=u.CreateUniformBuffer(`grid`);s.set(n<r?[e,Math.round(e/t)]:[Math.round(e*t),e]);let f=s[0]*s[1];u.WriteBuffer(l,s);let{cellStateIn:p,buffer:m}=d.CreateStorageBuffer(`cellStateIn`,f),{buffer:h}=d.CreateStorageBuffer(`cellStateOut`,f);for(let e=0;e<p.length;e++)p[e]=+(Math.random()>.6);d.WriteBuffer(h,p),d.WriteBuffer(m,p),c.push(l,m,h),o.Workgroups=[Math.ceil(s[0]/8),Math.ceil(s[1]/8)];let g=[d.CreateBindGroup(d.CreateBindGroupEntries([l,m,h])),d.CreateBindGroup(d.CreateBindGroupEntries([l,h,m]))];d.SetBindGroups(g),u.SetBindGroups(g),u.SetDrawParams(6,f),i=requestAnimationFrame(x)}function x(e){if(i=requestAnimationFrame(x),e-p<200)return;let t=o.CreateCommandEncoder();d.SetActiveBindGroups(f%2),o.Compute(!1),a.CommandEncoder=t,u.SetActiveBindGroups(++f%2),a.Render(),p=e}s=new ResizeObserver(e=>{for(let t of e){let{inlineSize:e,blockSize:n}=t.contentBoxSize[0];e=e<=960&&e||e-240,a.SetCanvasSize(e,n)}y(),b()}),s.observe(document.body)}function u(){t.OnLost=()=>void 0,cancelAnimationFrame(i),o.Destroy(),s.disconnect(),a.Destroy(),t.Destroy(c)}export{u as destroy,l as run};