import{a as B,T as p,E as S}from"./index-DHkQdOh-.js";import{M as g,a as s,b as n}from"./Math-Cr7J2GA5.js";var y="@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>matrix: mat3x3f;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn vertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}";const R=B({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});let G=class{#n;#u;#a;#c;#s;#r;#i;#t;constructor(t={segments:"SQUARE",radius:0}){const i=t.segments,e=typeof i=="number"&&i;this.#a=e||R[i||"SQUARE"],this.#n=t.radius??0,this.#c=t}#o(t,i="Shape"){let e=this.#t;if(!e){e=new Float32Array((this.#a+1)*2*3);const{endAngle:r=g.TAU,startAngle:a=0,innerRadius:o=0}=this.#c,h=r-a;for(let f=0,u=0,c=this.#a;u<=c;++u){const l=a+u*h/c,d=Math.cos(l),x=Math.sin(l);e[f++]=d*this.#n,e[f++]=x*this.#n,e[f++]=d*o,e[f++]=x*o}this.#r=t.CreateVertexBuffer(e,{label:`${i} Vertex Buffer`}),t.WriteBuffer(this.#r,e),t.SetVertexBuffers(this.#r)}}#e(t,i="Shape"){let e=this.#i;if(!e){e=new Uint16Array(this.#a*6);for(let r=0,a=0,o=this.#a;a<o;++a){const h=a*2;e[r++]=h+1,e[r++]=h+3,e[r++]=h+2,e[r++]=h+2,e[r++]=h+0,e[r++]=h+1}}this.#s=t.CreateIndexBuffer(e,{label:`${i} Index Buffer`}),t.SetDrawParams(this.#u=e.length),t.WriteBuffer(this.#s,e),t.SetIndexBuffer(...this.IndexBuffer)}CreateBuffers(t,i="Shape"){this.#o(t,i),this.#e(t,i)}set VertexData(t){this.#t=t}get VertexBuffer(){return this.#r}set IndexData(t){this.#i=t}get IndexBuffer(){return[this.#s,"uint16"]}get Vertices(){return this.#u}get Radius(){return this.#n}Destroy(){this.#i=void 0,this.#s?.destroy(),this.#t=void 0,this.#r?.destroy()}};class A{#n=s.create();#u=s.create();#a=s.create();#c=s.create();#s;#r;#i;#t;#o;#e;#f=!1;#l;#x;#p=n.set(1,1);#h=n.set(0,0);#B=n.set(0,0);#S=n.set(0,0);#d=B({min:n.create(),max:n.create()});static GetPositionBufferLayout(t,i="position",e="vertex",r="vertex"){return t.CreateVertexBufferLayout(i,e,r)}constructor(t,i,e="Shape"){this.#i=t,this.#l=i,this.#s=e,this.Scale=this.#p,this.Origin=this.#h,this.Position=this.#S,this.Rotation=this.#r??0}SetRenderPipeline(t,i){this.#e=t,this.#i.CreateBuffers(t,this.#s),this.#l?.CreateColorBuffer(t,this.#s),this.#m(i)}AddVertexBuffers(t,i,e){!this.#e&&p(S.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Use `Shape.SetRenderPipeline` method before adding vertex buffers."),this.#e.AddVertexBuffers(t,i,e)}#m(t){const{matrix:i,buffer:e}=this.#e.CreateUniformBuffer("matrix",{label:`${this.#s} Matrix Buffer`});this.#t=i,this.#o=e,this.#x=[t,e,this.#l?.ColorBuffer].filter(Boolean),this.#e.SetBindGroupFromResources(this.#x,0,0,`${this.#s} Bind Group`)}SetPipelineData(){!this.#e&&p(S.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Use `Shape.SetRenderPipeline` method before setting its data."),this.#e.SetBindGroupFromResources(this.#x);const{VertexBuffer:t,IndexBuffer:i,Vertices:e}=this.#i;this.#e.SetVertexBuffers(t),this.#e.SetIndexBuffer(...i),this.#e.SetDrawParams(e)}Update(){if(this.#f){s.multiply(this.#c,this.#a,this.#t),s.multiply(this.#t,this.#u,this.#t),s.multiply(this.#t,this.#n,this.#t),this.#e.WriteBuffer(this.#o,this.#t);const t=this.#B[0]=this.#t[8],i=this.#B[1]=this.#t[9],{Radius:e}=this.#i;this.#d.min[0]=t-e,this.#d.min[1]=i-e,this.#d.max[0]=t+e,this.#d.max[1]=i+e,this.#f=!1}}set Position(t){this.#S.set(t),s.translation(this.#S,this.#c),this.#f=!0}get Position(){return this.#S}set Rotation(t){this.#r=t,s.rotation(this.#r,this.#a),this.#f=!0}get Rotation(){return this.#r}set Scale(t){this.#p.set(t),s.scaling(this.#p,this.#u),this.#f=!0}get Scale(){return this.#p}set Origin(t){const{Radius:i}=this.#i;this.#h[0]=t[0],this.#h[1]=t[1],this.#h[0]*=-i,this.#h[1]*=-i,s.translation(this.#h,this.#n),this.#h[0]=t[0]||0,this.#h[1]=t[1]||0,this.#f=!0}get Origin(){return this.#h}get Center(){return this.Update(),this.#B}get Transform(){return this.Update(),this.#t}get BoundingBox(){return this.Update(),this.#d}get Geometry(){return this.#i}get Material(){return this.#l}Destroy(){this.#i.Destroy(),this.#l?.Destroy(),this.#e=void 0,this.#o?.destroy(),this.#o=void 0,this.#x?.splice(0)}}export{y as S,A as a,G as b};
