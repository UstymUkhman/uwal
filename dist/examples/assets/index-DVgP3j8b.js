var j=Object.defineProperty;var Y=(o,e,t)=>e in o?j(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var U=(o,e,t)=>(Y(o,typeof e!="symbol"?e+"":e,t),t),b=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var i=(o,e,t)=>(b(o,e,"read from private field"),t?t.call(o):e.get(o)),u=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},E=(o,e,t,r)=>(b(o,e,"write to private field"),r?r.call(o,t):e.set(o,t),t);var _=(o,e,t)=>(b(o,e,"access private method"),t);function G(o){const e={};for(let t in o)e[t]={value:o[t]};return Object.freeze(Object.create(null,e))}const H=G({DEVICE_LOST:"Device::Lost"}),D=G({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND"}),I=G({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder."}),J=G({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7});function K(o,e){console.warn(I[o]+(e??""))}function l(o,e){throw new Error(I[o]+(e??""),{cause:J[o]})}var N,h;class z{constructor(e,t){u(this,N,void 0);U(this,"Device");U(this,"BindGroups",[]);u(this,h,void 0);!e&&l(D.DEVICE_NOT_REQUESTED),this.Device=e,E(this,N,t)}CreateBuffer(e){return this.Device.createBuffer(e)}WriteBuffer(e,t,r=0,a,s){this.Device.queue.writeBuffer(e,r,t,a,s)}CopyBufferToBuffer(e,t,r,a=0,s=0){this.CommandEncoder.copyBufferToBuffer(e,a,t,s,r)}CreateShaderModule(e,t="",r,a){const s=Array.isArray(e)&&e.join(`

`)||e;return this.Device.createShaderModule({label:t,code:s,sourceMap:r,compilationHints:a})}CreateBindGroupEntries(e){return Array.isArray(e)&&e.map((t,r)=>({binding:r,resource:t}))||[{binding:0,resource:e}]}CreateBindGroup(e){return this.Device.createBindGroup(e)}AddBindGroups(e){this.BindGroups=Array.isArray(e)&&e||[e]}CreateCommandEncoder(){return E(this,h,this.Device.createCommandEncoder({label:i(this,N)}))}SubmitCommandBuffer(){this.Device.queue.submit([this.CommandEncoder.finish()])}get CommandEncoder(){if(!i(this,h)){const e=` ${i(this,N)&&`Label: "${i(this,N)}". `}`;return K(D.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one."),this.CreateCommandEncoder()}return i(this,h)}}N=new WeakMap,h=new WeakMap;var g,O;class Z extends z{constructor(t,r,a){super(t,r);u(this,g,void 0);u(this,O,void 0);E(this,g,a)}CreateColorAttachment(t,r="load",a="store",s,c,C){return{view:t,loadOp:r,storeOp:a,clearValue:s,resolveTarget:c,depthSlice:C}}CreateRenderPassDescriptor(t,r="",a,s,c,C){return{colorAttachments:Array.isArray(t)&&t||[t],depthStencilAttachment:a,occlusionQuerySet:s,timestampWrites:c,maxDrawCount:C,label:r}}CreateVertexState(t,r="vertex",a,s){return{module:t,entryPoint:r,constants:a,buffers:s}}CreateFragmentState(t,r="fragment",a,s){return a??(a=[{format:i(this,g)}]),{module:t,entryPoint:r,targets:a,constants:s}}CreateRenderPipeline(t){const r=t.layout??"auto";return this.Device.createRenderPipeline({...t,layout:r})}Render(t,r,a,s=!0){if(!i(this,O)){const c=this.CreateCommandEncoder();E(this,O,c.beginRenderPass(t)),i(this,O).setPipeline(r)}for(let c=0,C=this.BindGroups.length;c<C;++c)i(this,O).setBindGroup(c,this.BindGroups[c]);i(this,O).draw(...Array.isArray(a)&&a||[a]),s&&(i(this,O).end(),E(this,O,void 0),this.SubmitCommandBuffer())}get CurrentPass(){return i(this,O)}}g=new WeakMap,O=new WeakMap;var A;class ee extends z{constructor(t,r){super(t,r);u(this,A,[1])}CreateComputePassDescriptor(t="",r,a,s){return{label:t,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:a,endOfPassWriteIndex:s}:void 0}}CreateComputePipeline(t){const r=t.layout??"auto";return this.Device.createComputePipeline({label:t.label,layout:r,compute:t})}Compute(t,r){const a=this.CommandEncoder.beginComputePass(r);a.setPipeline(t);for(let s=0,c=this.BindGroups.length;s<c;++s)a.setBindGroup(s,this.BindGroups[s]);a.dispatchWorkgroups(...i(this,A)),a.end()}set Workgroups(t){E(this,A,Array.isArray(t)&&t||[t])}}A=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.1
 * @license MIT
 */var R,f,d,m,F,v,T,B,L,y,q,V,Q;const n=class n{static SetAdapterOptions(e=void 0,t=!1){i(n,v).powerPreference=e,i(n,v).forceFallbackAdapter=t}static SetDeviceDescriptor(e="",t=[],r={}){i(n,T).label=e,i(n,T).requiredFeatures=t,i(n,T).requiredLimits=r}static SetCanvasSize(e=innerWidth,t=innerHeight){!i(n,d)&&l(D.CANVAS_NOT_FOUND),!i(n,f)&&l(D.DEVICE_NOT_FOUND);const{maxTextureDimension2D:r}=i(n,f).limits;e=Math.max(1,Math.min(e,r)),t=Math.max(1,Math.min(t,r)),(i(n,d).width!==e||i(n,d).height!==t)&&(i(n,d).height=t,i(n,d).width=e)}static RenderPipeline(e,t="",r={}){return(async()=>{const a=await n.Device,s=e.getContext("webgpu");!s&&l(D.CONTEXT_NOT_FOUND);const c=r.format??i(n,F),C={...r,format:c};return s.configure({device:a,...C}),E(n,d,e),E(n,m,s),new Proxy(Z,{construct(P){return new P(a,t,c)}})})()}static ComputePipeline(e=""){return(async()=>{const t=await n.Device;return new Proxy(ee,{construct(r){return new r(t,e)}})})()}static Destroy(e,t,r){var a,s;e=Array.isArray(e)&&e||[e],e.forEach(c=>c==null?void 0:c.destroy()),t=Array.isArray(t)&&t||[t],t.forEach(c=>c==null?void 0:c.destroy()),r=Array.isArray(r)&&r||[r],r.forEach(c=>c==null?void 0:c.destroy()),(a=i(n,m))==null||a.unconfigure(),(s=i(n,f))==null||s.destroy()}static get Adapter(){return(async()=>{var e;return i(n,R)??await _(e=n,B,L).call(e)()})()}static get Device(){return(async()=>{var e;return i(n,f)??await _(e=n,y,q).call(e)()})()}static get Canvas(){return i(n,d)}static get Context(){return i(n,m)}static get AspectRatio(){return!i(n,d)&&l(D.CANVAS_NOT_FOUND),i(n,d).width/i(n,d).height}static get CurrentTexture(){return i(n,m).getCurrentTexture()}static get CurrentTextureView(){return n.CurrentTexture.createView()}static get VERSION(){return"0.0.1"}};R=new WeakMap,f=new WeakMap,d=new WeakMap,m=new WeakMap,F=new WeakMap,v=new WeakMap,T=new WeakMap,B=new WeakSet,L=function(){return!navigator.gpu&&l(D.WEBGPU_NOT_SUPPORTED),E(n,F,navigator.gpu.getPreferredCanvasFormat()),async()=>{const e=await navigator.gpu.requestAdapter(i(n,v));return!e&&l(D.ADAPTER_NOT_FOUND),E(n,R,e)}},y=new WeakSet,q=function(){return async()=>{const{requiredFeatures:e,requiredLimits:t,label:r}=i(n,T),a=await(await n.Adapter).requestDevice({requiredFeatures:e,requiredLimits:t,defaultQueue:{label:r}});return!a&&l(D.DEVICE_NOT_FOUND),a.lost.then(_(n,V,Q)),E(n,f,a)}},V=new WeakSet,Q=function(e){if(n.OnDeviceLost)return n.OnDeviceLost(e);i(n,d).dispatchEvent(new CustomEvent(H.DEVICE_LOST,{detail:e}));const t=(e.message&&` | Message: ${e.message}`)??".";l(D.DEVICE_LOST,` Reason: ${e.reason}`+t)},u(n,B),u(n,y),u(n,V),u(n,R,null),u(n,f,null),u(n,d,void 0),u(n,m,void 0),u(n,F,void 0),u(n,v,{powerPreference:void 0,forceFallbackAdapter:!1}),u(n,T,{label:"",requiredFeatures:[],requiredLimits:{}}),U(n,"OnDeviceLost");let p=n;console.info(`%cUWAL v${p.VERSION}`,"background:#005a9c;padding:3px;color:#fff;");var te="struct Screen{color: vec3f,time: f32};struct VertexOutput{@location(0)coords: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>screen: Screen;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=array(vec2f(-1.0,-1.0),vec2f(1.0,-1.0),vec2f(1.0,1.0),vec2f(1.0,1.0),vec2f(-1.0,1.0),vec2f(-1.0,-1.0));var output: VertexOutput;let coords=position[index];output.position=vec4f(coords,0,1);output.coords=coords;return output;}@fragment fn fragment(@location(0)coords: vec2f)->@location(0)vec4f {return vec4f(cos(coords.xyx+screen.time)*0.2+screen.color+0.4,1);}";/**
 * @example Screen Shader
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is inspired by OGL's Triangle Screen Shader
 * {@link https://oframe.github.io/ogl/examples/?src=triangle-screen-shader.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.2
 * @license MIT
 */let x;async function ie(o){let e;try{e=new(await p.RenderPipeline(o,"Screen Shader Encoder"))}catch(S){alert(S)}const t=e.CreateRenderPassDescriptor(e.CreateColorAttachment(),"Screen Shader Render Pass"),r=e.CreateShaderModule(te,"Screen Shader Uniforms"),a=e.CreateVertexState(r),s=e.CreateFragmentState(r),c=e.CreateRenderPipeline({label:"Screen Shader Pipeline",vertex:a,fragment:s}),C=Float32Array.BYTES_PER_ELEMENT+Float32Array.BYTES_PER_ELEMENT*3,P=e.CreateBuffer({label:"Screen Shader Uniform Buffer",size:C,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),W=e.CreateBindGroup({label:"Screen Shader Uniform Buffer Bind Group",layout:c.getBindGroupLayout(0),entries:e.CreateBindGroupEntries({buffer:P})}),w=new Float32Array(C/Float32Array.BYTES_PER_ELEMENT);w.set([0,.3515625,.609375]);function M(S){w.set([S*.001],3),p.SetCanvasSize(o.width,o.height),t.colorAttachments[0].view=p.CurrentTextureView,e.WriteBuffer(P,w),e.Render(t,c,6),x=requestAnimationFrame(M)}new ResizeObserver(S=>{for(const k of S){const{inlineSize:X,blockSize:$}=k.contentBoxSize[0];p.SetCanvasSize(X,$)}e.AddBindGroups(W),x=requestAnimationFrame(M)}).observe(o)}function ae(){cancelAnimationFrame(x),p.Destroy()}export{ae as destroy,ie as run};
