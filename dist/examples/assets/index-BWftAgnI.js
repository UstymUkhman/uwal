var J=Object.defineProperty;var K=(o,t,e)=>t in o?J(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var _=(o,t,e)=>(K(o,typeof t!="symbol"?t+"":t,e),e),$=(o,t,e)=>{if(!t.has(o))throw TypeError("Cannot "+e)};var s=(o,t,e)=>($(o,t,"read from private field"),e?e.call(o):t.get(o)),c=(o,t,e)=>{if(t.has(o))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(o):t.set(o,e)},h=(o,t,e,r)=>($(o,t,"write to private field"),r?r.call(o,e):t.set(o,e),e);var N=(o,t,e)=>($(o,t,"access private method"),e);const Z={REQUIRED_SEGMENTS:"REQUIRED_SEGMENTS"},ee={REQUIRED_SEGMENTS:"Shape `segments` is required to be an integer value."};function v(o){for(let t in o)o[t]={value:o[t]};return Object.freeze(Object.create(null,o))}v({DEVICE_LOST:"Device::Lost"});const D=v({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND",PIPELINE_NOT_FOUND:"PIPELINE_NOT_FOUND",...Z}),q=v({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder.",PIPELINE_NOT_FOUND:"Failed to get a GPU",...ee}),te=v({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7,PIPELINE_NOT_FOUND:8});function re(o,t){console.warn(q[o]+(t??""))}function O(o,t){throw new Error(q[o]+(t??""),{cause:te[o]})}var f,T,P,C;class j{constructor(t,e,r){c(this,f,void 0);c(this,T,void 0);c(this,P,void 0);_(this,"Device");_(this,"BindGroups",[]);c(this,C,void 0);_(this,"Pipeline");_(this,"Descriptor");!t&&O(D.DEVICE_NOT_REQUESTED),h(this,f,r),this.Device=t,h(this,T,e),h(this,P,this.CreateProgramLabel("Command Encoder"))}CreateProgramLabel(t){return s(this,T)&&t&&`${s(this,T)} ${t}`||""}CreatePipelineLayout(t,e){const r=Array.isArray(t)&&t||[t];return e??(e=this.CreateProgramLabel(`${s(this,f)} Pipeline Layout`)),this.Device.createPipelineLayout({label:e,bindGroupLayouts:r})}CreateShaderModule(t,e,r,i){e??(e=this.CreateProgramLabel("Shader Module"));const a=Array.isArray(t)&&t.join(`

`)||t;return this.Device.createShaderModule({label:e,code:a,sourceMap:r,compilationHints:i})}CreateBuffer(t){const e=t.label??this.CreateProgramLabel("Buffer");return this.Device.createBuffer({...t,label:e})}WriteBuffer(t,e,r=0,i,a){this.Device.queue.writeBuffer(t,r,e,i,a)}CopyBufferToBuffer(t,e,r,i=0,a=0){this.GetCommandEncoder(!0).copyBufferToBuffer(t,i,e,a,r)}CreateBindGroupLayout(t,e){e??(e=this.CreateProgramLabel("Bind Group Layout")),t=Array.isArray(t)&&t.map((i,a)=>({...i,binding:i.binding??a}))||[{...t,binding:t.binding??0}];const r=t;return this.Device.createBindGroupLayout({entries:r,label:e})}CreateBindGroupEntries(t,e=0){return Array.isArray(t)&&t.map((r,i)=>({binding:(e==null?void 0:e[i])??i,resource:r}))||[{binding:e,resource:t}]}CreateBindGroup(t,e=0,r){return r??(r=this.CreateProgramLabel("Bind Group")),typeof e=="number"&&(e=this.Pipeline?this.Pipeline.getBindGroupLayout(e):O(D.PIPELINE_NOT_FOUND,`${s(this,f)}Pipeline.`)),this.Device.createBindGroup({entries:t,label:r,layout:e})}SetBindGroups(t){this.BindGroups=Array.isArray(t)&&t||[t]}AddBindGroups(t){this.BindGroups.push(...Array.isArray(t)&&t||[t])}ClearBindGroups(){this.BindGroups.splice(0)}CreateCommandEncoder(){return h(this,C,this.Device.createCommandEncoder({label:s(this,P)}))}SetCommandEncoder(t){h(this,C,t)}GetCommandEncoder(t=!1){if(!s(this,C)){if(t){const e=` ${s(this,P)&&`Label: "${s(this,P)}". `}`;re(D.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one.")}return this.CreateCommandEncoder()}return s(this,C)}DestroyCommandEncoder(){h(this,C,void 0)}SubmitCommandBuffer(){this.Device.queue.submit([s(this,C).finish()])}set CommandEncoderLabel(t){h(this,P,t)}get ProgramName(){return s(this,T)}GetDescriptor(){return this.Descriptor}GetPipeline(){return this.Pipeline}}f=new WeakMap,T=new WeakMap,P=new WeakMap,C=new WeakMap;var y,g,E,m,R,U,S,d,u,I,Q;class ie extends j{constructor(e,r,i,a){super(e,r,"Render");c(this,I);c(this,y,void 0);c(this,g,new Float32Array(2));c(this,E,void 0);c(this,m,void 0);c(this,R,void 0);c(this,U,[]);c(this,S,void 0);c(this,d,void 0);c(this,u,void 0);!i&&O(D.CANVAS_NOT_FOUND);const l=i.getContext("webgpu");!l&&O(D.CONTEXT_NOT_FOUND),h(this,S,a.format??navigator.gpu.getPreferredCanvasFormat()),l.configure({device:e,...a,format:s(this,S)}),h(this,R,this.CreateBuffer({size:s(this,g).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Render Pipeline Resolution Buffer"})),h(this,E,i),h(this,m,l),N(this,I,Q).call(this)}SetCanvasSize(e,r){!this.Device&&O(D.DEVICE_NOT_FOUND),!s(this,E)&&O(D.CANVAS_NOT_FOUND);const{maxTextureDimension2D:i}=this.Device.limits;e=Math.max(1,Math.min(e,i)),r=Math.max(1,Math.min(r,i)),(s(this,E).width!==e||s(this,E).height!==r)&&(s(this,E).width=e,s(this,E).height=r,N(this,I,Q).call(this))}CreateColorAttachment(e,r="load",i="store",a,l,x){return{view:e,loadOp:r,storeOp:i,clearValue:a,resolveTarget:l,depthSlice:x}}CreatePassDescriptor(e,r,i,a,l,x){const Y=Array.isArray(e)&&e||[e];return r??(r=this.CreateProgramLabel("Render Pass")),this.Descriptor={colorAttachments:Y,depthStencilAttachment:i,occlusionQuerySet:a,timestampWrites:l,maxDrawCount:x,label:r}}SetPassDescriptor(e){this.Descriptor=e}CreateVertexBufferAttribute(e,r=0,i=0){return{format:e,shaderLocation:r,offset:i}}CreateVertexState(e,r="vertex",i,a){return i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,buffers:i,constants:a}}CreateFragmentColorTarget(e=s(this,S),r,i){return{format:e,blend:r,writeMask:i}}CreateFragmentState(e,r="fragment",i,a){return i??(i=[this.CreateFragmentColorTarget()]),i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,targets:i,constants:a}}CreatePipeline(e){const r=e.layout??"auto",i=e.label??this.CreateProgramLabel("Render Pipeline");return this.Pipeline=this.Device.createRenderPipeline({...e,label:i,layout:r})}SetPipeline(e){this.Pipeline=e}SetVertexBuffers(e){h(this,U,Array.isArray(e)&&e||[e])}SetIndexBuffer(e,r="uint32",i,a){h(this,d,{buffer:e,format:r,offset:i,size:a})}Render(e,r=!0){s(this,u)||(h(this,u,this.GetCommandEncoder().beginRenderPass(this.Descriptor)),s(this,u).setPipeline(this.Pipeline),h(this,y,s(this,d)?s(this,u).drawIndexed.bind(s(this,u)):s(this,u).draw.bind(s(this,u))));for(let i=0,a=s(this,U).length;i<a;++i)s(this,u).setVertexBuffer(i,s(this,U)[i]);s(this,d)&&s(this,u).setIndexBuffer(s(this,d).buffer,s(this,d).format,s(this,d).offset,s(this,d).size);for(let i=0,a=this.BindGroups.length;i<a;++i)s(this,u).setBindGroup(i,this.BindGroups[i]);s(this,y).call(this,...Array.isArray(e)&&e||[e]),r&&this.Submit()}Submit(){s(this,u).end(),this.SubmitCommandBuffer(),this.DestroyCommandEncoder(),h(this,u,void 0)}Destroy(){var e;(e=s(this,m))==null||e.unconfigure()}get Canvas(){return s(this,E)}get Context(){return s(this,m)}get AspectRatio(){return!s(this,E)&&O(D.CANVAS_NOT_FOUND),s(this,E).width/s(this,E).height}get CurrentTexture(){return s(this,m).getCurrentTexture()}get CurrentTextureView(){return this.CurrentTexture.createView()}get ResolutionBuffer(){return s(this,R)}get CurrentPass(){return s(this,u)}}y=new WeakMap,g=new WeakMap,E=new WeakMap,m=new WeakMap,R=new WeakMap,U=new WeakMap,S=new WeakMap,d=new WeakMap,u=new WeakMap,I=new WeakSet,Q=function(){s(this,g).set([s(this,E).width,s(this,E).height]),this.WriteBuffer(s(this,R),s(this,g))};var L;class se extends j{constructor(e,r){super(e,r,"Compute");c(this,L,[1])}CreatePassDescriptor(e,r,i,a){return e??(e=this.CreateProgramLabel("Compute Pass")),this.Descriptor={label:e,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:i,endOfPassWriteIndex:a}:void 0}}SetPassDescriptor(e){this.Descriptor=e}CreatePipeline(e){const r=e.layout??"auto",i=e.label??this.CreateProgramLabel("Compute Pipeline");return this.Pipeline=this.Device.createComputePipeline({label:i,layout:r,compute:e})}SetPipeline(e){this.Pipeline=e}Compute(){const e=this.GetCommandEncoder().beginComputePass(this.Descriptor);e.setPipeline(this.Pipeline);for(let r=0,i=this.BindGroups.length;r<i;++r)e.setBindGroup(r,this.BindGroups[r]);e.dispatchWorkgroups(...s(this,L)),e.end()}set Workgroups(e){h(this,L,Array.isArray(e)&&e||[e])}}L=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.4
 * @license MIT
 */var G,B,A,p,F,V,W,b,k,w,z,M,H;const n=class n{static SetAdapterOptions(t,e=!1){s(n,B).powerPreference=t,s(n,B).forceFallbackAdapter=e}static SetDeviceDescriptor(t,e=[],r={}){s(n,p).label=t,s(n,p).requiredFeatures=e,s(n,p).requiredLimits=r}static RenderPipeline(t,e="",r={}){return N(this,V,W).call(this,e),(async()=>{const i=await n.Device;return new Proxy(ie,{construct(a){return new a(i,e,t,r)}})})()}static ComputePipeline(t=""){return N(this,V,W).call(this,t),(async()=>{const e=await n.Device;return new Proxy(se,{construct(r){return new r(e,t)}})})()}static Destroy(t,e,r){var i;t=Array.isArray(t)&&t||[t],t.forEach(a=>a==null?void 0:a.destroy()),e=Array.isArray(e)&&e||[e],e.forEach(a=>a==null?void 0:a.destroy()),r=Array.isArray(r)&&r||[r],r.forEach(a=>a==null?void 0:a.destroy()),(i=s(n,A))==null||i.destroy(),n.SetAdapterOptions(),n.SetDeviceDescriptor(),h(n,F,void 0),h(n,G,h(n,A,null))}static get AdapterLimits(){return s(this,F)}static get Adapter(){return(async()=>{var t;return s(n,G)??await N(t=n,w,z).call(t)()})()}static get Device(){return(async()=>{var t;return s(n,A)??await N(t=n,M,H).call(t)()})()}static get VERSION(){return"0.0.4"}};G=new WeakMap,B=new WeakMap,A=new WeakMap,p=new WeakMap,F=new WeakMap,V=new WeakSet,W=function(t){var e;(e=s(n,p)).label??(e.label=t&&`${t} Device`||"")},b=new WeakSet,k=function(t){if(n.OnDeviceLost)return n.OnDeviceLost(t);const e=(t.message&&` | Message: ${t.message}`)??".";O(D.DEVICE_LOST,` Reason: ${t.reason}`+e)},w=new WeakSet,z=function(){return!navigator.gpu&&O(D.WEBGPU_NOT_SUPPORTED),async()=>{const t=await navigator.gpu.requestAdapter(s(n,B));return!t&&O(D.ADAPTER_NOT_FOUND),h(this,F,t.limits),h(n,G,t)}},M=new WeakSet,H=function(){return async()=>{const{requiredFeatures:t,requiredLimits:e,label:r}=s(n,p),i=await(await n.Adapter).requestDevice({requiredFeatures:t,requiredLimits:e,defaultQueue:{label:r}});return!i&&O(D.DEVICE_NOT_FOUND),i.lost.then(N(n,b,k)),h(n,A,i)}},c(n,V),c(n,b),c(n,w),c(n,M),c(n,G,null),c(n,B,{powerPreference:void 0,forceFallbackAdapter:!1}),c(n,A,null),c(n,p,{label:void 0,requiredFeatures:[],requiredLimits:{}}),c(n,F,void 0),_(n,"OnDeviceLost");let X=n;const ne=v({HPI:Math.PI/2,TAU:Math.PI*2});v({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});console.info("%cUWAL v0.0.4","background:#005a9c;padding:3px;color:#fff;");export{v as C,D as E,ne as N,O as T,X as U};
