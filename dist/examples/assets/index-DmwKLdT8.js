import{D as p,C as L,M as S}from"./index-BvoO-MNg.js";import{C as O,a as _,S as j,b as q}from"./Camera2D-C-bxeTr1.js";var U="struct VertexOutput{@location(0)textureCoord: vec2f,@builtin(position)position: vec4f,@location(1)@interpolate(flat)instance: u32};@group(1)@binding(0)var Sampler: sampler;@group(1)@binding(1)var Texture: texture_2d<f32>;@group(1)@binding(2)var<uniform>resolution: vec3f;@group(1)@binding(3)var<storage,read>visible: array<u32>;@vertex fn textureVertex(@location(0)position: vec2f,@location(1)translation: vec2f,@builtin(instance_index)instance: u32)->VertexOutput{var output: VertexOutput;let dpr=resolution.z*2.75;let aspect=resolution.xy/resolution.y;let clipSpace=GetVertexClipSpace(position).xy;output.position=vec4f(clipSpace+translation,0,1);output.textureCoord=clipSpace*aspect*dpr+0.5;output.instance=instance;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f,@location(1)@interpolate(flat)instance: u32)->@location(0)vec4f{if(visible[instance]==0){discard;}return textureSample(Texture,Sampler,textureCoord);}";const W=""+new URL("logo-DEvozEyj.jpg",import.meta.url).href;/**
 * @example Textures / Instancing
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is developed by using a version listed below.
 * Please note that this code may be simplified in future
 * thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */let l,r,w,C,f,G;async function H(d){try{r=new(await p.Renderer(d,"Textures / Instancing"))}catch(e){alert(e)}const y=new O,m=128,i=256,t=new r.Pipeline,x=new _({radius:m});let s,b,u,v,o=512,g=performance.now()-o;const h=t.CreateShaderModule([j,U]);r.CreatePassDescriptor(r.CreateColorAttachment(new L(1651532)));const{buffer:T,layout:R}=t.CreateVertexBuffer("translation",i,"instance","textureVertex");await r.AddPipeline(t,{fragment:t.CreateFragmentState(h),vertex:t.CreateVertexState(h,[x.GetPositionBufferLayout(t),R],void 0,"textureVertex")}),P();function V(){cancelAnimationFrame(l),clearTimeout(b),g=performance.now()-o}async function z(){A(),D(),await F(),requestAnimationFrame(B),b=setTimeout(()=>o=~(u=-1),o*3)}function A(){const e=new q(x);e.SetRenderPipeline(t);const[n,a]=r.CanvasSize;t.AddVertexBuffers(T),t.SetDrawParams(x.Vertices,i),e.Transform=[[n/2,a/2],Math.PI/4],e.UpdateProjectionMatrix(y.ProjectionMatrix)}function P(){const e=new Float32Array(i*2),n=1-Math.sqrt(2)*m/d.offsetWidth,a=1-Math.sqrt(2)*m/d.offsetHeight;for(let c=i;c--;){const M=S.Random(-n,n),I=S.Random(-a,a);e.set([M,I],c*2)}t.WriteBuffer(T,e)}function D(){const e=t.CreateStorageBuffer("visible",i);t.WriteBuffer(e.buffer,e.visible),v=(s=e.visible).length-1,f=e.buffer}async function F(){const{ResolutionBuffer:e}=r,n=new(await p.Texture());C=await n.CopyImageToTexture(await n.CreateImageBitmap(W),{flipY:!0,create:{mipmaps:!1}}),t.AddBindGroupFromResources([n.CreateSampler(),C.createView(),e,f],0,1)}function B(e){l=requestAnimationFrame(B),!(e-g<o)&&(o?s.fill(0)&&(u=S.RandomInt(0,v)):++u===v&&cancelAnimationFrame(l),g=e,s[u]=1,t.WriteBuffer(f,s),r.Render())}w=new ResizeObserver(e=>{for(const n of e){let{inlineSize:a,blockSize:c}=n.contentBoxSize[0];a=a<=960&&a||a-240,r.SetCanvasSize(a,c),y.Size=r.CanvasSize}V(),z()}),w.observe(document.body)}function Y(){p.OnLost=()=>{},cancelAnimationFrame(l),w.disconnect(),r.Destroy(),p.Destroy([f,G],C)}export{Y as destroy,H as run};
