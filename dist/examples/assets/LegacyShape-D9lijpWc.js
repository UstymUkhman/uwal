var Y=a=>{throw TypeError(a)};var I=(a,e,i)=>e.has(a)||Y("Cannot "+i);var t=(a,e,i)=>(I(a,e,"read from private field"),i?i.call(a):e.get(a)),s=(a,e,i)=>e.has(a)?Y("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,i),h=(a,e,i,n)=>(I(a,e,"write to private field"),n?n.call(a,i):e.set(a,i),i),G=(a,e,i)=>(I(a,e,"access private method"),i);import{b as l,c as j,d as k,N as K,G as q}from"./index-BNSavNwh.js";var Z="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn shapeVertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}",f,v,x,M,w,F,T,m,B,P,C,o,S,d,r,g,A,b,u,V,E,U,y,c,z,H,J,L;class tt{constructor(e){s(this,c);s(this,f);s(this,v,0);s(this,x,!1);s(this,M,l.create());s(this,w,l.create());s(this,F,l.create());s(this,T,l.create());s(this,m);s(this,B);s(this,P);s(this,C);s(this,o);s(this,S);s(this,d);s(this,r);s(this,g,[]);s(this,A,[void 0]);s(this,b,new Float32Array([1,1]));s(this,u,new Float32Array([0,0]));s(this,V,new Float32Array([0,0]));s(this,E,new Float32Array([0,0]));s(this,U);s(this,y,j({min:k.create(),max:k.create()}));h(this,r,e.renderer),h(this,B,e.segments),h(this,f,e.radius??0),h(this,m,e.label??"Shape");const{startAngle:i,endAngle:n,innerRadius:p}=e;G(this,c,z).call(this,i,n,p),G(this,c,H).call(this),G(this,c,J).call(this),this.Scale=t(this,b),this.Origin=t(this,u),this.Rotation=t(this,v),this.Position=t(this,E)}Update(){return t(this,r).SetVertexBuffers(t(this,g)),t(this,r).SetIndexBuffer(t(this,S)),t(this,r).SetBindGroups(t(this,A)),G(this,c,L).call(this)}Render(e=!0){t(this,r).SavePipelineState(),t(this,r).Render(t(this.Update(),P),e),t(this,r).RestorePipelineState()}AddBindGroups(e){t(this,A).push(...q(e))}AddVertexBuffers(e){t(this,g).push(...q(e))}set Color(e){t(this,C).set(Array.isArray(e)||ArrayBuffer.isView(e)?e:e.rgba),t(this,r).WriteBuffer(t(this,d),t(this,C),t(this,U).color)}get Color(){return t(this,C)}set Position(e){t(this,E).set(e),l.translation(t(this,E),t(this,T)),h(this,x,!0)}get Position(){return t(this,E)}set Rotation(e){h(this,v,e),l.rotation(t(this,v),t(this,F)),h(this,x,!0)}get Rotation(){return t(this,v)}set Scale(e){t(this,b).set(e),l.scaling(t(this,b),t(this,w)),h(this,x,!0)}get Scale(){return t(this,b)}set Origin(e){t(this,u)[0]=e[0],t(this,u)[1]=e[1],t(this,u)[0]*=-t(this,f),t(this,u)[1]*=-t(this,f),l.translation(t(this,u),t(this,M)),t(this,u)[0]=e[0]||0,t(this,u)[1]=e[1]||0,h(this,x,!0)}get Origin(){return t(this,u)}get Center(){return t(G(this,c,L).call(this),V)}get Vertices(){return t(this,P)}get Transform(){return t(this,o)}get BoundingBox(){return t(this,y)}Destroy(){t(this,g).forEach(e=>e.destroy()),h(this,d,t(this,d).destroy()),h(this,S,t(this,S).destroy()),t(this,g).splice(0),t(this,A).splice(0)}}f=new WeakMap,v=new WeakMap,x=new WeakMap,M=new WeakMap,w=new WeakMap,F=new WeakMap,T=new WeakMap,m=new WeakMap,B=new WeakMap,P=new WeakMap,C=new WeakMap,o=new WeakMap,S=new WeakMap,d=new WeakMap,r=new WeakMap,g=new WeakMap,A=new WeakMap,b=new WeakMap,u=new WeakMap,V=new WeakMap,E=new WeakMap,U=new WeakMap,y=new WeakMap,c=new WeakSet,z=function(e=0,i=K.TAU,n=0){const p=i-e,R=new Float32Array((t(this,B)+1)*2*3);for(let O=0,_=0;_<=t(this,B);++_){const W=e+_*p/t(this,B),$=Math.cos(W),D=Math.sin(W);R[O++]=$*t(this,f),R[O++]=D*t(this,f),R[O++]=$*n,R[O++]=D*n}const N=t(this,r).CreateVertexBuffer(R,{label:`${t(this,m)} Vertex Buffer`});t(this,r).WriteBuffer(N,R),t(this,g).push(N)},H=function(){const e=new Uint32Array(h(this,P,t(this,B)*6));for(let i=0,n=0;n<t(this,B);++n){const p=n*2;e[i++]=p+1,e[i++]=p+3,e[i++]=p+2,e[i++]=p+2,e[i++]=p+0,e[i++]=p+1}h(this,S,t(this,r).CreateIndexBuffer(e,{label:`${t(this,m)} Index Buffer`})),t(this,r).WriteBuffer(t(this,S),e)},J=function(){const{buffer:e,shape:{color:i,matrix:n}}=t(this,r).CreateUniformBuffer("shape",{label:`${t(this,m)} Uniform Buffer`});h(this,d,e),h(this,o,n),h(this,C,i),t(this,A)[0]=t(this,r).CreateBindGroup(t(this,r).CreateBindGroupEntries([{buffer:t(this,r).ResolutionBuffer},{buffer:t(this,d)}]),0,`${t(this,m)} Bind Group`),h(this,U,j({matrix:i.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT}))},L=function(){if(t(this,x)){l.multiply(t(this,T),t(this,F),t(this,o)),l.multiply(t(this,o),t(this,w),t(this,o)),l.multiply(t(this,o),t(this,M),t(this,o)),t(this,r).WriteBuffer(t(this,d),t(this,o),t(this,U).matrix);const e=t(this,V)[0]=t(this,o)[8],i=t(this,V)[1]=t(this,o)[9];t(this,y).min[0]=e-t(this,f),t(this,y).min[1]=i-t(this,f),t(this,y).max[0]=e+t(this,f),t(this,y).max[1]=i+t(this,f),h(this,x,!1)}return this};export{tt as L,Z as S};
