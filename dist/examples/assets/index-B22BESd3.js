import{m as o,v as L,a as N,T as Y,E as q,M as a,D as U,F as E,C as H}from"./index-qOH1w7rj.js";class D{Children=[];Label;#r=null;RotationOrder="XYZ";TransformationOrder="TRS";ProjectionMatrix=o.identity();#t=o.identity();#s=o.identity();#o=L.set(1,1,1);#n=L.create();#e=L.create();constructor(t,e=null){this.Label=t,this.Parent=e}Add(t){t=N(t),t.forEach(e=>e.Parent=this)}Remove(t){t=N(t),t.forEach(e=>e.Parent=null)}Find(t){if(this.Label===t)return this;for(const e=0,r=this.Children.length;e<r;e++){const i=this.Children[e].Find(t);if(i)return i}return null}ResetLocalMatrix(){this.#t=o.identity()}UpdateWorldMatrix(){this.#i(),this.#r?o.multiply(this.#r.WorldMatrix,this.#t,this.#s):o.copy(this.#t,this.#s),this.Children.forEach(t=>t.UpdateWorldMatrix())}#i(){const t=this.TransformationOrder.split("");for(let e=0,r=t.length;e<r;e++)switch(t[e]){case"T":o.translation(this.#n,this.#t);break;case"R":for(let i=0,h=this.RotationOrder.length;i<h;++i){const s=this.RotationOrder[i],c=this.#e[s.charCodeAt()-88];o[`rotate${s}`](this.#t,c,this.#t)}break;case"S":o.scale(this.#t,this.#o,this.#t);break}}UpdateProjectionMatrix(t){const e=this.#r&&this.#s||this.#t;return o.multiply(t,e,this.ProjectionMatrix)}ResetProjectionMatrix(){this.ProjectionMatrix=o.identity()}Translate(t){o.translate(this.#t,t,this.#t)}RotateAxis(t,e){o.rotate(this.#t,t,e,this.#t)}RotateX(t){o.rotateX(this.#t,t,this.#t)}RotateY(t){o.rotateY(this.#t,t,this.#t)}RotateZ(t){o.rotateZ(this.#t,t,this.#t)}Scale(t){o.scale(this.#t,t,this.#t)}set Transform(t){const[e,r,i]=t,h=this.TransformationOrder.split("");for(let s=0,c=h.length;s<c;s++)switch(h[s]){case"T":e&&(this.Position=e);break;case"R":r&&(this.Rotation=r);break;case"S":i&&(this.Scaling=i);break}}set Position(t){L.copy(t,this.#n),o.translation(t,this.#t)}get Position(){return this.#n}set Rotation(t){L.copy(t,this.#e);for(let e=0,r=this.RotationOrder.length;e<r;++e){const i=this.RotationOrder[e],h=t[i.charCodeAt()-88];o[`rotate${i}`](this.#t,h,this.#t)}}get Rotation(){return this.#e}set Scaling(t){L.copy(t,this.#o),o.scale(this.#t,t,this.#t)}get Scaling(){return this.#o}get LocalMatrix(){return this.#t}get WorldMatrix(){return this.#s}set Parent(t){if(this.#r){const e=this.#r.Children.indexOf(this);0<=e&&this.#r.Children.splice(e,1)}t&&t.Children.push(this),this.#r=t}get Parent(){return this.#r}}let z=class extends D{#r;Visible=!0;#t;#s;#o;#n=[];constructor(t,e,r="Mesh",i=null){super(r,i),this.#r=t,this.#o=e}SetRenderPipeline(t,e=!0){this.#t=t,this.#r.CreateBuffers(t),this.#o?.CreateColorBuffer(t),this.#e(e)}#e(t=!0,e){const{projection:r,buffer:i}=this.#t.CreateUniformBuffer("projection",{label:`${this.Label} Projection Buffer`,...e});this.ProjectionMatrix=o.identity(r),this.#s=i,t&&(this.#n=this.#t.SetBindGroupFromResources([i,this.#o?.ColorBuffer].filter(Boolean),0,0,`${this.Label} Bind Group`))}UpdateProjectionMatrix(t){const e=super.UpdateProjectionMatrix(t);this.#t.WriteBuffer(this.#s,e)}SetPipelineData(){!this.#t&&Y(q.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Mesh.SetRenderPipeline` method before setting its data.");const{VertexBuffers:t,IndexBuffer:e,Vertices:r}=this.#r;this.#t.BindGroups=this.#n,this.#t.VertexBuffers=t,this.#t.IndexBuffer=e,this.#t.SetDrawParams(r)}get ProjectionBuffer(){return this.#s}get Geometry(){return this.#r}get Material(){return this.#o}Destroy(){this.#r.Destroy(),this.#o?.Destroy(),this.#t=void 0,this.#n.splice(0),this.#s.destroy(),this.#s=void 0}};var X="@group(0)@binding(0)var<uniform>projection: mat4x4f;fn GetVertexClipSpace(position: vec4f)->vec4f{return projection*position;}@vertex fn vertex(@location(0)position: vec4f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}";class Z{#r;Label;IndexFormat;VertexBuffers;IndexBuffer;constructor(t="Mesh",e){this.IndexFormat=e,this.Label=t}CreateVertexBuffer(t,e,r=this.Label){const i=t.CreateVertexBuffer(e,{label:`${r} Vertex Buffer`});this.VertexBuffers=t.SetVertexBuffers(i),t.WriteBuffer(i,e)}CreateIndexBuffer(t,e,r=this.Label){const i=t.CreateIndexBuffer(e,{label:`${r} Index Buffer`});this.IndexBuffer=t.SetIndexBuffer(i,this.IndexFormat),t.SetDrawParams(this.#r=e.length),t.WriteBuffer(i,e)}get Vertices(){return this.#r}Destroy(){this.IndexBuffer?.buffer.destroy(),this.VertexBuffers?.[0].buffer.destroy()}}class J extends Z{#r;#t;constructor(t="Cube"){super(t,"uint16")}GetPositionBufferLayout(t,e={name:"position",format:"float32x3"},r="vertex",i="vertex"){return t.CreateVertexBufferLayout(e,r,i)}CreateTextureCoordsBuffer(t,e,r="vertex",i="vertex"){!Array.isArray(e)&&e?.name,e??="textureCoords";const h=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]);return this.AddVertexBuffer(t,h,e,r,i)}AddVertexBuffer(t,e,r,i="vertex",h="vertex"){const{buffer:s,layout:c}=t.CreateVertexBuffer(r,this.Vertices,i,h);return this.VertexBuffers=t.AddVertexBuffers(s),t.WriteBuffer(s,e),{buffer:s,layout:c}}#s(t,e=this.Label){super.CreateVertexBuffer(t,this.#t??new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),e)}#o(t,e=this.Label){super.CreateIndexBuffer(t,this.#r??new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),e)}CreateBuffers(t,e=this.Label){this.#s(t,e),this.#o(t,e)}set VertexData(t){this.#t=t}set IndexData(t){this.#r=t}get Vertices(){return(this.#t&&this.#t.length/3)??this.#r?.length??super.Vertices??24}Destroy(){super.Destroy(),this.#r=void 0,this.#t=void 0}}class K extends D{#r=1;#t=1e3;#s=0;#o=innerWidth;#n=innerHeight;#e=0;#i=new Float32Array(24);constructor(t=1,e=1e3,r=0,i=innerWidth,h=innerHeight,s=0){if(super("OrthographicCamera"),this.#r=t,this.#t=e,this.#s=r,this.#e=s,typeof i!="number"){const[c,C]=i.CanvasSize;this.#o=c,this.#n=C}else this.#o=i,this.#n=h;this.UpdateProjectionMatrix()}UpdateFrustumPlanes(t=!1){const[e,r,i,h,s,c,C,P,y,B,S,v,u,n,d,p]=this.ProjectionMatrix;if(this.#i[0]=u+y,this.#i[1]=n+B,this.#i[2]=d+S,this.#i[3]=p+v,this.#i[4]=u-y,this.#i[5]=n-B,this.#i[6]=d-S,this.#i[7]=p-v,this.#i[8]=u-s,this.#i[9]=n-c,this.#i[10]=d-C,this.#i[11]=p-P,this.#i[12]=u-e,this.#i[13]=n-r,this.#i[14]=d-i,this.#i[15]=p-h,this.#i[16]=u+s,this.#i[17]=n+c,this.#i[18]=d+C,this.#i[19]=p+P,this.#i[20]=u+e,this.#i[21]=n+r,this.#i[22]=d+i,this.#i[23]=p+h,!t)return this.#i;for(let R=0;R<6;++R){const l=R*4,m=Math.hypot(this.#i[l+0],this.#i[l+1],this.#i[l+2])||1;this.#i[l+0]/=m,this.#i[l+1]/=m,this.#i[l+2]/=m,this.#i[l+3]/=m}return this.#i}UpdateProjectionMatrix(){return o.ortho(this.#e,this.#o,this.#n,this.#s,this.#r,this.#t,this.ProjectionMatrix)}set Near(t){this.#r=t,this.UpdateProjectionMatrix()}get Near(){return this.#r}set Far(t){this.#t=t,this.UpdateProjectionMatrix()}get Far(){return this.#t}set Top(t){this.#s=t,this.UpdateProjectionMatrix()}get Top(){return this.#s}set Right(t){this.#o=t,this.UpdateProjectionMatrix()}get Right(){return this.#o}set Bottom(t){this.#n=t,this.UpdateProjectionMatrix()}get Bottom(){return this.#n}set Left(t){this.#e=t,this.UpdateProjectionMatrix()}get Left(){return this.#e}}class Q extends D{#r=L.set(0,1,0);#t=60;#s=1;#o=1e3;#n=innerWidth/innerHeight;#e=new Float32Array(24);#i=o.identity();#a=o.identity();constructor(t=60,e=1,r=1e3,i=innerWidth/innerHeight){super("PerspectiveCamera"),this.#t=t,this.#s=e,this.#o=r,this.#n=typeof i!="number"?i.AspectRatio:i,this.UpdateProjectionMatrix()}UpdateFrustumPlanes(t=!1){const[e,r,i,h,s,c,C,P,y,B,S,v,u,n,d,p]=this.#a;if(this.#e[0]=u+y,this.#e[1]=n+B,this.#e[2]=d+S,this.#e[3]=p+v,this.#e[4]=u-y,this.#e[5]=n-B,this.#e[6]=d-S,this.#e[7]=p-v,this.#e[8]=u-s,this.#e[9]=n-c,this.#e[10]=d-C,this.#e[11]=p-P,this.#e[12]=u-e,this.#e[13]=n-r,this.#e[14]=d-i,this.#e[15]=p-h,this.#e[16]=u+s,this.#e[17]=n+c,this.#e[18]=d+C,this.#e[19]=p+P,this.#e[20]=u+e,this.#e[21]=n+r,this.#e[22]=d+i,this.#e[23]=p+h,!t)return this.#e;for(let R=0;R<6;++R){const l=R*4,m=Math.hypot(this.#e[l+0],this.#e[l+1],this.#e[l+2])||1;this.#e[l+0]/=m,this.#e[l+1]/=m,this.#e[l+2]/=m,this.#e[l+3]/=m}return this.#e}UpdateViewProjectionMatrix(t=!0){return t&&o.inverse(this.LocalMatrix,this.#i),o.multiply(this.ProjectionMatrix,this.#i,this.#a)}UpdateProjectionMatrix(){const t=a.DegreesToRadians(this.#t);return o.perspective(t,this.#n,this.#s,this.#o,this.ProjectionMatrix)}LookAt(t,e=this.#r){o.lookAt(this.Position,t,e,this.#i)}get ViewProjectionMatrix(){return this.#a}set FieldOfView(t){this.#t=t,this.UpdateProjectionMatrix()}get FieldOfView(){return this.#t}set Near(t){this.#s=t,this.UpdateProjectionMatrix()}get Near(){return this.#s}set Far(t){this.#o=t,this.UpdateProjectionMatrix()}get Far(){return this.#o}set AspectRatio(t){this.#n=typeof t!="number"?t.AspectRatio:t,this.UpdateProjectionMatrix()}get AspectRatio(){return this.#n}}const tt=""+new URL("dice-Vcs4qiRq.jpg",import.meta.url).href;var et="struct VertexOutput{@location(0)textureCoords: vec2f,@builtin(position)position: vec4f};@group(0)@binding(1)var Sampler: sampler;@group(0)@binding(2)var Texture: texture_2d<f32>;@vertex fn cubeVertex(@location(0)position: vec4f,@location(1)textureCoords: vec2f)->VertexOutput {return VertexOutput(textureCoords,GetVertexClipSpace(position));}@fragment fn fragment(@location(0)textureCoords: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoords);}";/**
 * @example Cube / Cameras
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This example is developed by using a version listed below.
 * Please note that this code may be simplified in future
 * thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */let A,M,F,O;async function st(j){try{M=new(await U.Renderer(j,"Cube / Cameras"))}catch(V){alert(V)}let t,e,r,i=1/0;const h=new J,s=new M.Pipeline,c=a.Vec3.create(),C=new z(h),P=new z(h),y=new Q,B=new K,S=a.Vec3.create(),v=a.Vec3.create(),u=a.Vec3.create(),n=a.Vec3.create(),d=a.Vec3.create(),p=s.CreateShaderModule([X,et]),{buffer:R,layout:l}=h.CreateTextureCoordsBuffer(s,void 0,void 0,"cubeVertex");await M.AddPipeline(s,{primitive:s.CreatePrimitiveState(),fragment:s.CreateFragmentState(p),multisample:s.CreateMultisampleState(),depthStencil:s.CreateDepthStencilState(),vertex:s.CreateVertexState(p,[h.GetPositionBufferLayout(s),l],void 0,"cubeVertex")}),P.SetRenderPipeline(s,!1),C.SetRenderPipeline(s,!1);const m=new(await U.Texture(M)),k=await m.CreateImageBitmap(tt);F=await m.CopyImageToTexture(k),s.SetBindGroupFromResources([C.ProjectionBuffer,m.CreateSampler({filter:E.LINEAR}),F.createView()]),s.AddBindGroupFromResources([P.ProjectionBuffer,m.CreateSampler({filter:E.LINEAR}),F.createView()]),M.CreatePassDescriptor(M.CreateColorAttachment(new H(1657907)),M.CreateDepthStencilAttachment()),s.AddVertexBuffers(R),s.AddVertexBuffers(R);function $(){i=1/0,clearTimeout(r),cancelAnimationFrame(A)}function G(){r=setTimeout(()=>{const V=-t||0,f=a.RandomInt(-2,2)||1/0,x=a.RandomInt(-2,2)||1/0,g=a.RandomInt(-2,2)||1/0;u[0]=Math.PI/f,u[1]=Math.PI/x,u[2]=Math.PI/g,n[0]=Math.PI/f+t,n[1]=!isFinite(f)&&t||Math.abs(f)<2&&V,n[2]=Math.abs(f)===2&&Math.sign(f)*V,n[1]&&=n[1]+Math.PI/x,n[2]&&=n[2]+Math.PI/g,i=Date.now()},1e3)}function W(V){A=requestAnimationFrame(W),V=(Date.now()-i)/1e3;const f=a.SmoothStep(V);let x=a.SmootherStep(V*2);.5<=f&&(x=(.5-(f-.5))*2,f===1&&(a.Vec3.copy(u,d),a.Vec3.copy(n,v),i=1/0,G()));{const[g,I,w]=d;c[0]=a.Lerp(g,u[0],f),c[1]=a.Lerp(I,u[1],f),c[2]=a.Lerp(w,u[2],f),C.Transform=[[0,a.Lerp(0,4,x),0],c],C.UpdateWorldMatrix(),C.UpdateProjectionMatrix(y.ViewProjectionMatrix),s.SetActiveBindGroups(0),M.Render(!1)}{const[g,I,w]=S,[b,T,_]=v;c[0]=a.Lerp(b,n[0],f),c[1]=a.Lerp(T,n[1],f),c[2]=a.Lerp(_,n[2],f),P.Transform=[[g,a.Lerp(I,e,x),w],c],P.UpdateWorldMatrix(),P.UpdateProjectionMatrix(B.ProjectionMatrix),s.SetActiveBindGroups(1),M.Render()}}O=new ResizeObserver(V=>{for(const f of V){let{inlineSize:x,blockSize:g}=f.contentBoxSize[0];x=x<=960&&x||x-240,M.SetCanvasSize(x,g),M.MultisampleTexture=m.CreateMultisampleTexture(),y.AspectRatio=M.AspectRatio,y.Position=[x/360,2,8],y.UpdateViewProjectionMatrix(),B.Bottom=g,B.Right=x,B.Near=-100;const I=g-g/3.6,w=(x-360)/1320;t=w*.2+.1,e=I*.39;const b=w+1;C.Scaling=[b,b,b];const T=(1-(g-1e3)/-400)*36+72;P.Scaling=[T*b,T*b,T*b],a.Vec3.set(.2,t,0,v),a.Vec3.set(x-(w*250+100),I,0,S)}$(),G(),A=requestAnimationFrame(W)}),O.observe(document.body)}function ot(){U.OnLost=()=>{},cancelAnimationFrame(A),O.disconnect(),M.Destroy(),U.Destroy(void 0,F)}export{ot as destroy,st as run};
