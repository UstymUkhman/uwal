import{b as x,T as S,E as g}from"./index-ELOcnE7E.js";import{a as r,b as o,M as m}from"./Math-Cr7J2GA5.js";let y=class{#f=r.create();#c=r.create();#h=r.create();#n=r.create();#o;#i;#e;#t;#u;#a=!1;#s;#l;#p;#x=o.set(1,1);#r=o.set(0,0);#S=o.set(0,0);#B=o.set(0,0);#d=x({min:o.create(),max:o.create()});constructor(t,i,e="Shape"){this.#e=t,this.#l=i,this.#o=e,this.Scale=this.#x,this.Origin=this.#r,this.Position=this.#B,this.Rotation=this.#i??0}SetRenderPipeline(t,i){this.#t=t,this.#e.CreateBuffers(t),this.#l?.CreateColorBuffer(t),this.#g(i)}#g(t,i){const{projection:e,buffer:s}=this.#t.CreateUniformBuffer("projection",{label:`${this.#o} Projection Buffer`,...i});this.#s=r.identity(e),this.#u=s,this.#p=[t,s,this.#l?.ColorBuffer].filter(Boolean),this.#t.SetBindGroupFromResources(this.#p,0,0,`${this.#o} Bind Group`)}SetPipelineData(){!this.#t&&S(g.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Use `Shape.SetRenderPipeline` method before setting its data."),this.#t.SetBindGroupFromResources(this.#p);const{VertexBuffer:t,IndexBuffer:i,Vertices:e}=this.#e;this.#t.SetVertexBuffers(t),this.#t.SetIndexBuffer(...i),this.#t.SetDrawParams(e)}Update(){if(this.#a){r.multiply(this.#n,this.#h,this.#s),r.multiply(this.#s,this.#c,this.#s),r.multiply(this.#s,this.#f,this.#s),this.#t.WriteBuffer(this.#u,this.#s);const t=this.#S[0]=this.#s[8],i=this.#S[1]=this.#s[9],{Radius:e}=this.#e;this.#d.min[0]=t-e,this.#d.min[1]=i-e,this.#d.max[0]=t+e,this.#d.max[1]=i+e,this.#a=!1}}get ProjectionBuffer(){return this.#u}set Position(t){this.#B.set(t),r.translation(this.#B,this.#n),this.#a=!0}get Position(){return this.#B}set Rotation(t){this.#i=t,r.rotation(this.#i,this.#h),this.#a=!0}get Rotation(){return this.#i}set Scale(t){this.#x.set(t),r.scaling(this.#x,this.#c),this.#a=!0}get Scale(){return this.#x}set Origin(t){const{Radius:i}=this.#e;this.#r[0]=t[0],this.#r[1]=t[1],this.#r[0]*=-i,this.#r[1]*=-i,r.translation(this.#r,this.#f),this.#r[0]=t[0]||0,this.#r[1]=t[1]||0,this.#a=!0}get Origin(){return this.#r}get Center(){return this.Update(),this.#S}get ProjectionMatrix(){return this.Update(),this.#s}get BoundingBox(){return this.Update(),this.#d}get Geometry(){return this.#e}get Material(){return this.#l}Destroy(){this.#e.Destroy(),this.#l?.Destroy(),this.#t=void 0,this.#u?.destroy(),this.#u=void 0,this.#p?.splice(0)}};var D="@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>projection: mat3x3f;fn GetVertexClipSpace(position: vec2f)->vec4f{let coords=projection*vec3f(position,1);return vec4f(GetClipSpace(coords.xy),0,1);}@vertex fn vertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}";const C=x({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});class O{#f;#c;#h;#n;#o;#i;#e;#t;constructor(t={segments:"SQUARE",radius:0}){const i=t.segments,e=typeof i=="number"&&i;this.#f=t.radius??0,this.#h=e||C[i||"SQUARE"],this.#n={label:"Shape",...t}}GetPositionBufferLayout(t,i="position",e="vertex",s="vertex"){return t.CreateVertexBufferLayout(i,e,s)}#u(t,i=this.#n.label){let e=this.#t;if(!e){e=new Float32Array((this.#h+1)*2*3);const{endAngle:s=m.TAU,startAngle:n=0,innerRadius:a=0}=this.#n,h=s-n;for(let f=0,u=0,c=this.#h;u<=c;++u){const l=n+u*h/c,d=Math.cos(l),p=Math.sin(l);e[f++]=d*this.#f,e[f++]=p*this.#f,e[f++]=d*a,e[f++]=p*a}}this.#i=t.CreateVertexBuffer(e,{label:`${i} Vertex Buffer`}),t.WriteBuffer(this.#i,e),t.SetVertexBuffers(this.#i)}#a(t,i=this.#n.label){let e=this.#e;if(!e){e=new Uint16Array(this.#h*6);for(let s=0,n=0,a=this.#h;n<a;++n){const h=n*2;e[s++]=h+1,e[s++]=h+3,e[s++]=h+2,e[s++]=h+2,e[s++]=h+0,e[s++]=h+1}}this.#o=t.CreateIndexBuffer(e,{label:`${i} Index Buffer`}),t.SetDrawParams(this.#c=e.length),t.WriteBuffer(this.#o,e),t.SetIndexBuffer(...this.IndexBuffer)}CreateBuffers(t,i=this.#n.label){this.#u(t,i),this.#a(t,i)}set VertexData(t){this.#t=t}get VertexBuffer(){return this.#i}set IndexData(t){this.#e=t}get IndexBuffer(){return[this.#o,"uint16"]}get Vertices(){return this.#c}get Radius(){return this.#f}Destroy(){this.#e=void 0,this.#o?.destroy(),this.#t=void 0,this.#i?.destroy()}}export{D as S,O as a,y as b};
