var Se=Object.defineProperty;var ce=u=>{throw TypeError(u)};var fe=(u,t,e)=>t in u?Se(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var b=(u,t,e)=>fe(u,typeof t!="symbol"?t+"":t,e),ne=(u,t,e)=>t.has(u)||ce("Cannot "+e);var i=(u,t,e)=>(ne(u,t,"read from private field"),e?e.call(u):t.get(u)),o=(u,t,e)=>t.has(u)?ce("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(u):t.set(u,e),n=(u,t,e,r)=>(ne(u,t,"write to private field"),r?r.call(u,e):t.set(u,e),e),E=(u,t,e)=>(ne(u,t,"access private method"),e);const be=_({RAD:Math.PI/180,DEG:180/Math.PI,HPI:Math.PI/2,TAU:Math.PI*2});function _(u){for(let t in u)u[t]={value:u[t]};return Object.freeze(Object.create(null,u))}const ve={CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND",VERTEX_STATE_NOT_FOUND:"VERTEX_STATE_NOT_FOUND",PIPELINE_NOT_FOUND:"PIPELINE_NOT_FOUND"},Ue={CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder.",VERTEX_STATE_NOT_FOUND:"Failed to get a GPUVertexState.",PIPELINE_NOT_FOUND:"Failed to get a GPU"},ge={CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7,VERTEX_STATE_NOT_FOUND:8,PIPELINE_NOT_FOUND:9},ye={RENDER_PIPELNE_NOT_FOUND:"RENDER_PIPELNE_NOT_FOUND",TEXTURE_SIZE_NOT_FOUND:"TEXTURE_SIZE_NOT_FOUND",TEXTURE_NOT_FOUND:"TEXTURE_NOT_FOUND"},Ge={RENDER_PIPELNE_NOT_FOUND:'"UWAL.RenderPipeline" is required in `Texture` when generating mipmaps.\n        Use `Texture.SetRenderer` method before creating a texture with mipmaps.',TEXTURE_SIZE_NOT_FOUND:"`size` array or a `width` value is required in `options` parameter of ",TEXTURE_NOT_FOUND:"CopyImageToTexture `options` is required to have a `texture` value or a `create` entry."},Fe={REQUIRED_SEGMENTS:"REQUIRED_SEGMENTS"},xe={REQUIRED_SEGMENTS:"Shape `segments` is required to be an integer value."};_({DEVICE_LOST:"Device::Lost"});const l=_({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",...ve,...ye,...Fe}),le=_({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost. ",...Ue,...Ge,...xe}),Le=_({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,...ge});function Be(u,t){console.warn(le[u]+(t??""))}function T(u,t){throw new Error(le[u]+(t??""),{cause:Le[u]})}var $,B,f,v,k,Y,I,ae,Te;class de{constructor(t,e,r){o(this,ae);o(this,$);o(this,B);o(this,f);b(this,"Device");b(this,"BindGroups",[]);o(this,v);b(this,"Pipeline");b(this,"Descriptor");o(this,k);o(this,Y);o(this,I,[]);!t&&T(l.DEVICE_NOT_REQUESTED),n(this,$,r),this.Device=t,n(this,B,e),n(this,f,this.CreatePipelineLabel("Command Encoder"))}CreatePipelineLabel(t){return i(this,B)&&t&&`${i(this,B)} ${t}`||""}CreatePipelineLayout(t,e){e??(e=this.CreatePipelineLabel(`${i(this,$)} Pipeline Layout`));const r=Array.isArray(t)&&t||[t];return this.Device.createPipelineLayout({label:e,bindGroupLayouts:r})}CreateShaderModule(t,e,r,s){e??(e=this.CreatePipelineLabel("Shader Module"));const a=Array.isArray(t)&&t.join(`

`)||t;return this.Device.createShaderModule({label:e,code:a,sourceMap:r,compilationHints:s})}CreateBuffer(t){const e=t.label??this.CreatePipelineLabel("Buffer");return this.Device.createBuffer({...t,label:e})}WriteBuffer(t,e,r=0,s,a){this.Device.queue.writeBuffer(t,r,e,s,a)}CopyBufferToBuffer(t,e,r,s=0,a=0){this.GetCommandEncoder(!0).copyBufferToBuffer(t,s,e,a,r)}CreateBindGroupLayout(t,e){e??(e=this.CreatePipelineLabel("Bind Group Layout")),t=Array.isArray(t)&&t.map((s,a)=>({...s,binding:s.binding??a}))||[{...t,binding:t.binding??0}];const r=t;return this.Device.createBindGroupLayout({entries:r,label:e})}CreateBindGroupEntries(t,e=0){return Array.isArray(t)&&t.map((r,s)=>({binding:(e==null?void 0:e[s])??s,resource:r}))||[{binding:e,resource:t}]}CreateBindGroup(t,e=0,r){return r??(r=this.CreatePipelineLabel("Bind Group")),typeof e=="number"&&(e=this.Pipeline?this.Pipeline.getBindGroupLayout(e):T(l.PIPELINE_NOT_FOUND,`${i(this,$)}Pipeline.`)),this.Device.createBindGroup({entries:t,label:r,layout:e})}SetBindGroups(t,e){Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups=Array.isArray(t)&&t.map((r,s)=>({bindGroup:r,dynamicOffsets:e[s],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}]}AddBindGroups(t,e){return Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups.push(...Array.isArray(t)&&t.map((r,s)=>({bindGroup:r,dynamicOffsets:e[s],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}])}SetActiveBindGroups(t){t=Array.isArray(t)&&t||[t];for(let e=this.BindGroups.length;e--;)this.BindGroups[e].active=t.includes(e)}ClearBindGroups(){this.BindGroups.splice(0)}CreateCommandEncoder(){return n(this,v,this.Device.createCommandEncoder({label:i(this,f)}))}SetCommandEncoder(t){n(this,v,t)}GetCommandEncoder(t=!1){if(!i(this,v)){if(t){const e=`${i(this,f)&&`Label: "${i(this,f)}".`}`;Be(l.COMMAND_ENCODER_NOT_FOUND,` ${e} Creating a new one.`)}return this.CreateCommandEncoder()}return i(this,v)}SubmitCommandBuffer(){this.Device.queue.submit([i(this,v).finish()])}SavePipelineState(){n(this,Y,this.Pipeline),n(this,k,this.Descriptor),n(this,I,[...this.BindGroups])}ResetPipelineState(){this.ClearBindGroups()}RestorePipelineState(){this.Descriptor=i(this,k),this.Pipeline=i(this,Y),E(this,ae,Te).call(this)}set CommandEncoderLabel(t){n(this,f,t)}get ProgramName(){return i(this,B)}}$=new WeakMap,B=new WeakMap,f=new WeakMap,v=new WeakMap,k=new WeakMap,Y=new WeakMap,I=new WeakMap,ae=new WeakSet,Te=function(){const t=i(this,I).map(({bindGroup:a})=>a),e=i(this,I).map(({dynamicOffsets:a})=>a),r=e.some(a=>typeof a=="number")&&e||void 0,s=i(this,I).map(({active:a},h)=>a&&h).filter(a=>typeof a=="number");this.SetBindGroups(t,r),this.SetActiveBindGroups(s)};_({ALL:"all",STENCIL:"stencil-only",DEPTH:"depth-only"});_({CLAMP:"clamp-to-edge",REPEAT:"repeat",MIRROR:"mirror-repeat"});const pe=_({NEAREST:"nearest",LINEAR:"linear"});_({NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"});var Ie="const QUAD=array(vec2f(-1.0,-1.0),vec2f(1.0,-1.0),vec2f(1.0,1.0),vec2f(1.0,1.0),vec2f(-1.0,1.0),vec2f(-1.0,-1.0));fn GetQuadCoord(index: u32)->vec2f{return QUAD[index];}struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=GetQuadCoord(index);let coord=(position+1)*0.5;var output: VertexOutput;output.position=vec4f(position,0.0,1.0);output.textureCoord=vec2f(coord.x,1-coord.y);return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}",A,Q,U,g,p,m,De,ie,oe,he;class Ce{constructor(t,e){o(this,m);o(this,A);o(this,Q);o(this,U);o(this,g);o(this,p);!t&&T(l.DEVICE_NOT_REQUESTED),n(this,Q,e),n(this,A,t)}CreateTexture(t){const e=t.label??E(this,m,De).call(this,"Texture");return i(this,A).createTexture({...t,label:e})}WriteTexture(t,e){const{texture:r,mipLevel:s,origin:a,aspect:h,offset:C,bytesPerRow:O,rowsPerImage:L}=e;i(this,A).queue.writeTexture({texture:r,mipLevel:s,origin:a,aspect:h},t,{offset:C,bytesPerRow:O,rowsPerImage:L},E(this,m,oe).call(this,e,"WriteTexture"))}CreateBitmapImage(t,e){return createImageBitmap(t,e)}CreateTextureFromSource(t,e){const r=e.mipLevelCount??(e.mipmaps&&this.GetMipmapLevels(t)||void 0),s=e.size,a=e.size,h=Array.isArray(e.size)||!e.size?s??E(this,m,ie).call(this,t):[a.width,a.height];return this.CreateTexture({mipLevelCount:r,size:h,...e})}ImportExternalTexture(t,e,r){return i(this,A).importExternalTexture({source:t,label:e,colorSpace:r})}CopyImageToTexture(t,e){let{texture:r}=e;const[s,a]=E(this,m,ie).call(this,t),{create:h,flipY:C,mipLevel:O,aspect:L,colorSpace:Ae,premultipliedAlpha:Re,generateMipmaps:_e=!0}=e;return!r&&!h&&T(l.TEXTURE_NOT_FOUND),r??(r=this.CreateTextureFromSource(t,h)),i(this,A).queue.copyExternalImageToTexture({source:t,origin:e.sourceOrigin,flipY:C},{texture:r,mipLevel:O,origin:e.destinationOrigin,aspect:L,colorSpace:Ae,premultipliedAlpha:Re},E(this,m,oe).call(this,{width:s,height:a,...e},"CopyImageToTexture")),_e&&1<r.mipLevelCount&&(r.depthOrArrayLayers===1?this.GenerateMipmaps(r):this.GenerateCubeMipmaps(r)),r}GenerateCubeMipmaps(t){E(this,m,he).call(this,t,{minMagFilter:pe.LINEAR},e=>{for(let r=0;r<t.depthOrArrayLayers;++r)i(this,p).SetBindGroups(i(this,p).CreateBindGroup(i(this,p).CreateBindGroupEntries([i(this,U),t.createView({arrayLayerCount:1,baseArrayLayer:r,mipLevelCount:1,dimension:"2d",baseMipLevel:e})]))),i(this,p).CreatePassDescriptor(i(this,p).CreateColorAttachment(t.createView({baseMipLevel:e+1,arrayLayerCount:1,baseArrayLayer:r,mipLevelCount:1,dimension:"2d"}))),i(this,p).Render(6,!1),i(this,p).DestroyCurrentPass()})}GenerateMipmaps(t){E(this,m,he).call(this,t,{minFilter:pe.LINEAR},e=>{i(this,p).SetBindGroups(i(this,p).CreateBindGroup(i(this,p).CreateBindGroupEntries([i(this,U),t.createView({baseMipLevel:e++,mipLevelCount:1})]))),i(this,p).CreatePassDescriptor(i(this,p).CreateColorAttachment(t.createView({baseMipLevel:e,mipLevelCount:1}))),i(this,p).Render(6,!1),i(this,p).DestroyCurrentPass()})}CreateSampler(t){if(!t)return i(this,A).createSampler();const{addressModeUV:e,addressMode:r,minMagFilter:s,filter:a}=t;return e&&(t.addressModeU=t.addressModeV=e),r&&(t.addressModeU=t.addressModeV=t.addressModeW=r),s&&(t.minFilter=t.magFilter=s),a&&(t.minFilter=t.magFilter=t.mipmapFilter=a),i(this,A).createSampler(t)}GetMipmapLevels(t){const[e,r]=E(this,m,ie).call(this,t);return(Math.log2(Math.max(e,r))|0)+1}SetRenderer(t){n(this,p,t)}}A=new WeakMap,Q=new WeakMap,U=new WeakMap,g=new WeakMap,p=new WeakMap,m=new WeakSet,De=function(t){return i(this,Q)&&t&&`${i(this,Q)} ${t}`||""},ie=function(t){return t instanceof HTMLVideoElement?[t.videoWidth,t.videoHeight]:t instanceof VideoFrame?[t.codedWidth,t.codedHeight]:[t.width,t.height]},oe=function(t,e){const{size:r,width:s,height:a,depthOrArrayLayers:h}=t;return!r&&!s&&T(l.TEXTURE_SIZE_NOT_FOUND,`\`${e}\` method.`),r??{width:s,height:a,depthOrArrayLayers:h}},he=function(t,e,r){!i(this,p)&&T(l.RENDER_PIPELNE_NOT_FOUND),(!i(this,g)||!i(this,U))&&(n(this,g,i(this,p).CreateShaderModule(Ie)),n(this,U,this.CreateSampler(e)));let s=0,a=t.width,h=t.height;for(i(this,p).SavePipelineState(),i(this,p).ResetPipelineState(),i(this,p).CreatePipeline({vertex:i(this,p).CreateVertexState(i(this,g)),fragment:i(this,p).CreateFragmentState(i(this,g),void 0,{format:t.format})});1<a||1<h;)a=Math.max(a*.5|0,1),h=Math.max(h*.5|0,1),r(s++);i(this,p).SubmitCommandBuffer(),i(this,p).SetCommandEncoder(void 0),i(this,p).RestorePipelineState(),n(this,g,n(this,U,void 0))};var Z,y,X,G,D,M,W,J,R,d,P,q,S,K,ee,te,F,V,ue,me;class Me extends de{constructor(e,r,s,a){super(e,r,"Render");o(this,V);o(this,Z);o(this,y,!1);o(this,X,new Float32Array(2));o(this,G,!1);o(this,D);o(this,M);o(this,W);o(this,J);o(this,R);o(this,d);o(this,P);o(this,q);o(this,S,[]);o(this,K);o(this,ee);o(this,te);o(this,F);!s&&T(l.CANVAS_NOT_FOUND);const h=s.getContext("webgpu");!h&&T(l.CONTEXT_NOT_FOUND),n(this,q,a.format??navigator.gpu.getPreferredCanvasFormat()),h.configure({device:e,...a,format:i(this,q)}),n(this,W,this.CreateBuffer({size:i(this,X).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Render Pipeline Resolution Buffer"})),n(this,D,s),n(this,M,h),E(this,V,ue).call(this)}SetCanvasSize(e,r){!this.Device&&T(l.DEVICE_NOT_FOUND),!i(this,D)&&T(l.CANVAS_NOT_FOUND);const{maxTextureDimension2D:s}=this.Device.limits;e=Math.max(1,Math.min(e,s)),r=Math.max(1,Math.min(r,s)),(i(this,D).width!==e||i(this,D).height!==r)&&(i(this,D).width=e,i(this,D).height=r,E(this,V,ue).call(this))}CreateColorAttachment(e,r="clear",s="store",a,h,C){return{view:e,loadOp:r,storeOp:s,clearValue:a,resolveTarget:h,depthSlice:C}}CreateDepthAttachment(e,r=1,s="clear",a="store",h){return n(this,G,!0),n(this,J,new Ce(this.Device,"Depth Texture")),{view:e,depthClearValue:r,depthLoadOp:s,depthStoreOp:a,depthReadOnly:h}}CreateStencilAttachment(e,r="clear",s="store",a){return{stencilClearValue:e,stencilLoadOp:r,stencilStoreOp:s,stencilReadOnly:a}}CreatePassDescriptor(e,r,s,a,h,C){const O=Array.isArray(e)&&e||[e];return n(this,y,!O.some(({view:L})=>!!L)),r??(r=this.CreatePipelineLabel("Render Pass")),this.Descriptor={colorAttachments:O,depthStencilAttachment:s,occlusionQuerySet:a,timestampWrites:h,maxDrawCount:C,label:r}}CreateVertexBufferAttribute(e,r=0,s=0){return{format:e,shaderLocation:r,offset:s}}CreateVertexState(e,r="vertex",s,a){return s=Array.isArray(s)&&s||[s],{module:e,entryPoint:r,buffers:s,constants:a}}CreateFragmentColorTarget(e=i(this,q),r,s){return{format:e,blend:r,writeMask:s}}CreateFragmentState(e,r="fragment",s,a){return s??(s=[this.CreateFragmentColorTarget()]),s=Array.isArray(s)&&s||[s],{module:e,entryPoint:r,targets:s,constants:a}}CreatePipeline(e){const r=e.layout??"auto";let{module:s,vertex:a,fragment:h}=e;s&&(a??(a=this.CreateVertexState(s)),h??(h=this.CreateFragmentState(s))),!s&&!a&&T(l.VERTEX_STATE_NOT_FOUND);const C=e.label??this.CreatePipelineLabel("Render Pipeline");return this.Pipeline=this.Device.createRenderPipeline({...e,vertex:a,fragment:h,label:C,layout:r})}SavePipelineState(){super.SavePipelineState(),n(this,F,i(this,P)),n(this,K,i(this,S)),n(this,ee,i(this,y)),n(this,te,i(this,G)),i(this,F)&&n(this,F,Object.values(i(this,F)))}ResetPipelineState(){super.ResetPipelineState(),this.SetIndexBuffer(void 0),n(this,y,!1),n(this,G,!1)}RestorePipelineState(){super.RestorePipelineState(),n(this,S,i(this,K)),n(this,y,i(this,ee)),n(this,G,i(this,te)),this.SetIndexBuffer(...Array.isArray(i(this,F))&&i(this,F)||[void 0])}SetVertexBuffers(e,r,s){r=Array.isArray(r)&&r||[r],s=Array.isArray(s)&&s||[s],n(this,S,Array.isArray(e)&&e.map((a,h)=>({buffer:a,offset:r[h],size:s[h]}))||[{buffer:e,offset:r[0],size:s[0]}])}AddVertexBuffers(e,r,s){r=Array.isArray(r)&&r||[r],s=Array.isArray(s)&&s||[s],i(this,S).push(...Array.isArray(e)&&e.map((a,h)=>({buffer:a,offset:r[h],size:s[h]}))||[{buffer:e,offset:r[0],size:s[0]}])}SetIndexBuffer(e,r="uint32",s,a){n(this,P,e&&{buffer:e,format:r,offset:s,size:a})}Render(e,r=!0){i(this,G)&&E(this,V,me).call(this),i(this,d)||(i(this,y)&&(this.Descriptor.colorAttachments[0].view=this.CurrentTextureView),n(this,d,this.GetCommandEncoder().beginRenderPass(this.Descriptor)),i(this,d).setPipeline(this.Pipeline),n(this,Z,i(this,P)?i(this,d).drawIndexed.bind(i(this,d)):i(this,d).draw.bind(i(this,d))));for(let s=0,a=i(this,S).length;s<a;++s){const{buffer:h,offset:C,size:O}=i(this,S)[s];i(this,d).setVertexBuffer(s,h,C,O)}i(this,P)&&i(this,d).setIndexBuffer(i(this,P).buffer,i(this,P).format,i(this,P).offset,i(this,P).size);for(let s=0,a=0,h=this.BindGroups.length;s<h;++s){const{bindGroup:C,dynamicOffsets:O,active:L}=this.BindGroups[s];L&&i(this,d).setBindGroup(a++,C,O)}i(this,Z).call(this,...Array.isArray(e)&&e||[e]),r&&this.Submit()}DestroyCurrentPass(){var e;(e=i(this,d))==null||e.end(),n(this,d,void 0)}Submit(){this.DestroyCurrentPass(),this.SubmitCommandBuffer(),this.SetCommandEncoder(void 0)}Destroy(){var e;this.DestroyCurrentPass(),(e=i(this,M))==null||e.unconfigure()}get Canvas(){return i(this,D)}get Context(){return i(this,M)}get AspectRatio(){return!i(this,D)&&T(l.CANVAS_NOT_FOUND),i(this,D).width/i(this,D).height}get DepthTexture(){return i(this,R)}get CurrentTexture(){return i(this,M).getCurrentTexture()}get CurrentTextureView(){return this.CurrentTexture.createView()}get ResolutionBuffer(){return i(this,W)}get CurrentPass(){return i(this,d)}}Z=new WeakMap,y=new WeakMap,X=new WeakMap,G=new WeakMap,D=new WeakMap,M=new WeakMap,W=new WeakMap,J=new WeakMap,R=new WeakMap,d=new WeakMap,P=new WeakMap,q=new WeakMap,S=new WeakMap,K=new WeakMap,ee=new WeakMap,te=new WeakMap,F=new WeakMap,V=new WeakSet,ue=function(){i(this,X).set([i(this,D).width,i(this,D).height]),this.WriteBuffer(i(this,W),i(this,X))},me=function(){var a;const e=this.CurrentTexture,{width:r,height:s}=e;(!i(this,R)||i(this,R).width!==r||i(this,R).height!==s)&&((a=i(this,R))==null||a.destroy(),n(this,R,i(this,J).CreateTextureFromSource(e,{usage:GPUTextureUsage.RENDER_ATTACHMENT,format:"depth24plus"}))),this.Descriptor.depthStencilAttachment.view=i(this,R).createView()};var re;class we extends de{constructor(e,r){super(e,r,"Compute");o(this,re,[1])}CreatePassDescriptor(e,r,s,a){return e??(e=this.CreatePipelineLabel("Compute Pass")),this.Descriptor={label:e,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:s,endOfPassWriteIndex:a}:void 0}}SetPassDescriptor(e){this.Descriptor=e}CreatePipeline(e){const r=e.layout??"auto",s=e.label??this.CreatePipelineLabel("Compute Pipeline");return this.Pipeline=this.Device.createComputePipeline({label:s,layout:r,compute:e})}Compute(){const e=this.GetCommandEncoder().beginComputePass(this.Descriptor);e.setPipeline(this.Pipeline);for(let r=0,s=0,a=this.BindGroups.length;r<a;++r){const{bindGroup:h,dynamicOffsets:C,active:O}=this.BindGroups[r];O&&e.setBindGroup(s++,h,C)}e.dispatchWorkgroups(...i(this,re)),e.end()}set Workgroups(e){n(this,re,Array.isArray(e)&&e||[e])}}re=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.5
 * @license MIT
 */var z,H,w,x,j,N,se,Oe,Ne,Pe;const c=class c{static SetAdapterOptions(t,e=!1){i(c,H).powerPreference=t,i(c,H).forceFallbackAdapter=e}static SetDeviceDescriptor(t,e=[],r={}){i(c,x).label=t,i(c,x).requiredFeatures=e,i(c,x).requiredLimits=r}static RenderPipeline(t,e="",r={}){return E(this,N,se).call(this,e),(async()=>{const s=await c.Device;return new Proxy(Me,{construct(a){return new a(s,e,t,r)}})})()}static ComputePipeline(t=""){return E(this,N,se).call(this,t),(async()=>{const e=await c.Device;return new Proxy(we,{construct(r){return new r(e,t)}})})()}static Texture(t=""){return E(this,N,se).call(this,t),(async()=>{const e=await c.Device;return new Proxy(Ce,{construct(r){return new r(e,t)}})})()}static Destroy(t,e,r){var s;t=Array.isArray(t)&&t||[t],t.forEach(a=>a==null?void 0:a.destroy()),e=Array.isArray(e)&&e||[e],e.forEach(a=>a==null?void 0:a.destroy()),r=Array.isArray(r)&&r||[r],r.forEach(a=>a==null?void 0:a.destroy()),(s=i(c,w))==null||s.destroy(),c.SetAdapterOptions(),c.SetDeviceDescriptor(),n(c,j,void 0),n(c,z,n(c,w,null))}static get AdapterLimits(){return i(this,j)}static get Adapter(){return(async()=>{var t;return i(c,z)??await E(t=c,N,Ne).call(t)()})()}static get Device(){return(async()=>{var t;return i(c,w)??await E(t=c,N,Pe).call(t)()})()}static get VERSION(){return"0.0.5"}};z=new WeakMap,H=new WeakMap,w=new WeakMap,x=new WeakMap,j=new WeakMap,N=new WeakSet,se=function(t){var e;(e=i(c,x)).label??(e.label=t&&`${t} Device`||"")},Oe=function(t){if(c.OnDeviceLost)return c.OnDeviceLost(t);const e=(t.message&&` | Message: ${t.message}`)??".";T(l.DEVICE_LOST,`Reason: ${t.reason}`+e)},Ne=function(){return!navigator.gpu&&T(l.WEBGPU_NOT_SUPPORTED),async()=>{const t=await navigator.gpu.requestAdapter(i(c,H));return!t&&T(l.ADAPTER_NOT_FOUND),n(this,j,t.limits),n(c,z,t)}},Pe=function(){return async()=>{const{requiredFeatures:t,requiredLimits:e,label:r}=i(c,x),s=await(await c.Adapter).requestDevice({requiredFeatures:t,requiredLimits:e,defaultQueue:{label:r}});return!s&&T(l.DEVICE_NOT_FOUND),s.lost.then(E(c,N,Oe)),n(c,w,s)}},o(c,N),o(c,z,null),o(c,H,{powerPreference:void 0,forceFallbackAdapter:!1}),o(c,w,null),o(c,x,{label:void 0,requiredFeatures:[],requiredLimits:{}}),o(c,j),b(c,"OnDeviceLost");let Ee=c;_({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});console.info("%cUWAL v0.0.5","background:#005a9c;padding:3px;color:#fff;");export{_ as C,l as E,pe as F,be as N,T,Ee as U};
