import{b as i,c,d as p,N as B,G as x}from"./index-DM-yqRiN.js";var S="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn shapeVertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}";class g{#i;#l=0;#r=!1;#g=i.create();#y=i.create();#v=i.create();#C=i.create();#n;#h;#d;#c;#e;#o;#a;#t;#f=[];#p=[void 0];#x=new Float32Array([1,1]);#s=new Float32Array([0,0]);#m=new Float32Array([0,0]);#B=new Float32Array([0,0]);#S;#u=c({min:p.create(),max:p.create()});constructor(t){this.#t=t.renderer,this.#h=t.segments,this.#i=t.radius??0,this.#n=t.label??"Shape";const{startAngle:e,endAngle:s,innerRadius:r}=t;this.#b(e,s,r),this.#E(),this.#R(),this.Scale=this.#x,this.Origin=this.#s,this.Rotation=this.#l,this.Position=this.#B}#b(t=0,e=B.TAU,s=0){const r=e-t,h=new Float32Array((this.#h+1)*2*3);for(let a=0,n=0;n<=this.#h;++n){const f=t+n*r/this.#h,u=Math.cos(f),l=Math.sin(f);h[a++]=u*this.#i,h[a++]=l*this.#i,h[a++]=u*s,h[a++]=l*s}const o=this.#t.CreateVertexBuffer(h,{label:`${this.#n} Vertex Buffer`});this.#t.WriteBuffer(o,h),this.#f.push(o)}#E(){const t=new Uint32Array(this.#d=this.#h*6);for(let e=0,s=0;s<this.#h;++s){const r=s*2;t[e++]=r+1,t[e++]=r+3,t[e++]=r+2,t[e++]=r+2,t[e++]=r+0,t[e++]=r+1}this.#o=this.#t.CreateIndexBuffer(t,{label:`${this.#n} Index Buffer`}),this.#t.WriteBuffer(this.#o,t)}#R(){const{buffer:t,shape:{color:e,matrix:s}}=this.#t.CreateUniformBuffer("shape",{label:`${this.#n} Uniform Buffer`});this.#a=t,this.#e=s,this.#c=e,this.#p[0]=this.#t.CreateBindGroup(this.#t.CreateBindGroupEntries([{buffer:this.#t.ResolutionBuffer},{buffer:this.#a}]),0,`${this.#n} Bind Group`),this.#S=c({matrix:e.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT})}#A(){if(this.#r){i.multiply(this.#C,this.#v,this.#e),i.multiply(this.#e,this.#y,this.#e),i.multiply(this.#e,this.#g,this.#e),this.#t.WriteBuffer(this.#a,this.#e,this.#S.matrix);const t=this.#m[0]=this.#e[8],e=this.#m[1]=this.#e[9];this.#u.min[0]=t-this.#i,this.#u.min[1]=e-this.#i,this.#u.max[0]=t+this.#i,this.#u.max[1]=e+this.#i,this.#r=!1}return this}Update(){return this.#t.SetVertexBuffers(this.#f),this.#t.SetIndexBuffer(this.#o),this.#t.SetBindGroups(this.#p),this.#A()}Render(t=!0){this.#t.SavePipelineState(),this.#t.Render(this.Update().#d,t),this.#t.RestorePipelineState()}AddBindGroups(t){this.#p.push(...x(t))}AddVertexBuffers(t){this.#f.push(...x(t))}set Color(t){this.#c.set(Array.isArray(t)||ArrayBuffer.isView(t)?t:t.rgba),this.#t.WriteBuffer(this.#a,this.#c,this.#S.color)}get Color(){return this.#c}set Position(t){this.#B.set(t),i.translation(this.#B,this.#C),this.#r=!0}get Position(){return this.#B}set Rotation(t){this.#l=t,i.rotation(this.#l,this.#v),this.#r=!0}get Rotation(){return this.#l}set Scale(t){this.#x.set(t),i.scaling(this.#x,this.#y),this.#r=!0}get Scale(){return this.#x}set Origin(t){this.#s[0]=t[0],this.#s[1]=t[1],this.#s[0]*=-this.#i,this.#s[1]*=-this.#i,i.translation(this.#s,this.#g),this.#s[0]=t[0]||0,this.#s[1]=t[1]||0,this.#r=!0}get Origin(){return this.#s}get Center(){return this.#A().#m}get Vertices(){return this.#d}get Transform(){return this.#e}get BoundingBox(){return this.#u}Destroy(){this.#f.forEach(t=>t.destroy()),this.#a=this.#a.destroy(),this.#o=this.#o.destroy(),this.#f.splice(0),this.#p.splice(0)}}export{g as L,S};
