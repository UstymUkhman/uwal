{"version":3,"file":"index-XE6pvuvY.js","sources":["../../lib/Constants.js","../../lib/Errors.js","../../lib/pipeline/BasePipeline.js","../../lib/pipeline/RenderPipeline.js","../../lib/pipeline/ComputePipeline.js","../../lib/UWAL.js","../../src/examples/screen-shader/ScreenShader.wgsl","../../src/examples/screen-shader/index.js"],"sourcesContent":["/** @param {Record<string, unknown>} values */\nfunction CreateConstantObject(values)\n{\n    /** @type {object} */ const constants = {};\n\n    for (let value in values)\n        constants[value] = { value: values[value] };\n\n    return Object.freeze(Object.create(null, constants));\n}\n\n/**\n * @typedef {\"DEVICE_LOST\"} EventType\n * @type {Readonly<Record<EventType, string>>}\n */\nexport const EVENT = CreateConstantObject(\n{\n    DEVICE_LOST: \"Device::Lost\"\n});\n\n/**\n * @typedef {\"WEBGPU_NOT_SUPPORTED\"      |\n *           \"ADAPTER_NOT_FOUND\"         |\n *           \"DEVICE_NOT_FOUND\"          |\n *           \"DEVICE_NOT_REQUESTED\"      |\n *           \"DEVICE_LOST\"               |\n *           \"CANVAS_NOT_FOUND\"          |\n *           \"CONTEXT_NOT_FOUND\"         |\n *           \"COMMAND_ENCODER_NOT_FOUND\"\n * } ErrorCause\n *\n * @type {Readonly<Record<ErrorCause, ErrorCause>>}\n */\nexport const ERROR = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: \"WEBGPU_NOT_SUPPORTED\",\n    ADAPTER_NOT_FOUND: \"ADAPTER_NOT_FOUND\",\n    DEVICE_NOT_FOUND: \"DEVICE_NOT_FOUND\",\n    DEVICE_NOT_REQUESTED: \"DEVICE_NOT_REQUESTED\",\n    DEVICE_LOST: \"DEVICE_LOST\",\n    CANVAS_NOT_FOUND: \"CANVAS_NOT_FOUND\",\n    CONTEXT_NOT_FOUND: \"CONTEXT_NOT_FOUND\",\n    COMMAND_ENCODER_NOT_FOUND: \"COMMAND_ENCODER_NOT_FOUND\"\n});\n\n/** @type {Readonly<Record<ErrorCause, string>>} */\nexport const ERROR_MESSAGE = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: \"WebGPU is not supported in this browser.\",\n    ADAPTER_NOT_FOUND: \"Failed to get a GPUAdapter.\",\n    DEVICE_NOT_FOUND: \"Failed to get a GPUDevice.\",\n    DEVICE_NOT_REQUESTED: \"GPUDevice was not requested.\",\n    DEVICE_LOST: \"WebGPU device was lost.\",\n    CANVAS_NOT_FOUND: \"Failed to get a WebGPU canvas.\",\n    CONTEXT_NOT_FOUND: \"Failed to get a WebGPU context.\",\n    COMMAND_ENCODER_NOT_FOUND: \"Failed to get a GPUCommandEncoder.\"\n});\n\n/** @type {Readonly<Record<ErrorCause, number>>} */\nexport const ERROR_CAUSE = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: 0,\n    ADAPTER_NOT_FOUND: 1,\n    DEVICE_NOT_FOUND: 2,\n    DEVICE_NOT_REQUESTED: 3,\n    DEVICE_LOST: 4,\n    CANVAS_NOT_FOUND: 5,\n    CONTEXT_NOT_FOUND: 6,\n    COMMAND_ENCODER_NOT_FOUND: 7\n});\n","import { ERROR_MESSAGE, ERROR_CAUSE } from \"@/Constants\";\n\n/**\n * @param {import(\"@/Constants\").ErrorCause} warning\n * @param {string} [message = undefined]\n */\nexport function ThrowWarning(warning, message)\n{\n    console.warn(ERROR_MESSAGE[warning] + (message ?? \"\"));\n}\n\n/**\n * @param {import(\"@/Constants\").ErrorCause} error\n * @param {string} [message = undefined]\n */\nexport function ThrowError(error, message)\n{\n    throw new Error(ERROR_MESSAGE[error] + (message ?? \"\"), { cause: ERROR_CAUSE[error] });\n}\n","import { ThrowError, ThrowWarning } from \"@/Errors\";\nimport { ERROR } from \"@/Constants\";\n\n/** @abstract */\nexport default class BasePipeline\n{\n    /** @type {string} */ #CommandEncoderLabel;\n\n    /** @protected @type {GPUDevice} */ Device;\n    /** @protected @type {GPUBindGroup[]} */ BindGroups = [];\n    /** @type {GPUCommandEncoder | undefined} */ #CommandEncoder;\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     */\n    constructor(device, commandEncoderLabel)\n    {\n        !device && ThrowError(ERROR.DEVICE_NOT_REQUESTED);\n\n        this.Device = device;\n        this.#CommandEncoderLabel = commandEncoderLabel;\n    }\n\n    /**\n     * @typedef {Object} BufferDescriptor\n     * @property {GPUSize64} size\n     * @property {GPUBufferUsageFlags} usage\n     * @property {string} [label = undefined]\n     * @property {boolean} [mappedAtCreation = undefined]\n     * @param {BufferDescriptor} descriptor\n     */\n    CreateBuffer(descriptor)\n    {\n        return this.Device.createBuffer(descriptor);\n    }\n\n    /**\n     * @param {GPUBuffer} buffer\n     * @param {BufferSource | SharedArrayBuffer} data\n     * @param {GPUSize64} [bufferOffset = 0]\n     * @param {GPUSize64} [dataOffset = undefined]\n     * @param {GPUSize64} [size = undefined]\n     */\n    WriteBuffer(buffer, data, bufferOffset = 0, dataOffset, size)\n    {\n        this.Device.queue.writeBuffer(buffer, bufferOffset, data, dataOffset, size);\n    }\n\n    /**\n     * @param {GPUBuffer} source\n     * @param {GPUBuffer} destination\n     * @param {GPUSize64} size\n     * @param {GPUSize64} [sourceOffset = 0]\n     * @param {GPUSize64} [destinationOffset = 0]\n     */\n    CopyBufferToBuffer(source, destination, size, sourceOffset = 0, destinationOffset = 0)\n    {\n        this.CommandEncoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);\n    }\n\n    /**\n     * @param {string | string[]} shader\n     * @param {string} [label = \"\"]\n     * @param {any} [sourceMap = undefined]\n     * @param {GPUShaderModuleCompilationHint[]} [hints = undefined]\n     */\n    CreateShaderModule(shader, label = \"\", sourceMap, hints)\n    {\n        const code = Array.isArray(shader) ? shader.join(\"\\n\\n\") : shader;\n        return this.Device.createShaderModule({ label, code, sourceMap, compilationHints: hints });\n    }\n\n    /** @param {GPUBindingResource | GPUBindingResource[]} resources */\n    CreateBindGroupEntries(resources)\n    {\n        return Array.isArray(resources)\n            ? resources.map((resource, binding) => ({ binding, resource }))\n            : [{ binding: 0, resource: resources }];\n    }\n\n    /**\n     * @typedef {Object} BindGroupDescriptor\n     * @property {GPUBindGroupLayout} layout\n     * @property {Iterable<GPUBindGroupEntry>} entries\n     * @property {string} [label = undefined]\n     * @param {BindGroupDescriptor} descriptor\n     */\n    CreateBindGroup(descriptor)\n    {\n        return this.Device.createBindGroup(descriptor);\n    }\n\n    /** @param {GPUBindGroup | GPUBindGroup[]} bindGroups */\n    AddBindGroups(bindGroups)\n    {\n        this.BindGroups = Array.isArray(bindGroups) ? bindGroups : [bindGroups];\n    }\n\n    CreateCommandEncoder()\n    {\n        return this.#CommandEncoder = this.Device.createCommandEncoder({ label: this.#CommandEncoderLabel });\n    }\n\n    SubmitCommandBuffer()\n    {\n        this.Device.queue.submit([this.CommandEncoder.finish()]);\n    }\n\n    /** @protected */\n    get CommandEncoder()\n    {\n        if (!this.#CommandEncoder)\n        {\n            const message = ` ${this.#CommandEncoderLabel && `Label: \"${this.#CommandEncoderLabel}\". `}`;\n            ThrowWarning(ERROR.COMMAND_ENCODER_NOT_FOUND, message + \"Creating a new one.\");\n            return this.CreateCommandEncoder();\n        }\n\n        return this.#CommandEncoder;\n    }\n}\n","import { BasePipeline } from \"@/pipeline\";\n\nexport default class RenderPipeline extends BasePipeline\n{\n    /** @type {GPUTextureFormat} */ #PreferredCanvasFormat;\n    /** @type {GPURenderPassEncoder | undefined} */ #CurrentPass;\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     * @param {GPUTextureFormat} [preferredFormat = undefined]\n     */\n    constructor(device, commandEncoderLabel, preferredFormat)\n    {\n        super(device, commandEncoderLabel);\n        this.#PreferredCanvasFormat = preferredFormat;\n    }\n\n    /**\n     * @param {GPUTextureView} [view = undefined]\n     * @param {GPULoadOp} [loadOp = \"load\"]\n     * @param {GPUStoreOp} [storeOp = \"store\"]\n     * @param {GPUColor} [clearValue = undefined]\n     * @param {GPUTextureView} [resolveTarget = undefined]\n     * @param {GPUIntegerCoordinate} [depthSlice = undefined]\n     */\n    CreateColorAttachment(view, loadOp = \"load\", storeOp = \"store\", clearValue, resolveTarget, depthSlice)\n    {\n        return { view, loadOp, storeOp, clearValue, resolveTarget, depthSlice };\n    }\n\n    /**\n     * @param {GPURenderPassColorAttachment | GPURenderPassColorAttachment[]} colorAttachments\n     * @param {string} [label = \"\"]\n     * @param {GPURenderPassDepthStencilAttachment} [depthStencilAttachment = undefined]\n     * @param {GPUQuerySet} [occlusionQuerySet = undefined]\n     * @param {GPURenderPassTimestampWrites} [timestampWrites = undefined]\n     * @param {GPUSize64} [maxDrawCount = undefined]\n     */\n    CreateRenderPassDescriptor(\n        colorAttachments, label = \"\", depthStencilAttachment, occlusionQuerySet, timestampWrites, maxDrawCount\n    ) {\n        colorAttachments = Array.isArray(colorAttachments) ? colorAttachments : [colorAttachments];\n        return { colorAttachments, label, depthStencilAttachment, occlusionQuerySet, timestampWrites, maxDrawCount };\n    }\n\n    /**\n     * @param {GPUShaderModule} module\n     * @param {string} [entry = \"vertex\"]\n     * @param {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     * @param {Iterable<GPUVertexBufferLayout | null>} [buffers = undefined]\n     */\n    CreateVertexState(module, entry = \"vertex\", constants, buffers)\n    {\n        return { module, entryPoint: entry, constants, buffers };\n    }\n\n    /**\n     * @param {GPUShaderModule} module\n     * @param {string} [entry = \"fragment\"]\n     * @param {Iterable<GPUColorTargetState | null>} [targets = [undefined]]\n     * @param {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     */\n    CreateFragmentState(module, entry = \"fragment\", targets, constants)\n    {\n        targets ??= [{ format: this.#PreferredCanvasFormat }];\n        return { module, entryPoint: entry, targets, constants };\n    }\n\n    /**\n     * @typedef {Object} RenderPipelineDescriptor\n     * @property {GPUVertexState} vertex\n     * @property {string} [label = undefined]\n     * @property {GPUFragmentState} [fragment = undefined]\n     * @property {GPUPipelineLayout | GPUAutoLayoutMode} [layout = \"auto\"]\n     * @property {GPUPrimitiveState} [primitive = undefined]\n     * @property {GPUDepthStencilState} [depthStencil = undefined]\n     * @property {GPUMultisampleState} [multisample = undefined]\n     * @param {RenderPipelineDescriptor} descriptor\n     */\n    CreateRenderPipeline(descriptor)\n    {\n        const layout = descriptor.layout ?? \"auto\";\n        return this.Device.createRenderPipeline({ ...descriptor, layout });\n    }\n\n    /**\n     * @param {GPURenderPassDescriptor} descriptor\n     * @param {GPURenderPipeline} pipeline\n     * @typedef {Object} DrawParams\n     * @property {GPUSize32} vertexCount\n     * @property {GPUSize32} [instanceCount = undefined]\n     * @property {GPUSize32} [firstVertex = undefined]\n     * @property {GPUSize32} [firstInstance = undefined]\n     * @param {DrawParams | GPUSize32} drawParams\n     * @param {boolean} [submit = true]\n     */\n    Render(descriptor, pipeline, drawParams, submit = true)\n    {\n        if (!this.#CurrentPass)\n        {\n            const encoder = this.CreateCommandEncoder();\n            this.#CurrentPass = encoder.beginRenderPass(descriptor);\n            this.#CurrentPass.setPipeline(pipeline);\n        }\n\n        for (let g = 0, l = this.BindGroups.length; g < l; ++g)\n            this.#CurrentPass.setBindGroup(g, this.BindGroups[g]);\n\n        drawParams = typeof drawParams === \"number\"\n            ? { vertexCount: drawParams }\n            : drawParams;\n\n        this.#CurrentPass.draw(\n            drawParams.vertexCount,\n            drawParams.instanceCount,\n            drawParams.firstVertex,\n            drawParams.firstInstance\n        );\n\n        if (submit)\n        {\n            this.#CurrentPass.end();\n            this.#CurrentPass = undefined;\n            this.SubmitCommandBuffer();\n        }\n    }\n\n    get CurrentPass()\n    {\n        return this.#CurrentPass;\n    }\n}\n","import { BasePipeline } from \"@/pipeline\";\n\nexport default class ComputePipeline extends BasePipeline\n{\n    /** @type {number[]} */ #Workgroups = [1];\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     */\n    constructor(device, commandEncoderLabel)\n    {\n        super(device, commandEncoderLabel);\n    }\n\n    /**\n     * @param {string} [label = \"\"]\n     * @param {GPUQuerySet} [querySet = undefined]\n     * @param {GPUSize32} [beginningOfPassWriteIndex = undefined]\n     * @param {GPUSize32} [endOfPassWriteIndex = undefined]\n     */\n    CreateComputePassDescriptor(label = \"\", querySet, beginningOfPassWriteIndex, endOfPassWriteIndex)\n    {\n        return {\n            label,\n            timestampWrites: querySet\n                ? { querySet, beginningOfPassWriteIndex, endOfPassWriteIndex }\n                : undefined\n        };\n    }\n\n    /**\n     * @typedef {Object} ComputePipelineDescriptor\n     * @property {GPUShaderModule} module\n     * @property {string} [entry = \"compute\"]\n     * @property {string} [label = undefined]\n     * @property {GPUPipelineLayout | GPUAutoLayoutMode} [layout = \"auto\"]\n     * @property {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     * @param {ComputePipelineDescriptor} descriptor\n     */\n    CreateComputePipeline(descriptor)\n    {\n        const layout = descriptor.layout ?? \"auto\";\n        return this.Device.createComputePipeline({ label: descriptor.label, layout, compute: descriptor });\n    }\n\n    /**\n     * @param {GPUComputePipeline} pipeline\n     * @param {GPUComputePassDescriptor} [descriptor = undefined]\n     */\n    Compute(pipeline, descriptor)\n    {\n        const pass = this.CommandEncoder.beginComputePass(descriptor);\n\n        pass.setPipeline(pipeline);\n\n        for (let g = 0, l = this.BindGroups.length; g < l; ++g)\n            pass.setBindGroup(g, this.BindGroups[g]);\n\n        // @ts-ignore\n        pass.dispatchWorkgroups(...this.#Workgroups);\n        pass.end();\n    }\n\n    /** @param {number | number[]} workgroups */\n    set Workgroups(workgroups)\n    {\n        this.#Workgroups = Array.isArray(workgroups) ? workgroups : [workgroups];\n    }\n}\n","/**\n * @module UWAL\n * @author Ustym Ukhman <ustym.ukhman@gmail.com>\n * @description Unopinionated WebGPU Abstraction Library\n * @version 0.0.1\n * @license MIT\n */\n\nimport { RenderPipeline, ComputePipeline } from \"@/pipeline\";\nimport { ERROR, EVENT } from \"@/Constants\";\nimport { ThrowError } from \"@/Errors\";\n\nexport default class UWAL\n{\n    /** @type {GPUAdapter | null} */ static #Adapter = null;\n    /** @type {GPUDevice | null} */ static #Device = null;\n\n    /** @type {HTMLCanvasElement} */ static #Canvas;\n    /** @type {GPUCanvasContext} */ static #Context;\n\n    /** @type {GPUTextureFormat} */ static #PreferredCanvasFormat;\n\n    /** @type {GPURequestAdapterOptions} */ static #AdapterOptions =\n    {\n        powerPreference: undefined, forceFallbackAdapter: false\n    }\n\n    /** @type {GPUDeviceDescriptor} */ static #DeviceDescriptor =\n    {\n        label: \"\", requiredFeatures: [], requiredLimits: {}\n    }\n\n    /** @type {((detail: GPUDeviceLostInfo) => unknown) | undefined} */ static OnDeviceLost;\n\n    /** @param {GPUPowerPreference} [powerPreference = undefined] */\n    static SetAdapterOptions(powerPreference = undefined, forceFallbackAdapter = false)\n    {\n        UWAL.#AdapterOptions.powerPreference = powerPreference;\n        UWAL.#AdapterOptions.forceFallbackAdapter = forceFallbackAdapter;\n    }\n\n    /**\n     * @param {Iterable<GPUFeatureName>} [requiredFeatures = []]\n     * @param {Record<string, GPUSize64>} [requiredLimits = {}]\n     */\n    static SetDeviceDescriptor(label = \"\", requiredFeatures = [], requiredLimits = {})\n    {\n        UWAL.#DeviceDescriptor.label = label;\n        UWAL.#DeviceDescriptor.requiredFeatures = requiredFeatures;\n        UWAL.#DeviceDescriptor.requiredLimits = requiredLimits;\n    }\n\n    static SetCanvasSize(width = innerWidth, height = innerHeight)\n    {\n        !UWAL.#Canvas && ThrowError(ERROR.CANVAS_NOT_FOUND);\n        !UWAL.#Device && ThrowError(ERROR.DEVICE_NOT_FOUND);\n\n        const { maxTextureDimension2D } = UWAL.#Device.limits;\n\n        width = Math.max(1, Math.min(width, maxTextureDimension2D));\n        height = Math.max(1, Math.min(height, maxTextureDimension2D));\n\n        if (UWAL.#Canvas.width !== width || UWAL.#Canvas.height !== height)\n        {\n            UWAL.#Canvas.height = height;\n            UWAL.#Canvas.width = width;\n        }\n    }\n\n    /**\n     * @param {HTMLCanvasElement} canvas\n     * @param {string} [commandEncoderLabel = \"\"]\n     * @typedef {Object} ConfigurationOptions\n     * @property {GPUTextureFormat} [format = undefined]\n     * @property {GPUTextureUsageFlags} [usage = 0x10] - GPUTextureUsage.RENDER_ATTACHMENT\n     * @property {Iterable<GPUTextureFormat>} [viewFormats = []]\n     * @property {PredefinedColorSpace} [colorSpace = \"srgb\"]\n     * @property {GPUCanvasAlphaMode} [alphaMode = \"opaque\"]\n     * @param {ConfigurationOptions} [options = {}]\n     */\n    static RenderPipeline(canvas, commandEncoderLabel = \"\", options = {})\n    {\n        return (async () =>\n        {\n            const device = await UWAL.Device;\n            const context = canvas.getContext(\"webgpu\");\n\n            !context && ThrowError(ERROR.CONTEXT_NOT_FOUND);\n\n            const preferredFormat = options.format ?? UWAL.#PreferredCanvasFormat;\n            const configuration = { ...options, format: preferredFormat };\n\n            context.configure({ device, ...configuration });\n\n            UWAL.#Canvas = canvas;\n            UWAL.#Context = context;\n\n            return new Proxy(RenderPipeline,\n            {\n                construct(Pipeline)\n                {\n                    return new Pipeline(device, commandEncoderLabel, preferredFormat);\n                }\n            });\n        })();\n    }\n\n    /** @param {string} [commandEncoderLabel = \"\"] */\n    static ComputePipeline(commandEncoderLabel = \"\")\n    {\n        return (async () =>\n        {\n            const device = await UWAL.Device;\n\n            return new Proxy(ComputePipeline,\n            {\n                construct(Pipeline)\n                {\n                    return new Pipeline(device, commandEncoderLabel);\n                }\n            });\n        })();\n    }\n\n    /**\n     * @param {GPUBuffer | GPUBuffer[]} [buffers = undefined]\n     * @param {GPUTexture | GPUTexture[]} [textures = undefined]\n     * @param {GPUQuerySet | GPUQuerySet[]} [querySets = undefined]\n     */\n    static Destroy(buffers, textures, querySets)\n    {\n        // Optionally remove all GPUBuffers:\n        buffers = Array.isArray(buffers) ? buffers : [buffers];\n        buffers.forEach(buffer => buffer?.destroy());\n\n        // Optionally remove all GPUTextures:\n        textures = Array.isArray(textures) ? textures : [textures];\n        textures.forEach(texture => texture?.destroy());\n\n        // Optionally remove all GPUQuerySets:\n        querySets = Array.isArray(querySets) ? querySets : [querySets];\n        querySets.forEach(querySet => querySet?.destroy());\n\n        // Remove GPUCanvasContext configuration:\n        UWAL.#Context?.unconfigure();\n\n        // Destroy GPUDevice:\n        UWAL.#Device?.destroy();\n    }\n\n    static #RequestAdapter()\n    {\n        !navigator.gpu && ThrowError(ERROR.WEBGPU_NOT_SUPPORTED);\n\n        UWAL.#PreferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();\n\n        return async () =>\n        {\n            const adapter = await navigator.gpu.requestAdapter(UWAL.#AdapterOptions);\n            !adapter && ThrowError(ERROR.ADAPTER_NOT_FOUND);\n            return UWAL.#Adapter = adapter;\n        };\n    }\n\n    static #RequestDevice()\n    {\n        return async () =>\n        {\n            const { requiredFeatures, requiredLimits, label } = UWAL.#DeviceDescriptor;\n\n            const device = await (await UWAL.Adapter).requestDevice({\n                requiredFeatures, requiredLimits, defaultQueue: { label }\n            });\n\n            !device && ThrowError(ERROR.DEVICE_NOT_FOUND);\n            device.lost.then(UWAL.#DeviceLost);\n            return UWAL.#Device = device;\n        };\n    }\n\n    /** @param {GPUDeviceLostInfo} detail */\n    static #DeviceLost(detail)\n    {\n        if (UWAL.OnDeviceLost) return UWAL.OnDeviceLost(detail);\n\n        UWAL.#Canvas.dispatchEvent(new CustomEvent(EVENT.DEVICE_LOST, { detail }));\n\n        const message = (detail.message && ` | Message: ${detail.message}`) ?? \".\";\n\n        // If device is destroyed intentionally, `reason` will be `destroyed`.\n        ThrowError(ERROR.DEVICE_LOST, ` Reason: ${detail.reason}` + message);\n    }\n\n    static get Adapter()\n    {\n        return (async () => UWAL.#Adapter ?? (await UWAL.#RequestAdapter()()))();\n    }\n\n    static get Device()\n    {\n        return (async () => UWAL.#Device ?? (await UWAL.#RequestDevice()()))();\n    }\n\n    /** @returns {HTMLCanvasElement | undefined} */\n    static get Canvas()\n    {\n        return UWAL.#Canvas;\n    }\n\n    /** @returns {GPUCanvasContext | undefined} */\n    static get Context()\n    {\n        return UWAL.#Context;\n    }\n\n    static get AspectRatio()\n    {\n        !UWAL.#Canvas && ThrowError(ERROR.CANVAS_NOT_FOUND);\n        return UWAL.#Canvas.width / UWAL.#Canvas.height;\n    }\n\n    static get CurrentTexture()\n    {\n        return UWAL.#Context.getCurrentTexture();\n    }\n\n    static get CurrentTextureView()\n    {\n        return UWAL.CurrentTexture.createView();\n    }\n\n    static get VERSION()\n    {\n        return VERSION;\n    }\n}\n\nconsole.info(`%cUWAL v${UWAL.VERSION}`, \"background:#005a9c;padding:3px;color:#fff;\");\n","struct Screen\n{\n    color: vec3f,\n    time: f32\n};\n\nstruct VertexOutput {\n  @location(0) coords: vec2f,\n  @builtin(position) position: vec4f\n};\n\n@group(0) @binding(0) var<uniform> screen: Screen;\n\n@vertex fn vertex(@builtin(vertex_index) index: u32) -> VertexOutput\n{\n    let position = array(\n        vec2f(-1.0, -1.0),\n        vec2f( 1.0, -1.0),\n        vec2f( 1.0,  1.0),\n\n        vec2f( 1.0,  1.0),\n        vec2f(-1.0,  1.0),\n        vec2f(-1.0, -1.0)\n    );\n\n    var output: VertexOutput;\n    let coords = position[index];\n\n    output.position = vec4f(coords, 0, 1);\n    output.coords = coords;\n\n    return output;\n}\n\n@fragment fn fragment(@location(0) coords: vec2f) -> @location(0) vec4f\n{\n    return vec4f(cos(coords.xyx + screen.time) * 0.2 + screen.color + 0.4, 1);\n}\n","// For local development:\nimport UWAL from \"@/UWAL\";\n\n// import UWAL from \"../../lib/UWAL\";\nimport ScreenShader from \"./ScreenShader.wgsl\";\n\n/** @type {number} */ let raf;\n\n/** @param {HTMLCanvasElement} canvas */\nexport async function run(canvas)\n{\n    /** @type {InstanceType<Awaited<ReturnType<UWAL.RenderPipeline>>>} */ let Renderer;\n\n    try { Renderer = new (await UWAL.RenderPipeline(canvas, \"Screen Shader Encoder\")) }\n    catch (error) { alert(error) }\n\n    const descriptor = Renderer.CreateRenderPassDescriptor(\n        Renderer.CreateColorAttachment(),\n        \"Screen Shader Render Pass\"\n    );\n\n    const module = Renderer.CreateShaderModule(ScreenShader, \"Screen Shader Uniforms\");\n    const vertex = Renderer.CreateVertexState(module);\n    const fragment = Renderer.CreateFragmentState(module);\n\n    const pipeline = Renderer.CreateRenderPipeline({\n        label: \"Screen Shader Pipeline\", vertex, fragment\n    });\n\n    const screenUniformBufferSize =\n        Float32Array.BYTES_PER_ELEMENT +\n        Float32Array.BYTES_PER_ELEMENT * 3;\n\n    const screenUniformBuffer = Renderer.CreateBuffer({\n        label: \"Screen Shader Uniform Buffer\",\n        size: screenUniformBufferSize,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n    });\n\n    const bindGroup = Renderer.CreateBindGroup({\n        label: \"Screen Shader Uniform Buffer Bind Group\",\n        layout: pipeline.getBindGroupLayout(0),\n        entries: Renderer.CreateBindGroupEntries(\n            { buffer: screenUniformBuffer }\n        )\n    });\n\n    const screenUniformValues = new Float32Array(\n        screenUniformBufferSize / Float32Array.BYTES_PER_ELEMENT\n    );\n\n    screenUniformValues.set([0.0, 0.3515625, 0.609375]);\n\n    /** @param {DOMHighResTimeStamp} time */\n    function render(time)\n    {\n        screenUniformValues.set([time * 0.001], 3);\n        UWAL.SetCanvasSize(canvas.width, canvas.height);\n        descriptor.colorAttachments[0].view = UWAL.CurrentTextureView;\n\n        Renderer.WriteBuffer(screenUniformBuffer, screenUniformValues);\n        Renderer.Render(descriptor, pipeline, 6);\n        raf = requestAnimationFrame(render);\n    }\n\n    const observer = new ResizeObserver(entries =>\n    {\n        for (const entry of entries)\n        {\n            const { inlineSize, blockSize } = entry.contentBoxSize[0];\n            UWAL.SetCanvasSize(inlineSize, blockSize);\n        }\n\n        Renderer.AddBindGroups(bindGroup);\n        raf = requestAnimationFrame(render);\n    });\n\n    observer.observe(canvas);\n}\n\nexport function destroy()\n{\n    cancelAnimationFrame(raf);\n    UWAL.Destroy();\n}\n"],"names":["CreateConstantObject","values","constants","value","EVENT","ERROR","ERROR_MESSAGE","ERROR_CAUSE","ThrowWarning","warning","message","ThrowError","error","_CommandEncoderLabel","_CommandEncoder","BasePipeline","device","commandEncoderLabel","__privateAdd","__publicField","__privateSet","descriptor","buffer","data","bufferOffset","dataOffset","size","source","destination","sourceOffset","destinationOffset","shader","label","sourceMap","hints","code","resources","resource","binding","bindGroups","__privateGet","_PreferredCanvasFormat","_CurrentPass","RenderPipeline","preferredFormat","view","loadOp","storeOp","clearValue","resolveTarget","depthSlice","colorAttachments","depthStencilAttachment","occlusionQuerySet","timestampWrites","maxDrawCount","module","entry","buffers","targets","layout","pipeline","drawParams","submit","encoder","g","l","_Workgroups","ComputePipeline","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","pass","workgroups","_Adapter","_Device","_Canvas","_Context","_AdapterOptions","_DeviceDescriptor","_RequestAdapter","RequestAdapter_fn","_RequestDevice","RequestDevice_fn","_DeviceLost","DeviceLost_fn","_UWAL","powerPreference","forceFallbackAdapter","requiredFeatures","requiredLimits","width","height","maxTextureDimension2D","canvas","options","context","configuration","Pipeline","textures","querySets","_a","_b","texture","__privateMethod","adapter","detail","UWAL","ScreenShader_default","raf","run","Renderer","ScreenShader","vertex","fragment","screenUniformBufferSize","screenUniformBuffer","bindGroup","screenUniformValues","render","time","entries","inlineSize","blockSize","destroy"],"mappings":"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"}