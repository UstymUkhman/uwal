var j=Object.defineProperty;var Y=(a,e,t)=>e in a?j(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var U=(a,e,t)=>(Y(a,typeof e!="symbol"?e+"":e,t),t),b=(a,e,t)=>{if(!e.has(a))throw TypeError("Cannot "+t)};var o=(a,e,t)=>(b(a,e,"read from private field"),t?t.call(a):e.get(a)),u=(a,e,t)=>{if(e.has(a))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(a):e.set(a,t)},E=(a,e,t,r)=>(b(a,e,"write to private field"),r?r.call(a,t):e.set(a,t),t);var _=(a,e,t)=>(b(a,e,"access private method"),t);function G(a){const e={};for(let t in a)e[t]={value:a[t]};return Object.freeze(Object.create(null,e))}const H=G({DEVICE_LOST:"Device::Lost"}),D=G({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND"}),I=G({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder."}),J=G({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7});function K(a,e){console.warn(I[a]+(e??""))}function f(a,e){throw new Error(I[a]+(e??""),{cause:J[a]})}var N,v;class z{constructor(e,t){u(this,N,void 0);U(this,"Device");U(this,"BindGroups",[]);u(this,v,void 0);!e&&f(D.DEVICE_NOT_REQUESTED),this.Device=e,E(this,N,t)}CreateBuffer(e){return this.Device.createBuffer(e)}WriteBuffer(e,t,r=0,i,s){this.Device.queue.writeBuffer(e,r,t,i,s)}CopyBufferToBuffer(e,t,r,i=0,s=0){this.CommandEncoder.copyBufferToBuffer(e,i,t,s,r)}CreateShaderModule(e,t="",r,i){const s=Array.isArray(e)?e.join(`

`):e;return this.Device.createShaderModule({label:t,code:s,sourceMap:r,compilationHints:i})}CreateBindGroupEntries(e){return Array.isArray(e)?e.map((t,r)=>({binding:r,resource:t})):[{binding:0,resource:e}]}CreateBindGroup(e){return this.Device.createBindGroup(e)}AddBindGroups(e){this.BindGroups=Array.isArray(e)?e:[e]}CreateCommandEncoder(){return E(this,v,this.Device.createCommandEncoder({label:o(this,N)}))}SubmitCommandBuffer(){this.Device.queue.submit([this.CommandEncoder.finish()])}get CommandEncoder(){if(!o(this,v)){const e=` ${o(this,N)&&`Label: "${o(this,N)}". `}`;return K(D.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one."),this.CreateCommandEncoder()}return o(this,v)}}N=new WeakMap,v=new WeakMap;var g,C;class Z extends z{constructor(t,r,i){super(t,r);u(this,g,void 0);u(this,C,void 0);E(this,g,i)}CreateColorAttachment(t,r="load",i="store",s,c,O){return{view:t,loadOp:r,storeOp:i,clearValue:s,resolveTarget:c,depthSlice:O}}CreateRenderPassDescriptor(t,r="",i,s,c,O){return t=Array.isArray(t)?t:[t],{colorAttachments:t,label:r,depthStencilAttachment:i,occlusionQuerySet:s,timestampWrites:c,maxDrawCount:O}}CreateVertexState(t,r="vertex",i,s){return{module:t,entryPoint:r,constants:i,buffers:s}}CreateFragmentState(t,r="fragment",i,s){return i??(i=[{format:o(this,g)}]),{module:t,entryPoint:r,targets:i,constants:s}}CreateRenderPipeline(t){const r=t.layout??"auto";return this.Device.createRenderPipeline({...t,layout:r})}Render(t,r,i,s=!0){if(!o(this,C)){const c=this.CreateCommandEncoder();E(this,C,c.beginRenderPass(t)),o(this,C).setPipeline(r)}for(let c=0,O=this.BindGroups.length;c<O;++c)o(this,C).setBindGroup(c,this.BindGroups[c]);i=typeof i=="number"?{vertexCount:i}:i,o(this,C).draw(i.vertexCount,i.instanceCount,i.firstVertex,i.firstInstance),s&&(o(this,C).end(),E(this,C,void 0),this.SubmitCommandBuffer())}get CurrentPass(){return o(this,C)}}g=new WeakMap,C=new WeakMap;var P;class ee extends z{constructor(t,r){super(t,r);u(this,P,[1])}CreateComputePassDescriptor(t="",r,i,s){return{label:t,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:i,endOfPassWriteIndex:s}:void 0}}CreateComputePipeline(t){const r=t.layout??"auto";return this.Device.createComputePipeline({label:t.label,layout:r,compute:t})}Compute(t,r){const i=this.CommandEncoder.beginComputePass(r);i.setPipeline(t);for(let s=0,c=this.BindGroups.length;s<c;++s)i.setBindGroup(s,this.BindGroups[s]);i.dispatchWorkgroups(...o(this,P)),i.end()}set Workgroups(t){E(this,P,Array.isArray(t)?t:[t])}}P=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.1
 * @license MIT
 */var A,l,d,T,R,h,m,B,L,y,q,V,Q;const n=class n{static SetAdapterOptions(e=void 0,t=!1){o(n,h).powerPreference=e,o(n,h).forceFallbackAdapter=t}static SetDeviceDescriptor(e="",t=[],r={}){o(n,m).label=e,o(n,m).requiredFeatures=t,o(n,m).requiredLimits=r}static SetCanvasSize(e=innerWidth,t=innerHeight){!o(n,d)&&f(D.CANVAS_NOT_FOUND),!o(n,l)&&f(D.DEVICE_NOT_FOUND);const{maxTextureDimension2D:r}=o(n,l).limits;e=Math.max(1,Math.min(e,r)),t=Math.max(1,Math.min(t,r)),(o(n,d).width!==e||o(n,d).height!==t)&&(o(n,d).height=t,o(n,d).width=e)}static RenderPipeline(e,t="",r={}){return(async()=>{const i=await n.Device,s=e.getContext("webgpu");!s&&f(D.CONTEXT_NOT_FOUND);const c=r.format??o(n,R),O={...r,format:c};return s.configure({device:i,...O}),E(n,d,e),E(n,T,s),new Proxy(Z,{construct(F){return new F(i,t,c)}})})()}static ComputePipeline(e=""){return(async()=>{const t=await n.Device;return new Proxy(ee,{construct(r){return new r(t,e)}})})()}static Destroy(e,t,r){var i,s;e=Array.isArray(e)?e:[e],e.forEach(c=>c==null?void 0:c.destroy()),t=Array.isArray(t)?t:[t],t.forEach(c=>c==null?void 0:c.destroy()),r=Array.isArray(r)?r:[r],r.forEach(c=>c==null?void 0:c.destroy()),(i=o(n,T))==null||i.unconfigure(),(s=o(n,l))==null||s.destroy()}static get Adapter(){return(async()=>{var e;return o(n,A)??await _(e=n,B,L).call(e)()})()}static get Device(){return(async()=>{var e;return o(n,l)??await _(e=n,y,q).call(e)()})()}static get Canvas(){return o(n,d)}static get Context(){return o(n,T)}static get AspectRatio(){return!o(n,d)&&f(D.CANVAS_NOT_FOUND),o(n,d).width/o(n,d).height}static get CurrentTexture(){return o(n,T).getCurrentTexture()}static get CurrentTextureView(){return n.CurrentTexture.createView()}static get VERSION(){return"0.0.1"}};A=new WeakMap,l=new WeakMap,d=new WeakMap,T=new WeakMap,R=new WeakMap,h=new WeakMap,m=new WeakMap,B=new WeakSet,L=function(){return!navigator.gpu&&f(D.WEBGPU_NOT_SUPPORTED),E(n,R,navigator.gpu.getPreferredCanvasFormat()),async()=>{const e=await navigator.gpu.requestAdapter(o(n,h));return!e&&f(D.ADAPTER_NOT_FOUND),E(n,A,e)}},y=new WeakSet,q=function(){return async()=>{const{requiredFeatures:e,requiredLimits:t,label:r}=o(n,m),i=await(await n.Adapter).requestDevice({requiredFeatures:e,requiredLimits:t,defaultQueue:{label:r}});return!i&&f(D.DEVICE_NOT_FOUND),i.lost.then(_(n,V,Q)),E(n,l,i)}},V=new WeakSet,Q=function(e){if(n.OnDeviceLost)return n.OnDeviceLost(e);o(n,d).dispatchEvent(new CustomEvent(H.DEVICE_LOST,{detail:e}));const t=(e.message&&` | Message: ${e.message}`)??".";f(D.DEVICE_LOST,` Reason: ${e.reason}`+t)},u(n,B),u(n,y),u(n,V),u(n,A,null),u(n,l,null),u(n,d,void 0),u(n,T,void 0),u(n,R,void 0),u(n,h,{powerPreference:void 0,forceFallbackAdapter:!1}),u(n,m,{label:"",requiredFeatures:[],requiredLimits:{}}),U(n,"OnDeviceLost");let p=n;console.info(`%cUWAL v${p.VERSION}`,"background:#005a9c;padding:3px;color:#fff;");var te="struct Screen{color: vec3f,time: f32};struct VertexOutput{@location(0)coords: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>screen: Screen;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=array(vec2f(-1.0,-1.0),vec2f(1.0,-1.0),vec2f(1.0,1.0),vec2f(1.0,1.0),vec2f(-1.0,1.0),vec2f(-1.0,-1.0));var output: VertexOutput;let coords=position[index];output.position=vec4f(coords,0,1);output.coords=coords;return output;}@fragment fn fragment(@location(0)coords: vec2f)->@location(0)vec4f {return vec4f(cos(coords.xyx+screen.time)*0.2+screen.color+0.4,1);}";let w;async function ie(a){let e;try{e=new(await p.RenderPipeline(a,"Screen Shader Encoder"))}catch(S){alert(S)}const t=e.CreateRenderPassDescriptor(e.CreateColorAttachment(),"Screen Shader Render Pass"),r=e.CreateShaderModule(te,"Screen Shader Uniforms"),i=e.CreateVertexState(r),s=e.CreateFragmentState(r),c=e.CreateRenderPipeline({label:"Screen Shader Pipeline",vertex:i,fragment:s}),O=Float32Array.BYTES_PER_ELEMENT+Float32Array.BYTES_PER_ELEMENT*3,F=e.CreateBuffer({label:"Screen Shader Uniform Buffer",size:O,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),W=e.CreateBindGroup({label:"Screen Shader Uniform Buffer Bind Group",layout:c.getBindGroupLayout(0),entries:e.CreateBindGroupEntries({buffer:F})}),x=new Float32Array(O/Float32Array.BYTES_PER_ELEMENT);x.set([0,.3515625,.609375]);function M(S){x.set([S*.001],3),p.SetCanvasSize(a.width,a.height),t.colorAttachments[0].view=p.CurrentTextureView,e.WriteBuffer(F,x),e.Render(t,c,6),w=requestAnimationFrame(M)}new ResizeObserver(S=>{for(const k of S){const{inlineSize:X,blockSize:$}=k.contentBoxSize[0];p.SetCanvasSize(X,$)}e.AddBindGroups(W),w=requestAnimationFrame(M)}).observe(a)}function oe(){cancelAnimationFrame(w),p.Destroy()}export{oe as destroy,ie as run};
//# sourceMappingURL=index-XE6pvuvY.js.map
