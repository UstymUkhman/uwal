import{D as W}from"./index-BbNCSufw.js";var X="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;output.position=vec4f(position*scale+offset,0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Vertex Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Vertex Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.4
 * @license MIT
 */(async function(E){let e;try{e=new(await W.RenderPipeline(E,"Vertex Buffers"))}catch(r){alert(r)}const D=0,M=1,O=0,i=100,V=[],w=e.CreatePassDescriptor(e.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),C=e.CreateShaderModule(X);e.CreatePipeline({fragment:e.CreateFragmentState(C),vertex:e.CreateVertexState(C,"vertex",[{arrayStride:4+2*Float32Array.BYTES_PER_ELEMENT,attributes:[e.CreateVertexBufferAttribute("float32x2"),e.CreateVertexBufferAttribute("unorm8x4",4,8)]},{arrayStride:4+2*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[e.CreateVertexBufferAttribute("unorm8x4",1),e.CreateVertexBufferAttribute("float32x2",2,4)]},{stepMode:"instance",arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[e.CreateVertexBufferAttribute("float32x2",3)]}])});const b=4+2*Float32Array.BYTES_PER_ELEMENT,p=2*Float32Array.BYTES_PER_ELEMENT,y=b*i,P=p*i,{vertexData:g,indexData:d}=Y({innerRadius:.25,outerRadius:.5}),U=e.CreateBuffer({label:"Vertex Buffer",size:g.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.WriteBuffer(U,g);const T=e.CreateBuffer({label:"Constant Vertex Buffer",size:y,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),A=e.CreateBuffer({label:"Variable Vertex Buffer",size:P,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.SetVertexBuffers([U,T,A]);const h=e.CreateBuffer({label:"Index Buffer",size:d.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});e.WriteBuffer(h,d),e.SetIndexBuffer(h);{const r=new Uint8Array(y),t=new Float32Array(r.buffer);for(let n=0;n<i;++n){const a=b*n,l=a/4;r.set([u(255),u(255),u(255),255],a+D),t.set([u(-.9,.9),u(-.9,.9)],l+M),V.push({scale:u(.2,.5)})}e.WriteBuffer(T,t)}const _=new Float32Array(P/Float32Array.BYTES_PER_ELEMENT),F=d.length;function Y({endAngle:r=Math.PI*2,subdivisions:t=24,innerRadius:n=0,outerRadius:a=1,startAngle:l=0}){const G=(t+1)*2,x=new Float32Array(G*3),v=new Uint8Array(x.buffer);let S=0,B=8;const z=(f,s,o)=>{x[S++]=f,x[S++]=s,v[B++]=o[0]*255,v[B++]=o[1]*255,v[B++]=o[2]*255,B+=9,S+=1},L=[1,1,1],N=[.1,.1,.1],I=r-l;for(let f=0;f<=t;f++){const s=l+f*I/t,o=Math.cos(s),R=Math.sin(s);z(o*a,R*a,N),z(o*n,R*n,L)}const c=new Uint32Array(t*6);for(let f=0,s=0;s<t;s++){const o=s*2;c[f++]=o+1,c[f++]=o+3,c[f++]=o+2,c[f++]=o+2,c[f++]=o+0,c[f++]=o+1}return{vertexData:x,indexData:c}}function u(r,t){return r===void 0?(r=0,t=1):t===void 0&&(t=r,r=0),Math.random()*(t-r)+r}function m(){e.SetCanvasSize(E.width,E.height);const r=e.AspectRatio;w.colorAttachments[0].view=e.CurrentTextureView,V.forEach(({scale:t},n)=>{const a=p/4*n;_.set([t/r,t],a+O)}),e.WriteBuffer(A,_),e.Render([F,i])}new ResizeObserver(r=>{for(const t of r){const{inlineSize:n,blockSize:a}=t.contentBoxSize[0];e.SetCanvasSize(n,a)}m()}).observe(document.body)})(document.getElementById("lesson"));
