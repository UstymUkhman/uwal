import{T as i,E as n,c as o}from"./index-CWG6eoQD.js";class u{#f=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]);#t;#i=new Float32Array(16);#e;#r;constructor(t){this.#t=t??"Cube"}async CreatePipeline(t,e){const r=`${this.#t} Pipeline`;return Array.isArray(e)||typeof e=="string"?e={shader:e,pipelineName:r}:e instanceof GPUShaderModule?e={module:e,pipelineName:r}:e.pipelineName??=r,this.#e=await t.CreatePipeline(e),this.#n(),this.#o(),this.#a(),this.#e}AddVertexBuffers(t,e,r){!this.#e&&i(n.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Cube.CreatePipeline` or `Cube.SetRenderPipeline` method before adding vertex buffers."),this.#e.AddVertexBuffers(t,e,r)}SetRenderPipeline(t){this.#e=t,this.#n(),this.#o(),this.#a()}#n(){this.#r=this.#e.CreateBuffer({size:this.#i.length*Float32Array.BYTES_PER_ELEMENT,label:`${this.#t} Uniform Buffer`,usage:o.UNIFORM})}#o(){const t=new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),e=this.#e.CreateVertexBuffer(t,{label:`${this.#t} Vertex Buffer`});this.#e.WriteBuffer(e,t),this.#e.SetVertexBuffers(e)}#a(){const t=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),e=this.#e.CreateIndexBuffer(t,{label:`${this.#t} Index Buffer`});this.#e.WriteBuffer(e,t),this.#e.SetIndexBuffer(e,"uint16"),this.#e.SetDrawParams(t.length)}Update(){this.#e.WriteBuffer(this.#r,this.#i)}GetPositionBufferLayout(t){const e=t??this.#e;return!e&&i(n.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Pass it as argument to `Cube.GetPositionBufferLayout` method or call `Cube.CreatePipeline`\n            or `Cube.SetRenderPipeline` before getting a position buffer layout."),e.CreateVertexBufferLayout({name:"position",format:"float32x3"})}get ProjectionBuffer(){return this.#r}get Projection(){return this.#i}get Pipeline(){return this.#e}get UV(){return this.#f}Destroy(){this.#e.Destroy(),this.#r.destroy(),this.#r=void 0}}var s="struct VertexInput{@location(0)position: vec4f,@location(1)color: vec4f};struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>color: vec4f;@group(0)@binding(1)var<uniform>projection: mat4x4f;@vertex fn vertex(input: VertexInput)->VertexOutput {var output: VertexOutput;output.position=projection*input.position;output.color=input.color;return output;}@fragment fn fragment(input: VertexOutput)->@location(0)vec4f {return input.color*color;}";export{s as C,u as a};
