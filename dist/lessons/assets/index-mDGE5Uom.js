import{D as b,U as d,a as c}from"./index-FaxOCIzz.js";var y="struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>matrix: mat4x4f;@vertex fn vertex(@location(1)position: vec4f,@location(0)color: vec4f)->VertexOutput{var output: VertexOutput;output.position=matrix*position;output.color=color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";function C(){const i=[0,0,0,30,0,0,0,150,0,30,150,0,30,0,0,100,0,0,30,30,0,100,30,0,30,60,0,70,60,0,30,90,0,70,90,0,0,0,30,30,0,30,0,150,30,30,150,30,30,0,30,100,0,30,30,30,30,100,30,30,30,60,30,70,60,30,30,90,30,70,90,30],e=[0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,14,13,14,15,13,16,18,17,18,19,17,20,22,21,22,23,21,0,12,5,12,17,5,5,17,7,17,19,7,6,7,18,18,7,19,6,18,8,18,20,8,8,20,9,20,21,9,9,21,11,21,23,11,10,11,22,22,11,23,10,22,3,22,15,3,2,3,14,14,3,15,0,2,12,12,2,14],t=[200,70,120,200,70,120,200,70,120,80,70,200,80,70,200,80,70,200,70,200,210,160,160,220,90,130,110,200,200,70,210,100,70,210,160,70,70,180,210,100,70,210,76,210,100,140,210,80],s=e.length,r=new Float32Array(s*4),l=new Uint8Array(r.buffer);for(let a=0;a<s;a++){let n=e[a]*3;r.set(i.slice(n,n+3),a*4),n=(a/6|0)*3,l.set(t.slice(n,n+3),a*16+12),l[a*16+15]=255}return{vertexData:r,vertices:s}}/**
 * @module Orthographic Projection
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Math
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-orthographic-projection.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.11
 * @license MIT
 */(async function(i){let e;i.style.backgroundPosition="-1.5px -1.5px, -1.5px -1.5px, -1px -1px, -1px -1px",i.style.backgroundSize="100px 100px, 100px 100px, 10px 10px, 10px 10px",i.style.backgroundColor="#000",i.style.backgroundImage=`
        linear-gradient(       #666 1.5px, transparent 1.5px),
        linear-gradient(90deg, #666 1.5px, transparent 1.5px),
        linear-gradient(       #333 1px,   transparent 1px),
        linear-gradient(90deg, #333 1px,   transparent 1px)
    `;try{e=new(await b.RenderPipeline(i,"MatrixMath",{alphaMode:"premultiplied"}))}catch(p){alert(p)}const t={translation:[45,100,0],scale:[1,1,1],rotation:[d.DegreesToRadians(40),d.DegreesToRadians(25),d.DegreesToRadians(325)]},s={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},r=new GUI().onChange(f);r.add(t.translation,"0",0,1e3).name("translation.x"),r.add(t.translation,"1",0,1e3).name("translation.y"),r.add(t.translation,"2",-1e3,1e3).name("translation.z"),r.add(t.rotation,"0",s).name("rotation.x"),r.add(t.rotation,"1",s).name("rotation.y"),r.add(t.rotation,"2",s).name("rotation.z"),r.add(t.scale,"0",-5,5).name("scale.x"),r.add(t.scale,"1",-5,5).name("scale.y"),r.add(t.scale,"2",-5,5).name("scale.z");const{vertexData:l,vertices:a}=C(),n=e.CreateShaderModule(y),{layout:m,buffer:u}=e.CreateVertexBuffer([{name:"position",format:"float32x3"},{name:"color",format:"unorm8x4"}],l.byteLength/4);e.CreatePipeline({vertex:e.CreateVertexState(n,void 0,m),depthStencil:e.CreateDepthStencilState(),fragment:e.CreateFragmentState(n),primitive:{cullMode:"front"}});const{matrix:o,buffer:x}=e.CreateUniformBuffer("matrix");e.CreatePassDescriptor(e.CreateColorAttachment(),void 0,e.CreateDepthAttachment()),e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries({buffer:x}))),e.WriteBuffer(u,l),e.SetVertexBuffers(u),e.Depth=400;function f(){c.copy(e.OrthographicProjection,o),c.translate(o,t.translation,o),c.rotateX(o,t.rotation[0],o),c.rotateY(o,t.rotation[1],o),c.rotateZ(o,t.rotation[2],o),c.scale(o,t.scale,o),e.WriteBuffer(x,o.buffer),e.Render(a)}new ResizeObserver(p=>{for(const g of p){const{inlineSize:v,blockSize:h}=g.contentBoxSize[0];e.SetCanvasSize(v,h),e.UpdateOrthographicProjection(400,-400)}f()}).observe(document.body)})(document.getElementById("lesson"));
