import{U as w,A as B,F as c}from"./index-DUOumvAP.js";import{G as _,a as D}from"./GPUMipmap-ZyUDCfwU.js";import{v as z,m as n}from"./wgpu-matrix.module-D3z0rCw6.js";import{F as V}from"./f-CdSZvatx.js";import{Q as M,C as j}from"./Quad-C4zpvK4p.js";const O=""+new URL("granite-Bhx_bMIh.jpeg",import.meta.url).href,Y=""+new URL("coins-DSWNLmZu.jpg",import.meta.url).href;/**
 * @module GPU Mipmaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Loading Images into Textures
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html#generating-mips-on-the-gpu}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.5
 * @license MIT
 */(async function(m){let t;try{t=new(await w.RenderPipeline(m,"GPU Mipmaps"))}catch(e){alert(e)}const G=(()=>{let e,o;return r=>{e||(e=t.CreateShaderModule([M,D]),o=p.CreateSampler({minFilter:c.LINEAR})),t.CreatePipeline({fragment:t.CreateFragmentState(e,"fragment",{format:r.format}),vertex:t.CreateVertexState(e)});let a=0,s=r.width,i=r.height;for(;1<s||1<i;)s=Math.max(s/2|0,1),i=Math.max(i/2|0,1),t.SetBindGroups(t.CreateBindGroup(t.CreateBindGroupEntries([o,r.createView({baseMipLevel:a++,mipLevelCount:1})]))),t.CreatePassDescriptor(t.CreateColorAttachment(r.createView({baseMipLevel:a,mipLevelCount:1}))),t.Render(6)}})(),I=async e=>await p.CreateBitmapImage(await(await fetch(e)).blob(),{colorSpaceConversion:"none"}),p=new(await w.Texture()),l=await Promise.all([d(V,{mipmaps:!0}),d(Y,{mipmaps:!0}),d(O,{mipmaps:!0})]);let u=0;const U=0,C=[],h=1,g=2e3,b=[0,1,0],x=[0,0,0],S=Math.PI*60/180,L=[0,0,2],R=z.set(1.2,.7),f=n.perspective(S,t.AspectRatio,h,g),T=n.inverse(n.lookAt(L,x,b)),A=n.multiply(f,T);t.CreatePipeline({module:t.CreateShaderModule([M,_])});const P=t.CreateColorAttachment();P.clearValue=new j(5000268).rgba,t.CreatePassDescriptor(P),t.ClearBindGroups();for(let e=0;e<8;e++){const o=p.CreateSampler({addressModeU:B.REPEAT,addressModeV:B.REPEAT,magFilter:e&1?c.LINEAR:c.NEAREST,minFilter:e&2?c.LINEAR:c.NEAREST,mipmapFilter:e&4?c.LINEAR:c.NEAREST}),r=16*Float32Array.BYTES_PER_ELEMENT,a=t.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:r}),s=new Float32Array(r/Float32Array.BYTES_PER_ELEMENT),i=s.subarray(U,16);t.AddBindGroups(l.map(E=>t.CreateBindGroup(t.CreateBindGroupEntries([o,E.createView(),{buffer:a}])))),C.push({matrixBuffer:a,matrixValues:s,matrix:i})}function N(e,{mipmaps:o,flip:r}={}){const a=p.CopyImageToTexture(e,{flipY:r,create:{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:o}});return a.mipLevelCount>1&&G(a),a}async function d(e,o){const r=await I(e);return N(r,o)}function v(){C.forEach(({matrix:e,matrixBuffer:o,matrixValues:r},a)=>{const i=a%4-1.5,E=+(a<4)*2-1,y=a*l.length+u,F=[i*R[0],E*R[1],-50*.5];n.translate(A,F,e),n.rotateX(e,Math.PI*.5,e),n.scale(e,[1,50*2,1],e),n.translate(e,[-.5,-.5,0],e),t.WriteBuffer(o,r),t.SetActiveBindGroups(y),t.Render(6,!1)}),t.Submit()}new ResizeObserver(e=>{for(const o of e){const{inlineSize:r,blockSize:a}=o.contentBoxSize[0];t.SetCanvasSize(r,a)}n.perspective(S,t.AspectRatio,h,g,f),n.multiply(f,T,A),v()}).observe(m),m.addEventListener("click",()=>{u=(u+1)%l.length,v()})})(document.getElementById("lesson"));
