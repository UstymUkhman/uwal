import{c as S}from"./F-CQ4x-uOT.js";import{D,U as s,a}from"./index-BbNCSufw.js";var b="struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>matrix: mat4x4f;@vertex fn vertex(@location(1)position: vec4f,@location(0)color: vec4f)->VertexOutput{var output: VertexOutput;output.position=matrix*position;output.color=color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Perspective Projection
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Perspective Projection
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.12
 * @license MIT
 */(async function(c){let e;c.style.backgroundColor="#000";try{e=new(await D.RenderPipeline(c,"Perspective Projection",{alphaMode:"premultiplied"}))}catch(i){alert(i)}const t={scale:[1,1,1],fieldOfView:100,translation:[-65,0,-120],rotation:[s.DegreesToRadians(220),s.DegreesToRadians(25),s.DegreesToRadians(325)]},n={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},r=new GUI().onChange(m);r.add(t,"fieldOfView",{min:1,max:179}).name("Field of View"),r.add(t.translation,"0",-1e3,1e3).name("translation.x"),r.add(t.translation,"1",-1e3,1e3).name("translation.y"),r.add(t.translation,"2",-1400,-100).name("translation.z"),r.add(t.rotation,"0",n).name("rotation.x"),r.add(t.rotation,"1",n).name("rotation.y"),r.add(t.rotation,"2",n).name("rotation.z");const{vertexData:p,vertices:l}=S(),f=e.CreateShaderModule(b),{layout:v,buffer:d}=e.CreateVertexBuffer([{name:"position",format:"float32x3"},{name:"color",format:"unorm8x4"}],l);e.CreatePipeline({vertex:e.CreateVertexState(f,void 0,v),depthStencil:e.CreateDepthStencilState(),fragment:e.CreateFragmentState(f),primitive:{cullMode:"front"}});const{matrix:o,buffer:u}=e.CreateUniformBuffer("matrix");e.CreatePassDescriptor(e.CreateColorAttachment(),void 0,e.CreateDepthAttachment()),e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries({buffer:u}))),e.WriteBuffer(d,p),e.SetVertexBuffers(d),e.Depth=400;function m(){e.UpdatePerspectiveProjection(t.fieldOfView,1,2e3),a.copy(e.PerspectiveProjection,o),a.translate(o,t.translation,o),a.rotateX(o,t.rotation[0],o),a.rotateY(o,t.rotation[1],o),a.rotateZ(o,t.rotation[2],o),a.scale(o,t.scale,o),e.WriteBuffer(u,o),e.Render(l)}new ResizeObserver(i=>{for(const x of i){const{inlineSize:g,blockSize:C}=x.contentBoxSize[0];e.SetCanvasSize(g,C)}m()}).observe(document.body)})(document.getElementById("lesson"));
