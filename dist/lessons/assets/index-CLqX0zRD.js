import{D as Y,U as D,a as j}from"./index-BEuvW3M9.js";import{C as L,a as O,M as W}from"./Cube-C3wSyf39.js";import{P as X}from"./PerspectiveCamera-3423PXjM.js";/**
 * @module Recursive Tree
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Stacks
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html#a-recursive-tree}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.1.0
 * @license MIT
 */(async function(b){let r;b.style.backgroundColor="#000";try{r=new(await Y.Renderer(b,"Recursive Tree",{alphaMode:"premultiplied"}))}catch(t){alert(t)}const a={rotationX:D.DegreesToRadians(20),rotationY:D.DegreesToRadians(10),baseRotation:0,scale:.9},y={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},C={min:0,max:90,step:1,converters:GUI.converters.radToDeg},B=[20,150,20],U=[1,1,1,1],d=[],x=6;let l=0;j.create();const i=new W,u=new GUI().onChange(P);u.add(a,"scale",.1,1.2),u.add(a,"rotationX",C),u.add(a,"rotationY",C),u.add(a,"baseRotation",y);const c=new X(60,1,2e3);c.Position=[0,450,1e3],c.LookAt([0,450,0]);const A=c.UpdateViewProjection(!1);r.CreatePassDescriptor(r.CreateColorAttachment(),r.CreateDepthStencilAttachment());const f=new O,e=new r.Pipeline,v=e.CreateShaderModule(L),{layout:T,buffer:S}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);f.SetRenderPipeline(await r.AddPipeline(e,{primitive:{cullMode:"back"},fragment:e.CreateFragmentState(v),depthStencil:e.CreateDepthStencilState(),vertex:e.CreateVertexState(v,void 0,[f.GetPositionBufferLayout(e),T])}));const V=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],h=f.UV.length/2,p=new Uint8Array(h*4);for(let t=0,o=0;t<h;o=(++t/4|0)*3){const n=V.slice(o,o+3);p.set(n,t*4),p[t*4+3]=255}e.WriteBuffer(S,p),f.AddVertexBuffers(S);function G(t,o){if(l===d.length){const{projection:I,buffer:R}=e.CreateUniformBuffer("projection"),{color:M,buffer:g}=e.CreateUniformBuffer("color");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([g,R]))),d.push({projectionValue:I,projectionBuffer:R,colorValue:M,colorBuffer:g})}const{projectionValue:n,projectionBuffer:s,colorValue:w,colorBuffer:z}=d[l];w.set(o),e.WriteBuffer(z,w),j.multiply(A,t,n),e.WriteBuffer(s,n),e.SetActiveBindGroups(l++),r.Render(!1)}function k(){i.Push().Scale(B).Translate([0,.5,0]),G(i.Get(),U),i.Pop()}function m(t,o){const n=t?a.scale:1,s=t?B[1]:0;i.Push().Translate([0,s,0]).RotateZ(t*a.rotationX).RotateY(Math.abs(t)*a.rotationY).Scale([n,n,n]),k(),0<o&&(m(-1,o-1),m(1,o-1)),i.Pop()}function P(){i.Push(),i.RotateY(a.baseRotation),l=0,m(0,x),i.Pop(),r.Submit()}new ResizeObserver(t=>{for(const o of t){const{inlineSize:n,blockSize:s}=o.contentBoxSize[0];r.SetCanvasSize(n,s),c.AspectRatio=r.AspectRatio,c.UpdateViewProjection(!1)}P()}).observe(document.body)})(document.getElementById("lesson"));
