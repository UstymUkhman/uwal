import{c as G,a as F}from"./mipmaps-kMQ0t0FP.js";import{U as h,A as b,F as s}from"./index-DWxnOMSU.js";import{v as N,m as o}from"./wgpu-matrix.module-D3z0rCw6.js";import{C as _,Q as L}from"./Quad-C4zpvK4p.js";var z="struct Transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@group(0)@binding(2)var<uniform>transform: Transform;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=transform.matrix*vec4f(position,0.0,1.0);output.textureCoord=position*vec2f(1,50);return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}";/**
 * @module Mipmap Filter
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Textures
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-textures.html#mipmapfilter}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.5
 * @license MIT
 */(async function(p){let t;try{t=new(await h.RenderPipeline(p,"Mipmap Filter"))}catch(e){alert(e)}const P=t.CreatePassDescriptor(t.CreateColorAttachment(void 0,"clear","store",new _(5000268).rgba));t.CreatePipeline({module:t.CreateShaderModule([L,z])});const l=new(await h.Texture());let d=0;const B=0,x=[],f=[A(G(),"Blended"),A(F(),"Checked")];for(let e=0;e<8;e++){const a=l.CreateSampler({addressModeU:b.REPEAT,addressModeV:b.REPEAT,magFilter:e&1?s.LINEAR:s.NEAREST,minFilter:e&2?s.LINEAR:s.NEAREST,mipmapFilter:e&4?s.LINEAR:s.NEAREST}),n=16*Float32Array.BYTES_PER_ELEMENT,r=t.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:n}),i=new Float32Array(n/Float32Array.BYTES_PER_ELEMENT),u=i.subarray(B,16);t.AddBindGroups(f.map(c=>t.CreateBindGroup(t.CreateBindGroupEntries([a,c.createView(),{buffer:r}])))),x.push({matrixBuffer:r,matrixValues:i,matrix:u})}const v=1,E=2e3,M=[0,1,0],I=[0,0,0],T=60*Math.PI/180,w=[0,0,2],g=N.set(1.2,.7),m=o.perspective(T,t.AspectRatio,v,E),C=o.inverse(o.lookAt(w,I,M)),S=o.multiply(m,C);function A(e,a){const n=l.CreateTexture({usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,size:[e[0].width,e[0].height],mipLevelCount:e.length,label:`${a} Texture`,format:"rgba8unorm"});return e.forEach(({data:r,width:i,height:u},c)=>l.WriteTexture(r,{bytesPerRow:i*4,texture:n,mipLevel:c,width:i,height:u})),n}function R(){P.colorAttachments[0].view=t.CurrentTextureView,x.forEach(({matrix:e,matrixBuffer:a,matrixValues:n},r)=>{const u=r%4-1.5,c=+(r<4)*2-1,U=r*f.length+d,y=[u*g[0],c*g[1],-50*.5];o.translate(S,y,e),o.rotateX(e,.5*Math.PI,e),o.scale(e,[1,50*2,1],e),o.translate(e,[-.5,-.5,0],e),t.WriteBuffer(a,n),t.SetActiveBindGroups(U),t.Render(6,!1)}),t.Submit()}new ResizeObserver(e=>{for(const a of e){const{inlineSize:n,blockSize:r}=a.contentBoxSize[0];t.SetCanvasSize(n,r)}o.perspective(T,t.AspectRatio,v,E,m),o.multiply(m,C,S),R()}).observe(p),p.addEventListener("click",()=>{d=(d+1)%f.length,R()})})(document.getElementById("lesson"));
