import{T as s,E as n,c as o,a as i}from"./index-CWG6eoQD.js";class f{#t=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]);#i;#s=new Float32Array(16);#e;#r;constructor(t){this.#i=t??"Cube"}async CreatePipeline(t,e){const r=`${this.#i} Pipeline`;return Array.isArray(e)||typeof e=="string"?e={shader:e,pipelineName:r}:e instanceof GPUShaderModule?e={module:e,pipelineName:r}:e.pipelineName??=r,this.#e=await t.CreatePipeline(e),this.#n(),this.#a(),this.#o(),this.#e}AddVertexBuffers(t,e,r){!this.#e&&s(n.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Cube.CreatePipeline` or `Cube.SetRenderPipeline` method before adding vertex buffers."),this.#e.AddVertexBuffers(t,e,r)}SetRenderPipeline(t){this.#e=t,this.#n(),this.#a(),this.#o()}#n(){this.#r=this.#e.CreateBuffer({size:this.#s.length*Float32Array.BYTES_PER_ELEMENT,label:`${this.#i} Uniform Buffer`,usage:o.UNIFORM})}#a(){const t=new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),e=this.#e.CreateVertexBuffer(t,{label:`${this.#i} Vertex Buffer`});this.#e.WriteBuffer(e,t),this.#e.SetVertexBuffers(e)}#o(){const t=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),e=this.#e.CreateIndexBuffer(t,{label:`${this.#i} Index Buffer`});this.#e.WriteBuffer(e,t),this.#e.SetIndexBuffer(e,"uint16"),this.#e.SetDrawParams(t.length)}Update(){this.#e.WriteBuffer(this.#r,this.#s)}GetPositionBufferLayout(t){const e=t??this.#e;return!e&&s(n.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Pass it as argument to `Cube.GetPositionBufferLayout` method or call `Cube.CreatePipeline`\n            or `Cube.SetRenderPipeline` before getting a position buffer layout."),e.CreateVertexBufferLayout({name:"position",format:"float32x3"})}get ProjectionBuffer(){return this.#r}get Projection(){return this.#s}get Pipeline(){return this.#e}get UV(){return this.#t}Destroy(){this.#e.Destroy(),this.#r.destroy(),this.#r=void 0}}class h{#t=i.identity();#i=[];Push(){return this.#i.push(this.#t),this.#t=i.copy(this.#t),this}Pop(){return this.#t=this.#i.pop(),this}Translate(t){return i.translate(this.#t,t,this.#t),this}RotateX(t){return i.rotateX(this.#t,t,this.#t),this}RotateY(t){return i.rotateY(this.#t,t,this.#t),this}RotateZ(t){return i.rotateZ(this.#t,t,this.#t),this}Scale(t){return i.scale(this.#t,t,this.#t),this}Set(t){return this.#t.set(t)}Get(){return this.#t}Reset(){return this.#t=i.identity(),this.#i=[],this}}var l="struct VertexInput{@location(0)position: vec4f,@location(1)color: vec4f};struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>color: vec4f;@group(0)@binding(1)var<uniform>projection: mat4x4f;@vertex fn vertex(input: VertexInput)->VertexOutput {var output: VertexOutput;output.position=projection*input.position;output.color=input.color;return output;}@fragment fn fragment(input: VertexOutput)->@location(0)vec4f {return input.color*color;}";export{l as C,h as M,f as a};
