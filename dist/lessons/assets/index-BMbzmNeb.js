import{D as U,a as d}from"./index-BLf8dJ29.js";import{P as V}from"./PerspectiveCamera-BY8F8tzl.js";var z="struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>projection: mat4x4f;@vertex fn vertex(@location(1)position: vec4f,@location(0)color: vec4f)->VertexOutput{var output: VertexOutput;output.position=projection*position;output.color=color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";function G(){const u=[-50,75,15,-20,75,15,-50,-75,15,-20,-75,15,-20,75,15,50,75,15,-20,45,15,50,45,15,-20,15,15,20,15,15,-20,-15,15,20,-15,15,-50,75,-15,-20,75,-15,-50,-75,-15,-20,-75,-15,-20,75,-15,50,75,-15,-20,45,-15,50,45,-15,-20,15,-15,20,15,-15,-20,-15,-15,20,-15,-15],e=[0,2,1,2,3,1,4,6,5,6,7,5,8,10,9,10,11,9,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23,0,5,12,12,5,17,5,7,17,17,7,19,6,18,7,18,19,7,6,8,18,18,8,20,8,9,20,20,9,21,9,11,21,21,11,23,10,22,11,22,23,11,10,3,22,22,3,15,2,14,3,14,15,3,0,12,2,12,14,2],p=[200,70,120,200,70,120,200,70,120,80,70,200,80,70,200,80,70,200,70,200,210,160,160,220,90,130,110,200,200,70,210,100,70,210,160,70,70,180,210,100,70,210,76,210,100,140,210,80],c=e.length,o=new Float32Array(c*4),l=new Uint8Array(o.buffer);for(let t=0;t<c;t++){let n=e[t]*3;o.set(u.slice(n,n+3),t*4),n=(t/6|0)*3,l.set(p.slice(n,n+3),t*16+12),l[t*16+15]=255}return{vertexData:o,vertices:c}}/**
 * @module Cameras
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cameras
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.12
 * @license MIT
 */(async function(u){let e;u.style.backgroundColor="#000";try{e=new(await U.RenderPipeline(u,"Cameras",{alphaMode:"premultiplied"}))}catch(r){alert(r)}const p={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},c=[0,1,0],o=5,l=5,t=5*5+1,n=200,f=new V(60,1,2e3),a={target:[0,200,300],targetAngle:0},g=[],v=new GUI().onChange(h);v.add(a.target,"1",-100,300).name("Target Height"),v.add(a,"targetAngle",p).name("Target Angle");const{vertexData:S,vertices:x}=G(),C=e.CreateShaderModule(z),{layout:A,buffer:b}=e.CreateVertexBuffer([{name:"position",format:"float32x3"},{name:"color",format:"unorm8x4"}],x);e.CreatePipeline({vertex:e.CreateVertexState(C,void 0,A),depthStencil:e.CreateDepthStencilState(),fragment:e.CreateFragmentState(C),primitive:{cullMode:"back"}}),e.CreatePassDescriptor(e.CreateColorAttachment(),void 0,e.CreateDepthAttachment()),e.WriteBuffer(b,S),e.SetVertexBuffers(b);for(let r=0;r<t;++r){const i=e.CreateUniformBuffer("projection");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries({buffer:i.buffer}))),g.push(i)}function h(){a.target[0]=Math.cos(a.targetAngle)*n,a.target[2]=Math.sin(a.targetAngle)*n,f.Position=[-500,300,-500],f.LookAt([0,-100,0]);const r=f.UpdateViewProjection(!1);g.forEach(({projection:i,buffer:m},s)=>{if(s===25)d.translate(r,a.target,i);else{const B=s%o/(o-1),w=(s/o|0)/(l-1),y=(B-.5)*o*150,D=(w-.5)*l*150,P=d.aim([y,0,D],a.target,c);d.multiply(r,P,i)}e.WriteBuffer(m,i),e.SetActiveBindGroups(s),e.Render(x,!1)}),e.Submit()}new ResizeObserver(r=>{for(const i of r){const{inlineSize:m,blockSize:s}=i.contentBoxSize[0];e.SetCanvasSize(m,s),f.AspectRatio=m/s}h()}).observe(document.body)})(document.getElementById("lesson"));
