import{_ as e,a as t,b as n,d as r,f as i,g as a,h as o,i as s,l as c,m as l,n as u,p as d,s as f,y as p}from"./lib-CmpeTGut.js";import{n as m,t as h}from"./F-B-w0IlMC.js";var g=class extends m{#e=o.create();#t=o.create();#n=o.set(0,1,0);#r=l.create();#i=i.create();#a=1;constructor(e,t=`SpotLight`){super(t),this.Position=e||this.#t}LookAt(e){return i.aim(this.#t,e,this.#n,this.#i),o.copy(this.#i.slice(8,11),this.#e)}set Position(e){o.copy(e,this.#t)}get Position(){return this.#t}set Intensity(e){this.#a=Math.max(e,d.EPSILON)}get Intensity(){return this.#a}set Limit(e){this.#r.set(e.toSorted().map(Math.cos))}get Limit(){return this.#r}},_=`struct VertexOutput{@location(0)normal: vec3f,@location(1)lightDirection: vec3f,@location(2)cameraDirection: vec3f,@builtin(position)position: vec4f};@group(0)@binding(2)var<uniform>Light: LightUniforms;@group(0)@binding(3)var<uniform>Camera: CameraUniforms;@vertex fn meshVertex(@location(0)position: vec4f,@location(1)normal: vec3f)->VertexOutput {var output: VertexOutput;output.position=GetVertexClipSpace(position);let worldPosition=GetVertexWorldPosition(position);output.lightDirection=GetLightDirection(worldPosition,Light.position);output.cameraDirection=GetCameraDirection(worldPosition,Camera.position);output.normal=GetVertexNormal(MeshUniforms.worldNormal,normal);return output;}@fragment fn meshFragment(vertex: VertexOutput)->@location(0)vec4f {let spotLightColor=GetSpotLightColor(SpotLight(vertex.normal,Light.intensity,vertex.lightDirection,vertex.cameraDirection,Light.direction,Light.limit),color.rgb);return vec4f(spotLightColor,color.a);}`;(async function(i){let o;try{o=new(await(a.Renderer(i,`Spot Lighting`)))}catch(e){alert(e)}let l=new t,d=new GUI;d.onChange(I);let m=new u,v=new f,y=new o.Pipeline,b={innerLimit:r.DegreesToRadians(15),outerLimit:r.DegreesToRadians(25),rotation:r.DegreesToRadians(0),aimOffsetX:-10,aimOffsetY:10,shininess:30},x=y.CreateShaderModule([p,n,e,_]),{Camera:S,buffer:C}=y.CreateUniformBuffer(`Camera`),{Light:w,buffer:T}=y.CreateUniformBuffer(`Light`),E=new s(v,new c(3407667)),D={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},O={min:0,max:90,minRange:1,step:1,converters:GUI.converters.radToDeg},k=[y.CreateVertexBufferLayout({name:`position`,format:`float32x3`},`meshVertex`),y.CreateVertexBufferLayout({name:`normal`,format:`float32x3`},`meshVertex`)];E.SetRenderPipeline(await o.AddPipeline(y,{vertex:y.CreateVertexState(x,k,`meshVertex`),fragment:y.CreateFragmentState(x,void 0,`meshFragment`),depthStencil:y.CreateDepthStencilState(),primitive:y.CreatePrimitiveState()}),[T,C]);let{positionData:A,normalData:j,vertices:M}=h(),N=y.CreateVertexBuffer(j);d.add(b,`rotation`,D),d.add(b,`shininess`,{min:1,max:250}),GUI.makeMinMaxPair(d,b,`innerLimit`,`outerLimit`,O),d.add(b,`aimOffsetX`,-50,50),d.add(b,`aimOffsetY`,-50,50),v.CreatePositionBuffer(y,A),y.WriteBuffer(N,j),y.AddVertexBuffers(N),v.SetDrawParams(M);let P=new g([-10,30,100]);w.position.set(P.Position);let F=[0,35,0];l.Add(E);function I(){S.position.set(m.Position),w.intensity[0]=P.Intensity=b.shininess;let{aimOffsetX:e,aimOffsetY:t}=b,{innerLimit:n,outerLimit:r}=b;P.Limit=[n,r],w.limit.set(P.Limit),w.direction.set(P.LookAt([F[0]+e,F[1]+t,F[2]])),y.WriteBuffer(T,w.position.buffer),y.WriteBuffer(C,S.position),E.Rotation=[0,b.rotation,0],o.Render(l)}new ResizeObserver(e=>{for(let t of e){let{inlineSize:e,blockSize:n}=t.contentBoxSize[0];o.SetCanvasSize(e,n),m.AspectRatio=o.AspectRatio,m.UpdateViewProjectionMatrix(),m.Position=[100,150,200],m.LookAt(F),l.AddCamera(m)}I()}).observe(document.body)})(document.getElementById(`lesson`));