import{U as q,F as re,B as i}from"./index-GPjqY_Dq.js";import{m as H}from"./wgpu-matrix.module-0Oa3LLlt.js";import{Q as oe}from"./Quad-VFYOTGYq.js";var ne="struct Matrix{values: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>matrix: Matrix;@group(0)@binding(2)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=matrix.values*vec4f(position,0.0,1.0);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}";/**
 * @module Blend Settings
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Transparency and Blending
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-transparency.html#blend-settings}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.7
 * @license MIT
 */(async function(c){let r;c.style.backgroundPosition="0 0, 0 16px, 16px -16px, -16px 0px",c.style.backgroundSize="32px 32px",c.style.backgroundColor="#404040",c.style.backgroundImage=`
        linear-gradient( 45deg,     #808080 25%, transparent 25%),
        linear-gradient(-45deg,     #808080 25%, transparent 25%),
        linear-gradient( 45deg, transparent 75%,     #808080 75%),
        linear-gradient(-45deg, transparent 75%,     #808080 75%)
    `;try{r=new(await q.RenderPipeline(c,"Blend Settings",{alphaMode:"premultiplied"}))}catch(e){alert(e)}const I=(e,t,o)=>`hsl(${e*360|0}, ${t*100}%, ${o*100|0}%)`,A=(e,t,o,n)=>`hsla${I(e,t,o).slice(3,-1)}, ${n})`;function J(e){const t=document.createElement("canvas");t.width=t.height=e;const o=t.getContext("2d");o.translate(e/2,e/2),o.globalCompositeOperation="screen";const n=Math.PI*2,a=3;for(let l=0;l<a;++l){o.rotate(n/a),o.save(),o.translate(e/6,0),o.beginPath();const u=e/3,X=l/a;o.arc(0,0,u,0,n);const E=o.createRadialGradient(0,0,u/2,0,0,u);E.addColorStop(.5,A(X,1,.5,1)),E.addColorStop(1,A(X,1,.5,0)),o.fillStyle=E,o.fill(),o.restore()}return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function K(e){const t=document.createElement("canvas");t.width=t.height=e;const o=t.getContext("2d"),n=o.createLinearGradient(0,0,e,e);for(let a=0;a<=6;++a)n.addColorStop(a/6,I(a/-6,1,.5));o.fillStyle=n,o.fillRect(0,0,e,e),o.fillStyle="rgba(0, 0, 0, 255)",o.globalCompositeOperation="destination-out",o.rotate(Math.PI/-4);for(let a=0;a<e*2;a+=32)o.fillRect(-e,a,e*2,16);return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function F(){const{values:e}=r.CreateUniformBufferLayout("matrix"),t=r.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:e.buffer.byteLength});return{values:e,buffer:t}}function h(e,t=!0){return N.CopyImageToTexture(e,{premultipliedAlpha:t,create:{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:!1}})}function d(e){typeof e=="string"&&!["constant","one-minus-constant"].includes(e)||(r.BlendConstant=[...b.color,b.alpha])}function B(){const{premultiply:e,alpha:t,color:o}=f,n=e&&t||1,[a,l,u]=o;C.clearValue[0]=a*n,C.clearValue[1]=l*n,C.clearValue[2]=u*n,C.clearValue[3]=t}function R(e){const{operation:t}=e;(t==="min"||t==="max")&&(e.srcFactor=e.dstFactor="one")}function D(e,t,o){const n=H.ortho(0,t.width,t.height,0,-1,1);H.scale(n,[o.width,o.height,1],e.values),r.WriteBuffer(e.buffer,e.values)}const N=new(await q.Texture(r)),y=r.CreateShaderModule([oe,ne]),x=N.CreateSampler({filter:re.LINEAR}),V=J(300),_=K(300),v=F(),G=F(),w=h(V),M=h(_),L=h(V,!1),$=h(_,!1),g=r.CreateBindGroupLayout([{visibility:GPUShaderStage.FRAGMENT,sampler:{}},{visibility:GPUShaderStage.VERTEX,buffer:{}},{visibility:GPUShaderStage.FRAGMENT,texture:{}}]);r.SetBindGroups([r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},w.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},M.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},L.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},$.createView()]),g)]);const Z=[{sourceBindGroup:0,destinationBindGroup:1,sourceTexture:w,destinationTexture:M},{sourceBindGroup:2,destinationBindGroup:3,sourceTexture:L,destinationTexture:$}],s=new GUI().onChange(W),S={textureSet:0,alphaMode:"premultiplied",preset:"Copy (Default)"};s.add(S,"alphaMode",["opaque","premultiplied"]).name("Canvas Alpha Mode").onChange(e=>r.ConfigureContext({alphaMode:e})),s.add(S,"textureSet",["premultiplied alpha","un-premultiplied alpha"]).name("Texture Set");const z=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),ee=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),k={"Copy (Default)":i.COPY,"Additive (Lighten)":i.ADDITIVE,"Un-premultiplied Blend":{color:z,alpha:ee},"Source Over (Premultiplied Blend)":i.SOURCE_OVER,"Destination Over":i.DESTINATION_OVER,"Source In":i.SOURCE_IN,"Destination In":i.DESTINATION_IN,"Source Out":i.SOURCE_OUT,"Destination Out":i.DESTINATION_OUT,"Source Atop":i.SOURCE_ATOP,"Destination Atop":i.DESTINATION_ATOP};s.add(S,"preset",Object.keys(k)).name("Blending Preset").onChange(e=>{const t=k[e];Object.assign(p,t.color),Object.assign(m,t.alpha)});const O=s.addFolder("Color"),p=r.CreateBlendComponent(),j=["add","subtract","reverse-subtract","min","max"],T=["zero","one","src","one-minus-src","src-alpha","one-minus-src-alpha","dst","one-minus-dst","dst-alpha","one-minus-dst-alpha","src-alpha-saturated","constant","one-minus-constant"];O.add(p,"operation",j).name("Operation"),O.add(p,"srcFactor",T).name("Source Factor").onChange(d),O.add(p,"dstFactor",T).name("Destination Factor").onChange(d);const P=s.addFolder("Alpha"),m=r.CreateBlendComponent();P.add(m,"operation",j).name("Operation"),P.add(m,"srcFactor",T).name("Source Factor").onChange(d),P.add(m,"dstFactor",T).name("Destination Factor").onChange(d);const Q=s.addFolder("Constant"),b={color:[1,.5,.25],alpha:1};Q.addColor(b,"color").name("Color").onChange(d),Q.add(b,"alpha",0,1).name("Alpha").onChange(d);const U=s.addFolder("Canvas Clear Color"),f={color:[0,0,0],alpha:0,premultiply:!0};U.addColor(f,"color").name("Color").onChange(B),U.add(f,"alpha",0,1).name("Alpha").onChange(B),U.add(f,"premultiply").name("Premultiply").onChange(B);const C=r.CreateColorAttachment();C.clearValue=[...f.color,f.alpha];const Y=r.CreatePipelineLayout(g);r.CreatePassDescriptor(C),r.CreatePipeline({module:y,layout:Y});const te=r.CreateVertexState(y);function W(){R(p),R(m),s.updateDisplay();const{sourceTexture:e,destinationTexture:t,destinationBindGroup:o,sourceBindGroup:n}=Z[S.textureSet],a=r.CurrentTexture;D(v,a,e),D(G,a,t),r.SetActiveBindGroups(o),r.Render(6,!1),r.SavePipelineState();const l=r.CreateTargetState(void 0,{color:p,alpha:m}),u=r.CreateFragmentState(y,void 0,l);r.CreatePipeline({vertex:te,fragment:u,layout:Y},!0),r.SetActiveBindGroups(n),r.Render(6),r.RestorePipelineState()}new ResizeObserver(e=>{for(const t of e){const{inlineSize:o,blockSize:n}=t.contentBoxSize[0];r.SetCanvasSize(o,n)}W()}).observe(c)})(document.getElementById("lesson"));
