import{D as V,U as c,a}from"./index-CWG6eoQD.js";import{c as b}from"./F-CQ4x-uOT.js";import{P as w}from"./PerspectiveCamera-MopHud7N.js";var B="struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>matrix: mat4x4f;@vertex fn vertex(@location(1)position: vec4f,@location(0)color: vec4f)->VertexOutput{var output: VertexOutput;output.position=matrix*position;output.color=color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Perspective Projection
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Perspective Projection
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-perspective-projection.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.12
 * @license MIT
 */(async function(l){let e;l.style.backgroundColor="#000";try{e=new(await V.RenderPipeline(l,"Perspective Projection",{alphaMode:"premultiplied"}))}catch(s){alert(s)}const t={scale:[1,1,1],fieldOfView:100,translation:[-65,0,-120],rotation:[c.DegreesToRadians(220),c.DegreesToRadians(25),c.DegreesToRadians(325)]},n={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},r=new GUI().onChange(p),i=new w(t.fieldOfView,1,2e3);r.add(t,"fieldOfView",{min:1,max:179}).name("Field of View"),r.add(t.translation,"0",-1e3,1e3).name("translation.x"),r.add(t.translation,"1",-1e3,1e3).name("translation.y"),r.add(t.translation,"2",-1400,-100).name("translation.z"),r.add(t.rotation,"0",n).name("rotation.x"),r.add(t.rotation,"1",n).name("rotation.y"),r.add(t.rotation,"2",n).name("rotation.z");const{vertexData:C,vertices:f}=b(),d=e.CreateShaderModule(B),{layout:g,buffer:m}=e.CreateVertexBuffer([{name:"position",format:"float32x3"},{name:"color",format:"unorm8x4"}],f);e.CreatePipeline({vertex:e.CreateVertexState(d,void 0,g),depthStencil:e.CreateDepthStencilState(),fragment:e.CreateFragmentState(d),primitive:{cullMode:"front"}});const{matrix:o,buffer:u}=e.CreateUniformBuffer("matrix");e.CreatePassDescriptor(e.CreateColorAttachment(),void 0,e.CreateDepthAttachment()),e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries({buffer:u}))),e.WriteBuffer(m,C),e.SetVertexBuffers(m);function p(){i.FieldOfView=t.fieldOfView,a.copy(i.Projection,o),a.translate(o,t.translation,o),a.rotateX(o,t.rotation[0],o),a.rotateY(o,t.rotation[1],o),a.rotateZ(o,t.rotation[2],o),a.scale(o,t.scale,o),e.WriteBuffer(u,o),e.Render(f)}new ResizeObserver(s=>{for(const S of s){const{inlineSize:v,blockSize:x}=S.contentBoxSize[0];e.SetCanvasSize(v,x),i.AspectRatio=v/x}p()}).observe(document.body)})(document.getElementById("lesson"));
