import{addButtonLeftJustified as Te}from"https://webgpufundamentals.org/webgpu/resources/js/gui-helpers.js";import{D as Re,b as M,U as Be,a as Pe}from"./index-CWG6eoQD.js";import{C as Ue,a as ye}from"./Cube-Uz7Qg183.js";import{S as K,T as Q}from"./Transform-neAPMyd6.js";import{P as je}from"./PerspectiveCamera-MopHud7N.js";/**
 * @module Scene Graphs
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Scene Graphs
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-scene-graphs.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.1.0
 * @license MIT
 */(async function(V){let c;V.style.backgroundColor="#000";try{c=new(await Re.Renderer(V,"Scene Graphs",{alphaMode:"premultiplied"}))}catch(e){alert(e)}const S={min:-90,max:90,step:1,converters:GUI.converters.radToDeg},ee={min:-180,max:180,step:1,converters:GUI.converters.radToDeg},te=[.75,.75,.75,.75],[g,m,v]=[0,1,2],oe=[.5,.5,.5,1],ne=new Set([0,1,2]),ae=[1,1,1,1],d=[40,30,50],$=[10,2,2],T=4,z=[];let I=!1;const R=[];let B,x,h=0;const P=5,U=[];let y,O=0;const n={cameraRotation:Be.DegreesToRadians(-45),animate:!1,showMeshNodes:!1,showAllTransforms:!1,translation:M.zero(),rotation:M.zero(),scale:M.create(1,1,1)},w=new K("root"),f=new GUI().onChange(N),re=(e,t,o)=>(t-e)*o+e;f.add(n,"cameraRotation",ee),f.add(n,"animate").onChange(e=>i.enable(!e)),f.add(n,"showMeshNodes").onChange(_),f.add(n,"showAllTransforms").onChange(J);const i=f.addFolder("Orientation");i.onChange(he);const se=[i.add(n.translation,"0",-200,200,1).name("Translation X"),i.add(n.translation,"1",-200,200,1).name("Translation Y"),i.add(n.translation,"2",-200,200,1).name("Translation Z"),i.add(n.rotation,"0",S).name("Rotation X"),i.add(n.rotation,"1",S).name("Rotation Y"),i.add(n.rotation,"2",S).name("Rotation Z"),i.add(n.scale,"0",.1,100).name("Scale X"),i.add(n.scale,"1",.1,100).name("Scale Y"),i.add(n.scale,"2",.1,100).name("Scale Z")],ie=[0,d[m]/3*2-d[m]/2,$[v]/2+d[v]/2],W=d[g]+10,F=d[m]+3,j=[d[g]+6,F*T+6,d[v]+4],l=new je(60,1,2e3);let E=l.UpdateViewProjection();const ce=(j[g]+W)/2*(P-1)/2+4;c.CreatePassDescriptor(c.CreateColorAttachment(),c.CreateDepthStencilAttachment());const C=new ye,r=new c.Pipeline,L=r.CreateShaderModule(Ue),de=(T*2+1)*P+1,{layout:le,buffer:X}=r.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);C.SetRenderPipeline(await c.AddPipeline(r,{primitive:{cullMode:"back"},fragment:r.CreateFragmentState(L),depthStencil:r.CreateDepthStencilState(),vertex:r.CreateVertexState(L,void 0,[C.GetPositionBufferLayout(r),le])}));const fe=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],Y=C.UV.length/2,D=new Uint8Array(Y*4);for(let e=0,t=0;e<Y;t=(++e/4|0)*3){const o=fe.slice(t,t+3);D.set(o,e*4),D[e*4+3]=255}r.WriteBuffer(X,D),C.AddVertexBuffers(X);for(let e=0;e<P;++e)we(w,e);const ue=f.addFolder("Nodes"),me=k(ue,w);Z(w.Children[0]),J(!1),_(!1);function k(e,t,o,a){const s=[],u=a===void 0;if(t.Transform instanceof Q){const p=`${u?"":`${a} +-`}${t.Label}`;s.push(Te(e,p,()=>Z(t)))}return a=u?"":`${a}${o?"   ":" | "}`,s.push(...t.Children.map((p,b)=>k(e,p,b===t.Children.length-1,a))),s.flat()}function he(){const e=y.Transform;e.Translation.set(n.translation),e.Rotation.set(n.rotation),e.Scale.set(n.scale)}function q(){const e=y.Transform;n.translation.set(e.Translation),n.rotation.set(e.Rotation),n.scale.set(e.Scale),i.updateDisplay()}function Z(e){y=e,i.name(`Orientation: ${e.Label}`),q()}function J(e){se.forEach((t,o)=>t.show(e||ne.has(o)))}function _(e){for(const t of me)t.domElement.textContent.includes("mesh")&&t.show(e)}function A(e,t,o){const a=new K(e,new Q(...o));return t&&(a.Parent=t),a}function G(e,t,o,a){const s=A(e,t,o),u=U.push({node:s,color:a});return U[u-1]}function pe(e,t){const o=`drawer${t}`,a=j[m]/2-d[m]/2-5,s=A(o,e,[[0,F*t-a,3]]);z.push(s),G(`${o}-drawer-mesh`,s,[void 0,void 0,d],ae),G(`${o}-handle-mesh`,s,[ie,void 0,$],oe)}function we(e,t){const o=`cabinet${t}`,a=A(o,e,[[t*W,0,0]]);G(`${o}-mesh`,a,[void 0,void 0,j],te);for(let s=0;s<T;++s)pe(a,s)}function Ce(e,t){if(h===R.length){const{projection:p,buffer:b}=r.CreateUniformBuffer("projection"),{color:ve,buffer:H}=r.CreateUniformBuffer("color");r.AddBindGroups(r.CreateBindGroup(r.CreateBindGroupEntries([H,b]))),R.push({projectionValue:p,projectionBuffer:b,colorValue:ve,colorBuffer:H})}const{projectionValue:o,projectionBuffer:a,colorValue:s,colorBuffer:u}=R[h];s.set(t),r.WriteBuffer(u,s),Pe.multiply(E,e,o),r.WriteBuffer(a,o),r.SetActiveBindGroups(h),h=++h%de,c.Render(!1)}function N(){B||(B=requestAnimationFrame(ge))}function be(e){Ce(e.node.WorldMatrix,e.color)}function Se(){z.forEach((e,t)=>e.Transform.Translation[2]=re(3,d[2]*.8,Math.sin(O+t)*.5+.5))}function ge(){B=void 0,l.ResetMatrix(),l.Translate([ce,20,0]),l.RotateY(n.cameraRotation),l.Translate([0,0,300]),E=l.UpdateViewProjection(),w.UpdateWorldMatrix();for(const a of U)be(a);c.Submit();const e=n.animate,t=performance.now()*.001,o=I&&t-x||0;x=t,e&&(O+=o),I=e,n.animate&&(Se(),q(),N())}new ResizeObserver(e=>{for(const t of e){const{inlineSize:o,blockSize:a}=t.contentBoxSize[0];c.SetCanvasSize(o,a),l.AspectRatio=c.AspectRatio,l.UpdateViewProjection()}N()}).observe(document.body)})(document.getElementById("lesson"));
