import{T as G,E as O,b as q,a as s,D as H}from"./index-BEuvW3M9.js";import{P as J}from"./PerspectiveCamera-3423PXjM.js";class K{#e=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]);#r;#o=new Float32Array(16);#t;#i;constructor(e){this.#r=e??"Cube"}async CreatePipeline(e,t){const c=`${this.#r} Pipeline`;return Array.isArray(t)||typeof t=="string"?t={shader:t,pipelineName:c}:t instanceof GPUShaderModule?t={module:t,pipelineName:c}:t.pipelineName??=c,this.#t=await e.CreatePipeline(t),this.#n(),this.#s(),this.#a(),this.#t}AddVertexBuffers(e,t,c){!this.#t&&G(O.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Cube.CreatePipeline` or `Cube.SetRenderPipeline` method before adding vertex buffers."),this.#t.AddVertexBuffers(e,t,c)}SetRenderPipeline(e){this.#t=e,this.#n(),this.#s(),this.#a()}#n(){this.#i=this.#t.CreateBuffer({size:this.#o.length*Float32Array.BYTES_PER_ELEMENT,label:`${this.#r} Uniform Buffer`,usage:q.UNIFORM})}#s(){const e=new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),t=this.#t.CreateVertexBuffer(e,{label:`${this.#r} Vertex Buffer`});this.#t.WriteBuffer(t,e),this.#t.SetVertexBuffers(t)}#a(){const e=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),t=this.#t.CreateIndexBuffer(e,{label:`${this.#r} Index Buffer`});this.#t.WriteBuffer(t,e),this.#t.SetIndexBuffer(t,"uint16"),this.#t.SetDrawParams(e.length)}Update(){this.#t.WriteBuffer(this.#i,this.#o)}GetPositionBufferLayout(e){const t=e??this.#t;return!t&&G(O.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Pass it as argument to `Cube.GetPositionBufferLayout` method or call `Cube.CreatePipeline`\n            or `Cube.SetRenderPipeline` before getting a position buffer layout."),t.CreateVertexBufferLayout({name:"position",format:"float32x3"})}get ProjectionBuffer(){return this.#i}get Projection(){return this.#o}get Pipeline(){return this.#t}get UV(){return this.#e}Destroy(){this.#t.Destroy(),this.#i.destroy(),this.#i=void 0}}class Q{#e=s.identity();#r=[];Push(){return this.#r.push(this.#e),this.#e=s.copy(this.#e),this}Pop(){return this.#e=this.#r.pop(),this}Translate(e){return s.translate(this.#e,e,this.#e),this}RotateX(e){return s.rotateX(this.#e,e,this.#e),this}RotateY(e){return s.rotateY(this.#e,e,this.#e),this}RotateZ(e){return s.rotateZ(this.#e,e,this.#e),this}Scale(e){return s.scale(this.#e,e,this.#e),this}Set(e){return this.#e.set(e)}Get(){return this.#e}Reset(){return this.#e=s.identity(),this.#r=[],this}}var ee="struct VertexInput{@location(0)position: vec4f,@location(1)color: vec4f};struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>color: vec4f;@group(0)@binding(1)var<uniform>projection: mat4x4f;@vertex fn vertex(input: VertexInput)->VertexOutput {var output: VertexOutput;output.position=projection*input.position;output.color=input.color;return output;}@fragment fn fragment(input: VertexOutput)->@location(0)vec4f {return input.color*color;}";/**
 * @module Matrix Stacks
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cameras
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.1.0
 * @license MIT
 */(async function(p){let e;p.style.backgroundColor="#000";try{e=new(await H.Renderer(p,"Matrix Stacks",{alphaMode:"premultiplied"}))}catch(i){alert(i)}const t={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},c=[.75,.75,.75,.75],[S,f,b]=[0,1,2],T=[.5,.5,.5,1],L=[1,1,1,1],a=[40,30,50],m=[10,2,2],g=4,C=[];let d=0;const N=5;s.create();const r=new Q,v={baseRotation:0};new GUI().onChange(j).add(v,"baseRotation",t);const l=new J(60,1,2e3);l.Position=[0,15,250],l.LookAt([0,5,0]);const z=l.UpdateViewProjection(!1),M=[0,a[f]/3*2-a[f]/2,m[b]/2+a[b]/2],k=a[S]+10,w=a[f]+3,y=[a[S]+6,w*g+6,a[b]+4];e.CreatePassDescriptor(e.CreateColorAttachment(),e.CreateDepthStencilAttachment());const P=new K,o=new e.Pipeline,R=o.CreateShaderModule(ee),{layout:D,buffer:V}=o.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);P.SetRenderPipeline(await e.AddPipeline(o,{primitive:{cullMode:"back"},fragment:o.CreateFragmentState(R),depthStencil:o.CreateDepthStencilState(),vertex:o.CreateVertexState(R,void 0,[P.GetPositionBufferLayout(o),D])}));const F=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],A=P.UV.length/2,B=new Uint8Array(A*4);for(let i=0,n=0;i<A;n=(++i/4|0)*3){const u=F.slice(n,n+3);B.set(u,i*4),B[i*4+3]=255}o.WriteBuffer(V,B),P.AddVertexBuffers(V);function x(i,n){if(d===C.length){const{projection:X,buffer:I}=o.CreateUniformBuffer("projection"),{color:Z,buffer:E}=o.CreateUniformBuffer("color");o.AddBindGroups(o.CreateBindGroup(o.CreateBindGroupEntries([E,I]))),C.push({projectionValue:X,projectionBuffer:I,colorValue:Z,colorBuffer:E})}const{projectionValue:u,projectionBuffer:h,colorValue:U,colorBuffer:$}=C[d];U.set(n),o.WriteBuffer($,U),s.multiply(z,i,u),o.WriteBuffer(h,u),o.SetActiveBindGroups(d++),e.Render(!1)}function _(){r.Push(),r.Scale(a),x(r.Get(),L),r.Pop(),r.Push(),r.Translate(M),r.Scale(m),x(r.Get(),T),r.Pop()}function W(){r.Push(),r.Scale(y),x(r.Get(),c),r.Pop();const i=y[f]/2-a[f]/2-5;for(let n=0;n<g;++n)r.Push(),r.Translate([0,n*w-i,3]),_(),r.Pop()}function Y(){for(let i=0,n=1;i<N;++i){if(r.Push(),i){const u=i%2*2-1,h=k*u*n;r.Translate([h,0,0]),n+=~-u/-2}W(),r.Pop()}}function j(){r.Push(),r.RotateY(v.baseRotation),d=0,Y(),r.Pop(),e.Submit()}new ResizeObserver(i=>{for(const n of i){const{inlineSize:u,blockSize:h}=n.contentBoxSize[0];e.SetCanvasSize(u,h),l.AspectRatio=e.AspectRatio,l.UpdateViewProjection(!1)}j()}).observe(document.body)})(document.getElementById("lesson"));
