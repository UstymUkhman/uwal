import{U as B,A as w,F as n}from"./index-BwDKQVXi.js";import{G as N}from"./GPUMipmaps-Sf4roZHW.js";import{v as F,m as a}from"./wgpu-matrix.module-BCZfl02X.js";import{F as L}from"./f-CdSZvatx.js";import{C as _}from"./Color-DRvW8-9j.js";import{Q as D}from"./Quad-VFYOTGYq.js";const z=""+new URL("granite-Bhx_bMIh.jpeg",import.meta.url).href,j=""+new URL("coins-DSWNLmZu.jpg",import.meta.url).href;/**
 * @module GPU Mipmaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Loading Images into Textures
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html#generating-mips-on-the-gpu}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.5
 * @license MIT
 */(async function(p){let t;try{t=new(await B.RenderPipeline(p,"GPU Mipmaps"))}catch(e){alert(e)}const I=async e=>await c.CreateBitmapImage(await(await fetch(e)).blob(),{colorSpaceConversion:"none"}),c=new(await B.Texture());c.SetRenderer(t);const m=await Promise.all([f(L,{mipmaps:!0}),f(j,{mipmaps:!0}),f(z,{mipmaps:!0})]);let l=0;const v=0,R=[],T=1,A=2e3,G=[0,1,0],b=[0,0,0],g=Math.PI*60/180,x=[0,0,2],S=F.set(1.2,.7),u=a.perspective(g,t.AspectRatio,T,A),P=a.inverse(a.lookAt(x,b,G)),C=a.multiply(u,P);t.CreatePipeline({module:t.CreateShaderModule([D,N])});const U=t.CreateColorAttachment();U.clearValue=new _(5000268).rgba,t.CreatePassDescriptor(U);for(let e=0;e<8;e++){const s=c.CreateSampler({addressModeU:w.REPEAT,addressModeV:w.REPEAT,magFilter:e&1?n.LINEAR:n.NEAREST,minFilter:e&2?n.LINEAR:n.NEAREST,mipmapFilter:e&4?n.LINEAR:n.NEAREST}),o=16*Float32Array.BYTES_PER_ELEMENT,r=t.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:o}),i=new Float32Array(o/Float32Array.BYTES_PER_ELEMENT),E=i.subarray(v,16);t.AddBindGroups(m.map(d=>t.CreateBindGroup(t.CreateBindGroupEntries([s,d.createView(),{buffer:r}])))),R.push({matrixBuffer:r,matrixValues:i,matrix:E})}async function f(e,s){const{mipmaps:o,flip:r}=s,i=await I(e);return c.CopyImageToTexture(i,{flipY:r,create:{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:o}})}function h(){R.forEach(({matrix:e,matrixBuffer:s,matrixValues:o},r)=>{const E=r%4-1.5,d=+(r<4)*2-1,M=r*m.length+l,y=[E*S[0],d*S[1],-50*.5];a.translate(C,y,e),a.rotateX(e,Math.PI*.5,e),a.scale(e,[1,50*2,1],e),a.translate(e,[-.5,-.5,0],e),t.WriteBuffer(s,o),t.SetActiveBindGroups(M),t.Render(6,!1)}),t.Submit()}new ResizeObserver(e=>{for(const s of e){const{inlineSize:o,blockSize:r}=s.contentBoxSize[0];t.SetCanvasSize(o,r)}a.perspective(g,t.AspectRatio,T,A,u),a.multiply(u,P,C),h()}).observe(p),p.addEventListener("click",()=>{l=(l+1)%m.length,h()})})(document.getElementById("lesson"));
