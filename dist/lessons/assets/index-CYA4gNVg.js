var St=o=>{throw TypeError(o)};var st=(o,e,s)=>e.has(o)||St("Cannot "+s);var t=(o,e,s)=>(st(o,e,"read from private field"),s?s.call(o):e.get(o)),i=(o,e,s)=>e.has(o)?St("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(o):e.set(o,s),r=(o,e,s,c)=>(st(o,e,"write to private field"),c?c.call(o,s):e.set(o,s),s),L=(o,e,s)=>(st(o,e,"access private method"),s);import{m as x,c as Bt,v as Ct,N as Gt,D as At,C as it,U as rt}from"./index-D5aOD4ei.js";var Mt="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn shapeVertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}",p,P,S,q,Y,k,J,E,B,_,n,U,l,V,C,w,F,T,d,D,G,I,R,v,bt,Et,Vt,nt;class Ot{constructor(e){i(this,v);i(this,p);i(this,P,0);i(this,S,!1);i(this,q,x.create());i(this,Y,x.create());i(this,k,x.create());i(this,J,x.create());i(this,E);i(this,B);i(this,_);i(this,n);i(this,U);i(this,l);i(this,V);i(this,C);i(this,w,[]);i(this,F,[void 0]);i(this,T,new Float32Array([1,1]));i(this,d,new Float32Array([0,0]));i(this,D,new Float32Array([0,0]));i(this,G,new Float32Array([0,0]));i(this,I);i(this,R,Bt({min:Ct.create(),max:Ct.create()}));r(this,n,e.renderer),r(this,B,e.segments),r(this,p,e.radius??0),r(this,E,e.label??"Shape");const{startAngle:s,endAngle:c,innerRadius:u}=e;L(this,v,bt).call(this,s,c,u),L(this,v,Et).call(this),L(this,v,Vt).call(this),this.Scale=t(this,T),this.Origin=t(this,d),this.Rotation=t(this,P),this.Position=t(this,G)}Update(){return t(this,n).SetVertexBuffers(t(this,w)),t(this,n).SetIndexBuffer(t(this,V)),t(this,n).SetBindGroups(t(this,F)),L(this,v,nt).call(this)}Render(e=!0){t(this,n).SavePipelineState(),t(this,n).Render(t(this.Update(),_),e),t(this,n).RestorePipelineState()}AddBindGroups(e){t(this,F).push(...Array.isArray(e)&&e||[e])}AddVertexBuffers(e){t(this,w).push(...Array.isArray(e)&&e||[e])}set Color(e){t(this,U).set(Array.isArray(e)||ArrayBuffer.isView(e)?e:e.rgba),t(this,n).WriteBuffer(t(this,C),t(this,U),t(this,I).color)}get Color(){return t(this,U)}set Position(e){t(this,G).set(e),x.translation(t(this,G),t(this,J)),r(this,S,!0)}get Position(){return t(this,G)}set Rotation(e){r(this,P,e),x.rotation(t(this,P),t(this,k)),r(this,S,!0)}get Rotation(){return t(this,P)}set Scale(e){t(this,T).set(e),x.scaling(t(this,T),t(this,Y)),r(this,S,!0)}get Scale(){return t(this,T)}set Origin(e){t(this,d)[0]=e[0],t(this,d)[1]=e[1],t(this,d)[0]*=-t(this,p),t(this,d)[1]*=-t(this,p),x.translation(t(this,d),t(this,q)),t(this,d)[0]=e[0]||0,t(this,d)[1]=e[1]||0,r(this,S,!0)}get Origin(){return t(this,d)}get Center(){return t(L(this,v,nt).call(this),D)}get Vertices(){return t(this,_)}get Transform(){return t(this,l)}get BoundingBox(){return t(this,R)}Destroy(){t(this,w).forEach(e=>e.destroy()),r(this,C,t(this,C).destroy()),r(this,V,t(this,V).destroy()),t(this,w).splice(0),t(this,F).splice(0)}}p=new WeakMap,P=new WeakMap,S=new WeakMap,q=new WeakMap,Y=new WeakMap,k=new WeakMap,J=new WeakMap,E=new WeakMap,B=new WeakMap,_=new WeakMap,n=new WeakMap,U=new WeakMap,l=new WeakMap,V=new WeakMap,C=new WeakMap,w=new WeakMap,F=new WeakMap,T=new WeakMap,d=new WeakMap,D=new WeakMap,G=new WeakMap,I=new WeakMap,R=new WeakMap,v=new WeakSet,bt=function(e=0,s=Gt.TAU,c=0){const u=s-e,A=new Float32Array((t(this,B)+1)*2*3);for(let O=0,N=0;N<=t(this,B);++N){const y=e+N*u/t(this,B),z=Math.cos(y),h=Math.sin(y);A[O++]=z*t(this,p),A[O++]=h*t(this,p),A[O++]=z*c,A[O++]=h*c}const K=t(this,n).CreateVertexBuffer(A,{label:`${t(this,E)} Vertex Buffer`});t(this,n).WriteBuffer(K,A),t(this,w).push(K)},Et=function(){const e=new Uint32Array(r(this,_,t(this,B)*6));for(let s=0,c=0;c<t(this,B);++c){const u=c*2;e[s++]=u+1,e[s++]=u+3,e[s++]=u+2,e[s++]=u+2,e[s++]=u+0,e[s++]=u+1}r(this,V,t(this,n).CreateIndexBuffer(e,{label:`${t(this,E)} Index Buffer`})),t(this,n).WriteBuffer(t(this,V),e)},Vt=function(){const{buffer:e,shape:{color:s,matrix:c}}=t(this,n).CreateUniformBuffer("shape",{label:`${t(this,E)} Uniform Buffer`});r(this,C,e),r(this,l,c),r(this,U,s),t(this,F)[0]=t(this,n).CreateBindGroup(t(this,n).CreateBindGroupEntries([{buffer:t(this,n).ResolutionBuffer},{buffer:t(this,C)}]),0,`${t(this,E)} Bind Group`),r(this,I,Bt({matrix:s.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT}))},nt=function(){if(t(this,S)){x.multiply(t(this,J),t(this,k),t(this,l)),x.multiply(t(this,l),t(this,Y),t(this,l)),x.multiply(t(this,l),t(this,q),t(this,l)),t(this,n).WriteBuffer(t(this,C),t(this,l),t(this,I).matrix);const e=t(this,D)[0]=t(this,l)[8],s=t(this,D)[1]=t(this,l)[9];t(this,R).min[0]=e-t(this,p),t(this,R).min[1]=s-t(this,p),t(this,R).max[0]=e+t(this,p),t(this,R).max[1]=s+t(this,p),r(this,S,!1)}return this};/**
 * @module NonNegativeRollingAverage
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description We disallow negative values as this is used for timestamp queries
 * where it's possible for a query to return a beginning time greater than
 * the end time. {@link https://gpuweb.github.io/gpuweb/#timestamp}
 * @version 0.0.11
 * @license MIT
 */var Q,H,M,W;class ot{constructor(e=30){i(this,Q,0);i(this,H,0);i(this,M,0);i(this,W,[]);r(this,Q,e)}addSample(e){if(Number.isFinite(e)&&!Number.isNaN(e)&&0<=e){const s=t(this,W)[t(this,M)]||0;r(this,H,t(this,H)+(e-s)),t(this,W)[t(this,M)]=e,r(this,M,(t(this,M)+1)%t(this,Q))}}get(){return t(this,H)/t(this,W).length}}Q=new WeakMap,H=new WeakMap,M=new WeakMap,W=new WeakMap;var Nt="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;let clipSpace=GetVertexClipSpace(position*scale).xy;output.position=vec4f(clipSpace+(offset+0.9)/1.8*vec2f(2,-2),0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Timing Performance
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Timing Performance
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(o){let e,s=0;try{await At.SetRequiredFeatures("timestamp-query"),e=new(await At.RenderPipeline(o,"Timing Performance"))}catch(a){alert(a)}const c=24,u=0,A=0,K=2,O=new GUI,N=[],y=1e4,z={objects:100};O.add(z,"objects",0,y,1);const h=document.createElement("pre"),at=document.createElement("span"),ct=document.createElement("span"),ft=document.createElement("span");h.style.backgroundColor="rgb(0 0 0 / 0.8)",h.style.position="absolute",h.style.padding="0.5em",h.style.display="grid",h.style.color="white",h.style.margin="0px",h.style.left="0px",h.style.top="0px",h.append(at,ct,ft),document.body.appendChild(h);const ht=new ot,lt=new ot,ut=new ot,pt=e.CreateShaderModule([Mt,Nt]),dt=e.CreateColorAttachment();dt.clearValue=new it(5000268).rgba;const tt=new rt.GPUTiming(e),wt=await tt.QuerySet;e.CreatePassDescriptor(dt,void 0,void 0,void 0,e.CreateTimestampWrites(wt,0,1));const Rt=e.CreateVertexBufferLayout("position"),{buffer:X,layout:Pt}=e.CreateVertexBuffer([{name:"color",format:"unorm8x4"}],y,"instance"),{buffer:Z,layout:Ut}=e.CreateVertexBuffer(["offset","scale"],y,"instance"),{buffer:mt,layout:Ft}=e.CreateVertexBuffer({name:"vertexColor",format:"unorm8x4"},y);e.CreatePipeline({fragment:e.CreateFragmentState(pt),vertex:e.CreateVertexState(pt,void 0,[Rt,Pt,Ut,Ft])});const Tt=new Ot({renderer:e,innerRadius:120,radius:240,segments:c}).Update().Vertices,et=new Float32Array(Z.size/Float32Array.BYTES_PER_ELEMENT);e.AddVertexBuffers([X,Z,mt]);{const a=X.size/y,f=new Uint8Array(X.size);for(let m=0;m<y;++m)f.set([b(255),b(255),b(255),255],a*m+u),N.push({scale:b(.2,.5),offset:[b(-.9,.9),b(-.9,.9)],velocity:[b(-.1,.1),b(-.1,.1)]});e.WriteBuffer(X,f)}{const a=new it(1644825),f=new it(16777215),m=new Uint8Array((c+1)*8);for(let j=0,g=0;j<=c;j++,g+=8)m.set(a.RGBA,g),m.set(f.RGBA,g+4);e.WriteBuffer(mt,m)}function b(a,f){return a===void 0?(a=0,f=1):f===void 0&&(f=a,a=0),Math.random()*(f-a)+a}async function xt(a){a*=.001;const f=a-s,m=performance.now(),j=Z.size/y/4;for(let g=0;g<z.objects;g++){const{scale:vt,offset:$,velocity:yt}=N[g];$[0]=rt.EuclideanModulo($[0]+yt[0]*f+1.5,3)-1.5,$[1]=rt.EuclideanModulo($[1]+yt[1]*f+1.5,3)-1.5;const gt=g*j;et.set($,gt+A),et.set([vt,vt],gt+K)}e.WriteBuffer(Z,et),e.Render([Tt,z.objects],!1),e.DestroyCurrentPass(),ht.addSample(1/f),ut.addSample(performance.now()-m),tt.ResolveAndSubmit().then(g=>lt.addSample(g/1e3)),at.textContent=`FPS: ${ht.get().toFixed(1)}`,ft.textContent=`JS: ${ut.get().toFixed(1)}ms`,ct.textContent=`GPU: ${tt.Enabled&&`${lt.get().toFixed(1)}Âµs`||"N/A"}`,requestAnimationFrame(xt),s=a}new ResizeObserver(a=>{for(const f of a){const{inlineSize:m,blockSize:j}=f.contentBoxSize[0];e.SetCanvasSize(m,j)}requestAnimationFrame(xt)}).observe(document.body)})(document.getElementById("lesson"));
