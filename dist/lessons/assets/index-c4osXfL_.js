var A=t=>{throw TypeError(t)};var P=(t,e,o)=>e.has(t)||A("Cannot "+o);var r=(t,e,o)=>(P(t,e,"read from private field"),o?o.call(t):e.get(t)),f=(t,e,o)=>e.has(t)?A("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,o),m=(t,e,o,B)=>(P(t,e,"write to private field"),B?B.call(t,o):e.set(t,o),o),E=(t,e,o)=>(P(t,e,"access private method"),o);import{U as V,a as y}from"./index-BefPI_NB.js";import{m as h}from"./wgpu-matrix.module-CNlPNSC1.js";var n,x,S,g,C,T,U,l,w,z,I;class W{constructor(e,o){f(this,l);f(this,n);f(this,x);f(this,S);f(this,g);f(this,C);f(this,T);f(this,U,new Float32Array(16));m(this,x,o??"Cube"),m(this,n,e),E(this,l,w).call(this),E(this,l,z).call(this),E(this,l,I).call(this)}SetGeometryBuffers(){r(this,n).SetVertexBuffers(r(this,C)),r(this,n).SetIndexBuffer(r(this,g),"uint16")}UpdateTransformBuffer(){r(this,n).WriteBuffer(r(this,T),this.Transform)}get TransformBuffer(){return r(this,T)}get Transform(){return r(this,U)}get Vertices(){return r(this,S)}}n=new WeakMap,x=new WeakMap,S=new WeakMap,g=new WeakMap,C=new WeakMap,T=new WeakMap,U=new WeakMap,l=new WeakSet,w=function(){const e=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);m(this,S,e.length),m(this,g,r(this,n).CreateBuffer({usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,label:`${r(this,x)} Index Buffer`,size:e.byteLength})),r(this,n).WriteBuffer(r(this,g),e)},z=function(){const e=new Float32Array([-1,1,1,1,1,1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,-1,1,-1,1]);m(this,C,r(this,n).CreateBuffer({usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,label:`${r(this,x)} Vertex Buffer`,size:e.byteLength})),r(this,n).WriteBuffer(r(this,C),e)},I=function(){m(this,T,r(this,n).CreateBuffer({size:r(this,U).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`${r(this,x)} Uniform Buffer`}))};var k="struct Transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)normal: vec3f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>transform: Transform;@group(0)@binding(2)var CubeTexture: texture_cube<f32>;@vertex fn vertex(@location(0)position: vec4f)->VertexOutput {var output: VertexOutput;output.position=transform.matrix*position;output.normal=normalize(position.xyz);return output;}@fragment fn fragment(@location(0)normal: vec3f)->@location(0)vec4f {return textureSample(CubeTexture,Sampler,normalize(normal));}";/**
 * @module Cubemaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cubemaps
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cube-maps.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.6
 * @license MIT
 */(async function(t){let e,o;try{e=new(await V.RenderPipeline(t,"Cubemaps",{alphaMode:"premultiplied"}))}catch(a){alert(a)}const B=e.CreateColorAttachment();B.clearValue=[0,0,0,1],e.CreatePassDescriptor(B,void 0,e.CreateDepthAttachment());const D=e.CreateShaderModule(k),_=y.DegreesToRadians(60);e.CreatePipeline({primitive:{cullMode:"back"},fragment:e.CreateFragmentState(D),vertex:e.CreateVertexState(D,void 0,{arrayStride:Float32Array.BYTES_PER_ELEMENT*3,attributes:[e.CreateVertexBufferAttribute("float32x3")]}),depthStencil:{depthWriteEnabled:!0,format:"depth24plus",depthCompare:"less"}});const v=new(await V.Texture()),b=new W(e),s=b.Transform;v.SetRenderer(e),b.SetGeometryBuffers();const O=[{faceColor:"#F00",textColor:"#0FF",text:"+X"},{faceColor:"#FF0",textColor:"#00F",text:"-X"},{faceColor:"#0F0",textColor:"#F0F",text:"+Y"},{faceColor:"#0FF",textColor:"#F00",text:"-Y"},{faceColor:"#00F",textColor:"#FF0",text:"+Z"},{faceColor:"#F0F",textColor:"#0F0",text:"-Z"}].map(a=>L(a)),Y=v.CreateSampler({filter:"linear"}),M=X(O);e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([Y,{buffer:b.TransformBuffer},M.createView({dimension:"cube"})])));const N=h.lookAt([0,1,5],[0,0,0],[0,1,0]),d={rotation:[y.DegreesToRadians(20),y.DegreesToRadians(25),y.DegreesToRadians(0)]},R={converters:GUI.converters.radToDeg,min:-360,max:360,step:1},F=new GUI;F.onChange(G),F.add(d.rotation,"0",R).name("rotation.x"),F.add(d.rotation,"1",R).name("rotation.y"),F.add(d.rotation,"2",R).name("rotation.z");function L({faceColor:a,textColor:c,text:p}){const u=document.createElement("canvas"),i=u.getContext("2d");return u.width=u.height=128,i.fillStyle=a,i.fillRect(0,0,128,128),i.textAlign="center",i.fillStyle=c,i.textBaseline="middle",i.font="90px sans-serif",i.fillText(p,64,64),u}function X(a){const c=a[0],p=v.CreateTextureFromSource(c,{size:[c.width,c.height,a.length],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm"});return a.forEach((u,i)=>v.CopyImageToTexture(u,{generateMipmaps:i===a.length-1,destinationOrigin:[0,0,i],texture:p})),p}function G(){h.perspective(_,o,.1,10,s),h.multiply(s,N,s),h.rotateX(s,d.rotation[0],s),h.rotateY(s,d.rotation[1],s),h.rotateZ(s,d.rotation[2],s),b.UpdateTransformBuffer(),e.Render(b.Vertices)}new ResizeObserver(a=>{for(const c of a){const{inlineSize:p,blockSize:u}=c.contentBoxSize[0];e.SetCanvasSize(p,u)}o=e.AspectRatio,G()}).observe(t)})(document.getElementById("lesson"));
