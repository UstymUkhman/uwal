var w=r=>{throw TypeError(r)};var A=(r,e,o)=>e.has(r)||w("Cannot "+o);var t=(r,e,o)=>(A(r,e,"read from private field"),o?o.call(r):e.get(r)),u=(r,e,o)=>e.has(r)?w("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(r):e.set(r,o),s=(r,e,o,B)=>(A(r,e,"write to private field"),B?B.call(r,o):e.set(r,o),o),U=(r,e,o)=>(A(r,e,"access private method"),o);import{U as G,a as E}from"./index-BRbAh6QZ.js";import{m as T}from"./wgpu-matrix.module-0Oa3LLlt.js";var p,v,n,c,m,d,S,x,I,P,z;class X{constructor(e,o){u(this,x);u(this,p);u(this,v);u(this,n);u(this,c);u(this,m);u(this,d);u(this,S,new Float32Array(16));s(this,p,o??"Cube"),s(this,n,e),U(this,x,I).call(this),U(this,x,P).call(this),U(this,x,z).call(this)}SetGeometryBuffers(){t(this,n).SetVertexBuffers(t(this,m)),t(this,n).SetIndexBuffer(t(this,c),"uint16")}UpdateTransformBuffer(){t(this,n).WriteBuffer(t(this,d),this.Transform)}get TransformBuffer(){return t(this,d)}get Transform(){return t(this,S)}get Vertices(){return t(this,v)}Destroy(){s(this,c,t(this,c).destroy()),s(this,m,t(this,m).destroy()),s(this,d,t(this,d).destroy())}}p=new WeakMap,v=new WeakMap,n=new WeakMap,c=new WeakMap,m=new WeakMap,d=new WeakMap,S=new WeakMap,x=new WeakSet,I=function(){const e=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);s(this,c,t(this,n).CreateIndexBuffer(e,{label:`${t(this,p)} Index Buffer`})),t(this,n).WriteBuffer(t(this,c),e),s(this,v,e.length)},P=function(){const e=new Float32Array([-1,1,1,1,1,1,-1,1,-1,1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,-1,1,-1,1]);s(this,m,t(this,n).CreateVertexBuffer(e,{label:`${t(this,p)} Vertex Buffer`})),t(this,n).WriteBuffer(t(this,m),e)},z=function(){s(this,d,t(this,n).CreateBuffer({size:t(this,S).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:`${t(this,p)} Uniform Buffer`}))};var k="struct Transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)normal: vec3f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>transform: Transform;@group(0)@binding(2)var CubeTexture: texture_cube<f32>;@vertex fn vertex(@location(0)position: vec4f)->VertexOutput {var output: VertexOutput;output.position=transform.matrix*position;output.normal=normalize(position.xyz);return output;}@fragment fn fragment(@location(0)normal: vec3f)->@location(0)vec4f {return textureSample(CubeTexture,Sampler,normalize(normal));}";/**
 * @module Cubemaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cubemaps
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cube-maps.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.6
 * @license MIT
 */(async function(r){let e,o;try{e=new(await G.RenderPipeline(r,"Cubemaps",{alphaMode:"premultiplied"}))}catch(a){alert(a)}const B=e.CreateColorAttachment();B.clearValue=[0,0,0,1],e.CreatePassDescriptor(B,void 0,e.CreateDepthAttachment());const D=e.CreateShaderModule(k),_=E.DegreesToRadians(60);e.CreatePipeline({primitive:{cullMode:"back"},fragment:e.CreateFragmentState(D),vertex:e.CreateVertexState(D,void 0,{arrayStride:Float32Array.BYTES_PER_ELEMENT*3,attributes:[e.CreateVertexBufferAttribute("float32x3")]}),depthStencil:{depthWriteEnabled:!0,format:"depth24plus",depthCompare:"less"}});const F=new(await G.Texture()),b=new X(e),f=b.Transform;F.SetRenderer(e),b.SetGeometryBuffers();const M=[{faceColor:"#F00",textColor:"#0FF",text:"+X"},{faceColor:"#FF0",textColor:"#00F",text:"-X"},{faceColor:"#0F0",textColor:"#F0F",text:"+Y"},{faceColor:"#0FF",textColor:"#F00",text:"-Y"},{faceColor:"#00F",textColor:"#FF0",text:"+Z"},{faceColor:"#F0F",textColor:"#0F0",text:"-Z"}].map(a=>W(a)),O=F.CreateSampler({filter:"linear"}),N=L(M);e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([O,{buffer:b.TransformBuffer},N.createView({dimension:"cube"})])));const Y=T.lookAt([0,1,5],[0,0,0],[0,1,0]),C={rotation:[E.DegreesToRadians(20),E.DegreesToRadians(25),E.DegreesToRadians(0)]},R={converters:GUI.converters.radToDeg,min:-360,max:360,step:1},y=new GUI;y.onChange(V),y.add(C.rotation,"0",R).name("rotation.x"),y.add(C.rotation,"1",R).name("rotation.y"),y.add(C.rotation,"2",R).name("rotation.z");function W({faceColor:a,textColor:h,text:g}){const l=document.createElement("canvas"),i=l.getContext("2d");return l.width=l.height=128,i.fillStyle=a,i.fillRect(0,0,128,128),i.textAlign="center",i.fillStyle=h,i.textBaseline="middle",i.font="90px sans-serif",i.fillText(g,64,64),l}function L(a){const h=a[0],g=F.CreateTextureFromSource(h,{size:[h.width,h.height,a.length],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm"});return a.forEach((l,i)=>F.CopyImageToTexture(l,{generateMipmaps:i===a.length-1,destinationOrigin:[0,0,i],texture:g})),g}function V(){T.perspective(_,o,.1,10,f),T.multiply(f,Y,f),T.rotateX(f,C.rotation[0],f),T.rotateY(f,C.rotation[1],f),T.rotateZ(f,C.rotation[2],f),b.UpdateTransformBuffer(),e.Render(b.Vertices)}new ResizeObserver(a=>{for(const h of a){const{inlineSize:g,blockSize:l}=h.contentBoxSize[0];e.SetCanvasSize(g,l)}o=e.AspectRatio,V()}).observe(r)})(document.getElementById("lesson"));
