var St=o=>{throw TypeError(o)};var st=(o,e,s)=>e.has(o)||St("Cannot "+s);var t=(o,e,s)=>(st(o,e,"read from private field"),s?s.call(o):e.get(o)),i=(o,e,s)=>e.has(o)?St("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(o):e.set(o,s),r=(o,e,s,c)=>(st(o,e,"write to private field"),c?c.call(o,s):e.set(o,s),s),L=(o,e,s)=>(st(o,e,"access private method"),s);import{b as Bt,N as Gt,U as Ct,C as it,a as rt}from"./index-DFPbJ56q.js";import{a as m,v as bt}from"./wgpu-matrix.module-BIbWF_bz.js";var Mt="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn shapeVertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}",u,j,S,Y,k,J,Q,w,B,W,n,P,h,E,V,C,U,p,_,F,T,I,R,x,At,wt,Et,nt;class Ot{constructor(e){i(this,x);i(this,u);i(this,j,0);i(this,S,!1);i(this,Y,m.create());i(this,k,m.create());i(this,J,m.create());i(this,Q,m.create());i(this,w);i(this,B);i(this,W);i(this,n);i(this,P);i(this,h);i(this,E);i(this,V);i(this,C);i(this,U,new Float32Array([1,1]));i(this,p,new Float32Array([0,0]));i(this,_,new Float32Array([0,0]));i(this,F,new Float32Array([0,0]));i(this,T,[void 0]);i(this,I);i(this,R,Bt({min:bt.create(),max:bt.create()}));r(this,w,e.label??"Shape"),r(this,u,e.radius??0),r(this,n,e.renderer),r(this,B,e.segments);const{startAngle:s,endAngle:c,innerRadius:l}=e;L(this,x,At).call(this,s,c,l),L(this,x,wt).call(this),L(this,x,Et).call(this),this.Scale=t(this,U),this.Origin=t(this,p),this.Rotation=t(this,j),this.Position=t(this,F)}Update(){return t(this,n).SetVertexBuffers(t(this,V)),t(this,n).SetIndexBuffer(t(this,E)),t(this,n).SetBindGroups(t(this,T)),L(this,x,nt).call(this)}Render(e=!0){t(this,n).SavePipelineState(),t(this,n).Render(t(this.Update(),W),e),t(this,n).RestorePipelineState()}AddBindGroups(e){t(this,T).push(...Array.isArray(e)&&e||[e])}set Color(e){t(this,P).set(Array.isArray(e)||ArrayBuffer.isView(e)?e:e.rgba),t(this,n).WriteBuffer(t(this,C),t(this,P),t(this,I).color)}get Color(){return t(this,P)}set Position(e){t(this,F).set(e),m.translation(t(this,F),t(this,Q)),r(this,S,!0)}get Position(){return t(this,F)}set Rotation(e){m.rotation(r(this,j,e),t(this,J)),r(this,S,!0)}get Rotation(){return t(this,j)}set Scale(e){t(this,U).set(e),m.scaling(t(this,U),t(this,k)),r(this,S,!0)}get Scale(){return t(this,U)}set Origin(e){t(this,p)[0]=e[0],t(this,p)[1]=e[1],t(this,p)[0]*=-t(this,u),t(this,p)[1]*=-t(this,u),m.translation(t(this,p),t(this,Y)),t(this,p)[0]=e[0]||0,t(this,p)[1]=e[1]||0,r(this,S,!0)}get Origin(){return t(this,p)}get Center(){return t(L(this,x,nt).call(this),_)}get Vertices(){return t(this,W)}get Transform(){return t(this,h)}get BoundingBox(){return t(this,R)}Destroy(){t(this,T).splice(0),r(this,E,t(this,E).destroy()),r(this,V,t(this,V).destroy()),r(this,C,t(this,C).destroy())}}u=new WeakMap,j=new WeakMap,S=new WeakMap,Y=new WeakMap,k=new WeakMap,J=new WeakMap,Q=new WeakMap,w=new WeakMap,B=new WeakMap,W=new WeakMap,n=new WeakMap,P=new WeakMap,h=new WeakMap,E=new WeakMap,V=new WeakMap,C=new WeakMap,U=new WeakMap,p=new WeakMap,_=new WeakMap,F=new WeakMap,T=new WeakMap,I=new WeakMap,R=new WeakMap,x=new WeakSet,At=function(e=0,s=Gt.TAU,c=0){const l=s-e,b=new Float32Array((t(this,B)+1)*2*3);for(let M=0,D=0;D<=t(this,B);++D){const N=e+D*l/t(this,B),v=Math.cos(N),O=Math.sin(N);b[M++]=v*t(this,u),b[M++]=O*t(this,u),b[M++]=v*c,b[M++]=O*c}r(this,V,t(this,n).CreateVertexBuffer(b,{label:`${t(this,w)} Vertex Buffer`})),t(this,n).WriteBuffer(t(this,V),b)},wt=function(){const e=new Uint32Array(r(this,W,t(this,B)*6));for(let s=0,c=0;c<t(this,B);++c){const l=c*2;e[s++]=l+1,e[s++]=l+3,e[s++]=l+2,e[s++]=l+2,e[s++]=l+0,e[s++]=l+1}r(this,E,t(this,n).CreateIndexBuffer(e,{label:`${t(this,w)} Index Buffer`})),t(this,n).WriteBuffer(t(this,E),e)},Et=function(){const{buffer:e,shape:{color:s,matrix:c}}=t(this,n).CreateUniformBuffer("shape",{label:`${t(this,w)} Uniform Buffer`});r(this,C,e),r(this,h,c),r(this,P,s),t(this,T)[0]=t(this,n).CreateBindGroup(t(this,n).CreateBindGroupEntries([{buffer:t(this,n).ResolutionBuffer},{buffer:t(this,C)}]),0,`${t(this,w)} Bind Group`),r(this,I,Bt({matrix:s.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT}))},nt=function(){if(t(this,S)){m.multiply(t(this,Q),t(this,J),t(this,h)),m.multiply(t(this,h),t(this,k),t(this,h)),m.multiply(t(this,h),t(this,Y),t(this,h)),t(this,n).WriteBuffer(t(this,C),t(this,h),t(this,I).matrix);const e=t(this,_)[0]=t(this,h)[8],s=t(this,_)[1]=t(this,h)[9];t(this,R).min[0]=e-t(this,u),t(this,R).min[1]=s-t(this,u),t(this,R).max[0]=e+t(this,u),t(this,R).max[1]=s+t(this,u),r(this,S,!1)}return this};var zt="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;let clipSpace=GetVertexClipSpace(position*scale).xy;output.position=vec4f(clipSpace+(offset+0.9)/1.8*vec2f(2,-2),0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}",H,K,G,$;class ot{constructor(e=30){i(this,H,0);i(this,K,0);i(this,G,0);i(this,$,[]);r(this,H,e)}addSample(e){const s=t(this,$)[t(this,G)]||0;r(this,K,t(this,K)+(e-s)),t(this,$)[t(this,G)]=e,r(this,G,(t(this,G)+1)%t(this,H))}get(){return t(this,K)/t(this,$).length}}H=new WeakMap,K=new WeakMap,G=new WeakMap,$=new WeakMap;/**
 * @module Timing Performance
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Timing Performance
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(o){let e,s=0;try{await Ct.SetRequiredFeatures("timestamp-query"),e=new(await Ct.RenderPipeline(o,"Timing Performance"))}catch(a){alert(a)}const c=24,l=0,b=0,M=2,D=new GUI,N=[],v=1e4,O={objects:100};D.add(O,"objects",0,v,1);const y=document.createElement("pre"),at=document.createElement("span"),ct=document.createElement("span"),ft=document.createElement("span");y.style.backgroundColor="rgb(0 0 0 / 0.8)",y.style.position="absolute",y.style.padding="0.5em",y.style.display="grid",y.style.color="white",y.style.margin="0px",y.style.left="0px",y.style.top="0px",y.append(at,ct,ft),document.body.appendChild(y);const ht=new ot,lt=new ot,ut=new ot,pt=e.CreateShaderModule([Mt,zt]),dt=e.CreateColorAttachment();dt.clearValue=new it(5000268).rgba;const tt=new rt.GPUTiming(e),Vt=await tt.QuerySet;e.CreatePassDescriptor(dt,void 0,void 0,void 0,e.CreateTimestampWrites(Vt,0,1));const Rt=e.CreateVertexBufferLayout("position"),{buffer:X,layout:Pt}=e.CreateVertexBuffer([{name:"color",format:"unorm8x4"}],v,"instance"),{buffer:Z,layout:Ut}=e.CreateVertexBuffer(["offset","scale"],v,"instance"),{buffer:mt,layout:Ft}=e.CreateVertexBuffer({name:"vertexColor",format:"unorm8x4"},v);e.CreatePipeline({fragment:e.CreateFragmentState(pt),vertex:e.CreateVertexState(pt,void 0,[Rt,Pt,Ut,Ft])});const Tt=new Ot({renderer:e,innerRadius:120,radius:240,segments:c}).Update().Vertices,et=new Float32Array(Z.size/Float32Array.BYTES_PER_ELEMENT);e.AddVertexBuffers([X,Z,mt]);{const a=X.size/v,f=new Uint8Array(X.size);for(let d=0;d<v;++d)f.set([A(255),A(255),A(255),255],a*d+l),N.push({scale:A(.2,.5),offset:[A(-.9,.9),A(-.9,.9)],velocity:[A(-.1,.1),A(-.1,.1)]});e.WriteBuffer(X,f)}{const a=new it(1644825),f=new it(16777215),d=new Uint8Array((c+1)*8);for(let z=0,g=0;z<=c;z++,g+=8)d.set(a.RGBA,g),d.set(f.RGBA,g+4);e.WriteBuffer(mt,d)}function A(a,f){return a===void 0?(a=0,f=1):f===void 0&&(f=a,a=0),Math.random()*(f-a)+a}async function xt(a){a*=.001;const f=a-s,d=performance.now(),z=Z.size/v/4;for(let g=0;g<O.objects;g++){const{scale:vt,offset:q,velocity:yt}=N[g];q[0]=rt.EuclideanModulo(q[0]+yt[0]*f+1.5,3)-1.5,q[1]=rt.EuclideanModulo(q[1]+yt[1]*f+1.5,3)-1.5;const gt=g*z;et.set(q,gt+b),et.set([vt,vt],gt+M)}e.WriteBuffer(Z,et),e.Render([Tt,O.objects],!1),e.DestroyCurrentPass(),ht.addSample(1/f),ut.addSample(performance.now()-d),tt.ResolveAndSubmit().then(g=>lt.addSample(g/1e3)),at.textContent=`FPS: ${ht.get().toFixed(1)}`,ft.textContent=`JS: ${ut.get().toFixed(1)}ms`,ct.textContent=`GPU: ${tt.Enabled&&`${lt.get().toFixed(1)}Âµs`||"N/A"}`,requestAnimationFrame(xt),s=a}new ResizeObserver(a=>{for(const f of a){const{inlineSize:d,blockSize:z}=f.contentBoxSize[0];e.SetCanvasSize(d,z)}requestAnimationFrame(xt)}).observe(document.body)})(document.getElementById("lesson"));
