import{m as i,v as p,G as S,C as P,a as b,b as j,c as D,T as I,E as T,S as A,M,D as G,d as O,e as V}from"./index-DFT86U3m.js";class R{Children=[];Label;#e=null;TransformationOrder="TRS";ProjectionMatrix=i.identity();#t=i.identity();#r=i.identity();#a=p.create();#s=p.set(1,1);#i=0;constructor(t,e=null){this.Label=t,this.Parent=e}Find(t){let e=null;return this.Traverse(r=>r.Label===t&&(e=r)||!1),e}Add(t){t=S(t),t.forEach(e=>e.Parent=this)}Remove(t){t=S(t),t.forEach(e=>e.Parent=null)}Traverse(t){if(!t(this))for(let e=0,r=this.Children.length;e<r;++e)this.Children[e].Traverse(t)}ResetLocalMatrix(){i.identity(this.#t)}UpdateWorldMatrix(){this.UpdateLocalMatrix(),this.#e?i.multiply(this.#e.WorldMatrix,this.#t,this.#r):i.copy(this.#t,this.#r),this.Children.forEach(t=>t.UpdateWorldMatrix())}UpdateLocalMatrix(){i.identity(this.#t);const t=this.TransformationOrder.split("");for(let e=0,r=t.length;e<r;e++)switch(t[e]){case"T":i.translate(this.#t,this.#a,this.#t);break;case"R":i.rotate(this.#t,this.#i,this.#t);break;case"S":i.scale(this.#t,this.#s,this.#t);break}}UpdateProjectionMatrix(t){const e=this.#e&&this.#r||this.#t;return i.multiply(t,e,this.ProjectionMatrix)}ResetProjectionMatrix(){i.identity(this.ProjectionMatrix)}Rotate(t){i.rotate(this.#t,t,this.#t)}Scale(t){i.scale(this.#t,t,this.#t)}set Transform(t){i.identity(this.#t);const[e,r,s]=t,a=this.TransformationOrder.split("");for(let h=0,c=a.length;h<c;h++)switch(a[h]){case"T":e&&(this.Position=e);break;case"R":r!==void 0&&(this.Rotation=r);break;case"S":s&&(this.Scaling=s);break}}set Position(t){p.copy(t,this.#a),i.translate(this.#t,t,this.#t)}get Position(){return this.#a}set Rotation(t){this.#i=t,i.rotate(this.#t,t,this.#t)}get Rotation(){return this.#i}set Scaling(t){p.copy(t,this.#s),i.scale(this.#t,t,this.#t)}get Scaling(){return this.#s}get LocalMatrix(){return this.#t}get WorldMatrix(){return this.#r}set Parent(t){if(this.#e){const e=this.#e.Children.indexOf(this);0<=e&&this.#e.Children.splice(e,1)}t&&t.Children.push(this),this.#e=t}get Parent(){return this.#e}}let U=class{#e;#t;#r;Transparent=!1;#a=crypto.randomUUID();#s;#i;#n=new P(0,0);constructor(t=16777215,e="Shape"){this.Color=t,this.#e=e}CreateColorBuffer(t,e=this.#e){const{color:r,buffer:s}=t.CreateUniformBuffer("color",{label:`${e} Color Buffer`});this.#t=r,this.#r=t,this.#i=s,this.#t.set(this.#s),t.WriteBuffer(s,r)}SetBlendConstant(t){if(!t?.BlendConstant||!this.#n.Equals(t.BlendConstant))return this.#r.BlendConstant=this.#n}set BlendConstant(t){typeof t=="number"&&this.#n.Set(t)||(this.#n.rgba=b(t))}get BlendConstant(){return this.#n}get ColorBuffer(){return this.#i}set Color(t){this.#s=typeof t=="number"&&j(t)||b(t),this.#t?.fill(1).set(this.#s),this.#r?.WriteBuffer(this.#i,this.#t)}get Color(){return this.#s}get ID(){return this.#a}Destroy(){this.#r=void 0,this.#i?.destroy(),this.#i=void 0}},L=class extends R{#e;Visible=!0;#t;#r;#a;#s=p.set(0,0);#i=p.set(0,0);#n=D({min:p.create(),max:p.create()});#o=[];constructor(t,e,r="Shape",s=null){super(r,s),this.#e=t,this.#r=e===void 0&&new U||e}SetRenderPipeline(t,e){this.#t=t,this.#e.CreateBuffers(t),this.#r?.CreateColorBuffer(t),this.#h(e)}#h(t,e){const{projection:r,buffer:s}=this.#t.CreateUniformBuffer("shapeModelViewProjection",{label:`${this.Label} Projection Buffer`,...e});this.ProjectionMatrix=i.identity(r),this.#a=s,t=S(t),this.#o=this.#t.SetBindGroupFromResources([s,this.#r?.ColorBuffer,...t].filter(Boolean),0,0,`${this.Label} Bind Group`)}UpdateProjectionMatrix(t){const e=super.UpdateProjectionMatrix(t);return this.#t.WriteBuffer(this.#a,e),e}UpdateLocalMatrix(){super.UpdateLocalMatrix();const t=this.LocalMatrix,{Radius:e}=this.#e;this.#n.min[0]=t[8]-e,this.#n.min[1]=t[9]-e,this.#n.max[0]=t[8]+e,this.#n.max[1]=t[9]+e,i.translate(t,this.#s,t),this.#i[0]=this.#s[0]+this.#n.max[0],this.#i[1]=this.#s[1]+this.#n.max[1]}SetBindGroups(){!this.#t&&I(T.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Shape.SetRenderPipeline` method before setting its data."),this.#t.BindGroups=this.#o}get ProjectionBuffer(){return this.#a}set Origin(t){this.#s[0]=-t[0],this.#s[1]=-t[1];const e=this.LocalMatrix;i.translate(e,t,e)}get Origin(){return this.#s}get Center(){return this.#i}get BoundingBox(){return this.#n}get Geometry(){return this.#e}get Material(){return this.#r}get Pipeline(){return this.#t}Destroy(){this.#e.Destroy(),this.#r?.Destroy(),this.#t=void 0,this.#o.splice(0),this.#a?.destroy(),this.#a=void 0}};const v=D({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});class E{#e;#t;DrawParams=[];IndexFormat;#r;#a=crypto.randomUUID();#s;#i;VertexBuffers;IndexBuffer;constructor(t={segments:"SQUARE",radius:0}){const e=t.segments,r=typeof e=="number"&&e;this.#e=t.radius??0,this.#t=r||v[e||"SQUARE"],this.#r={label:"Shape",...t},this.IndexFormat=t.indexFormat??"uint16"}GetPositionBufferLayout(t,e="position",r="vertex",s="vertex"){return t.CreateVertexBufferLayout(e,r,s)}SetDrawParams(t,e,r,s,a){return A(this.DrawParams,...arguments)}#n(t,e=this.#r.label){let r=this.#i;if(!r){r=new Float32Array((this.#t+1)*2*3);const{endAngle:a=M.TAU,startAngle:h=0,innerRadius:c=0}=this.#r,l=a-h;for(let d=0,m=0,f=this.#t;m<=f;++m){const B=h+m*l/f,u=Math.cos(B),g=Math.sin(B);r[d++]=u*this.#e,r[d++]=g*this.#e,r[d++]=u*c,r[d++]=g*c}}const s=t.CreateVertexBuffer(r,{label:`${e} Vertex Buffer`});this.VertexBuffers=t.SetVertexBuffers(s),t.WriteBuffer(s,r)}#o(t,e=this.#r.label){let r=this.#s;if(!r){r=new Uint16Array(this.#t*6);for(let a=0,h=0,c=this.#t;h<c;++h){const l=h*2;r[a++]=l+1,r[a++]=l+3,r[a++]=l+2,r[a++]=l+2,r[a++]=l+0,r[a++]=l+1}}const s=t.CreateIndexBuffer(r,{label:`${e} Index Buffer`});t.SetDrawParams.apply(t,this.SetDrawParams(r.length)),this.IndexBuffer=t.SetIndexBuffer(s,this.IndexFormat),t.WriteBuffer(s,r)}CreateBuffers(t,e=this.#r.label){this.#n(t,e),this.#o(t,e)}set VertexData(t){this.#i=t}set IndexData(t){this.#s=t}get Vertices(){return this.DrawParams[0]}get Radius(){return this.#e}get ID(){return this.#a}Destroy(){this.IndexBuffer?.buffer.destroy(),this.IndexBuffer=void 0,this.#i=void 0,this.#s=void 0,this.VertexBuffers&&(this.VertexBuffers[0]?.buffer.destroy(),this.VertexBuffers.splice(0),this.VertexBuffers=void 0)}}class N extends R{#e=0;#t=innerWidth;#r=innerHeight;#a=0;#s=new Float32Array(4);constructor(t=innerWidth,e=innerHeight){super("Camera2D"),this.Size=typeof t!="number"&&t.CanvasSize||[t,e]}#i(t=!1){}UpdateProjectionMatrix(){const t=this.#e,e=this.#t,r=this.#r,s=this.#a;return i.set(2/e,0,0,0,-2/r,0,s/e*2-1,t/r*-2+1,1,this.ProjectionMatrix),this.#i(),this.ProjectionMatrix}set Size([t,e]){this.#t=t,this.#r=e,this.UpdateProjectionMatrix()}set Top(t){this.#e=t,this.UpdateProjectionMatrix()}get Top(){return this.#e}set Right(t){this.#t=t,this.UpdateProjectionMatrix()}get Right(){return this.#t}set Bottom(t){this.#r=t,this.UpdateProjectionMatrix()}get Bottom(){return this.#r}set Left(t){this.#a=t,this.UpdateProjectionMatrix()}get Left(){return this.#a}get Frustum(){return this.#s}}function F(){const o=new Float32Array([0,0,30,0,0,150,30,150,30,0,100,0,30,30,100,30,30,60,70,60,30,90,70,90]),t=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11]);return{vertexData:o,indexData:t}}/**
 * @module Matrix Math
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Math
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-math.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */(async function(o){let t;o.style.backgroundPosition="-1.5px -1.5px, -1.5px -1.5px, -1px -1px, -1px -1px",o.style.backgroundSize="100px 100px, 100px 100px, 10px 10px, 10px 10px",o.style.backgroundColor="#000",o.style.backgroundImage=`
        linear-gradient(       #666 1.5px, transparent 1.5px),
        linear-gradient(90deg, #666 1.5px, transparent 1.5px),
        linear-gradient(       #333 1px,   transparent 1px),
        linear-gradient(90deg, #333 1px,   transparent 1px)
    `;try{t=new(await G.Renderer(o,"Matrix Math",{alphaMode:"premultiplied"}))}catch(n){alert(n)}const e=new O,r=new N,s=new GUI().onChange(g),a=new t.Pipeline,{vertexData:h,indexData:c}=F(),l=a.CreateShaderModule(V),d=new E({radius:75,indexFormat:"uint32"}),m={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},f={translation:[150,100],rotation:M.DegreesToRadians(30),scale:[1,1],objects:1};s.add(f.translation,"0",0,1e3).name("translation.x"),s.add(f.translation,"1",0,1e3).name("translation.y"),s.add(f,"rotation",m),s.add(f.scale,"0",-5,5).name("scale.x"),s.add(f.scale,"1",-5,5).name("scale.y"),s.add(f,"objects",1,5,1).name("objects"),await t.AddPipeline(a,{fragment:a.CreateFragmentState(l),vertex:a.CreateVertexState(l,d.GetPositionBufferLayout(a))});const B=new P;d.IndexData=c,d.VertexData=h;const u=Array.from({length:5}).map(()=>{const n=new L(d,new U(B.Random()));return n.SetRenderPipeline(a),n.Origin=[50,75],n});for(let n=-1;n<4;++n)(n<0&&e||u[n]).Add(u[n+1]);function g(n,x=0){for(;x<f.objects;++x){u[x].Visible=!0;const{translation:C,rotation:y,scale:w}=f;u[x].Transform=[C,y,w]}u[x]&&(u[x].Visible=!1),t.Render(e)}new ResizeObserver(n=>{for(const x of n){const{inlineSize:C,blockSize:y}=x.contentBoxSize[0];t.SetCanvasSize(C,y),r.Size=t.CanvasSize,e.AddCamera(r)}g()}).observe(document.body)})(document.getElementById("lesson"));
