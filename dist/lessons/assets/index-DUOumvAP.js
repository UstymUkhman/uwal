var he=Object.defineProperty;var Ee=(o,t,e)=>t in o?he(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var v=(o,t,e)=>(Ee(o,typeof t!="symbol"?t+"":t,e),e),Y=(o,t,e)=>{if(!t.has(o))throw TypeError("Cannot "+e)};var a=(o,t,e)=>(Y(o,t,"read from private field"),e?e.call(o):t.get(o)),u=(o,t,e)=>{if(t.has(o))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(o):t.set(o,e)},E=(o,t,e,r)=>(Y(o,t,"write to private field"),r?r.call(o,e):t.set(o,e),e);var O=(o,t,e)=>(Y(o,t,"access private method"),e);function C(o){for(let t in o)o[t]={value:o[t]};return Object.freeze(Object.create(null,o))}const ce={CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND",VERTEX_STATE_NOT_FOUND:"VERTEX_STATE_NOT_FOUND",PIPELINE_NOT_FOUND:"PIPELINE_NOT_FOUND"},Te={CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder.",VERTEX_STATE_NOT_FOUND:"Failed to get a GPUVertexState.",PIPELINE_NOT_FOUND:"Failed to get a GPU"},le={CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7,VERTEX_STATE_NOT_FOUND:8,PIPELINE_NOT_FOUND:9},Oe={TEXTURE_SIZE_NOT_FOUND:"TEXTURE_SIZE_NOT_FOUND",TEXTURE_NOT_FOUND:"TEXTURE_NOT_FOUND"},De={TEXTURE_SIZE_NOT_FOUND:"WriteTexture `options` is required to have a `size` array or a `width` value.",TEXTURE_NOT_FOUND:"CopyImageToTexture `options` is required to have a `texture` value or `create` entry."},pe={REQUIRED_SEGMENTS:"REQUIRED_SEGMENTS"},Ne={REQUIRED_SEGMENTS:"Shape `segments` is required to be an integer value."};C({DEVICE_LOST:"Device::Lost"});const T=C({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",...ce,...Oe,...pe}),te=C({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",...Te,...De,...Ne}),de=C({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,...le});function Ce(o,t){console.warn(te[o]+(t??""))}function p(o,t){throw new Error(te[o]+(t??""),{cause:de[o]})}var G,S,P,A;class re{constructor(t,e,r){u(this,G,void 0);u(this,S,void 0);u(this,P,void 0);v(this,"Device");v(this,"BindGroups",[]);u(this,A,void 0);v(this,"Pipeline");v(this,"Descriptor");!t&&p(T.DEVICE_NOT_REQUESTED),E(this,G,r),this.Device=t,E(this,S,e),E(this,P,this.CreatePipelineLabel("Command Encoder"))}CreatePipelineLabel(t){return a(this,S)&&t&&`${a(this,S)} ${t}`||""}CreatePipelineLayout(t,e){const r=Array.isArray(t)&&t||[t];return e??(e=this.CreatePipelineLabel(`${a(this,G)} Pipeline Layout`)),this.Device.createPipelineLayout({label:e,bindGroupLayouts:r})}CreateShaderModule(t,e,r,i){e??(e=this.CreatePipelineLabel("Shader Module"));const s=Array.isArray(t)&&t.join(`

`)||t;return this.Device.createShaderModule({label:e,code:s,sourceMap:r,compilationHints:i})}CreateBuffer(t){const e=t.label??this.CreatePipelineLabel("Buffer");return this.Device.createBuffer({...t,label:e})}WriteBuffer(t,e,r=0,i,s){this.Device.queue.writeBuffer(t,r,e,i,s)}CopyBufferToBuffer(t,e,r,i=0,s=0){this.GetCommandEncoder(!0).copyBufferToBuffer(t,i,e,s,r)}CreateBindGroupLayout(t,e){e??(e=this.CreatePipelineLabel("Bind Group Layout")),t=Array.isArray(t)&&t.map((i,s)=>({...i,binding:i.binding??s}))||[{...t,binding:t.binding??0}];const r=t;return this.Device.createBindGroupLayout({entries:r,label:e})}CreateBindGroupEntries(t,e=0){return Array.isArray(t)&&t.map((r,i)=>({binding:(e==null?void 0:e[i])??i,resource:r}))||[{binding:e,resource:t}]}CreateBindGroup(t,e=0,r){return r??(r=this.CreatePipelineLabel("Bind Group")),typeof e=="number"&&(e=this.Pipeline?this.Pipeline.getBindGroupLayout(e):p(T.PIPELINE_NOT_FOUND,`${a(this,G)}Pipeline.`)),this.Device.createBindGroup({entries:t,label:r,layout:e})}SetBindGroups(t,e){Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups=Array.isArray(t)&&t.map((r,i)=>({bindGroup:r,dynamicOffsets:e[i],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}]}AddBindGroups(t,e){Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups.push(...Array.isArray(t)&&t.map((r,i)=>({bindGroup:r,dynamicOffsets:e[i],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}])}SetActiveBindGroups(t){t=Array.isArray(t)&&t||[t];for(let e=this.BindGroups.length;e--;)this.BindGroups[e].active=t.includes(e)}ClearBindGroups(){this.BindGroups.splice(0)}CreateCommandEncoder(){return E(this,A,this.Device.createCommandEncoder({label:a(this,P)}))}SetCommandEncoder(t){E(this,A,t)}GetCommandEncoder(t=!1){if(!a(this,A)){if(t){const e=` ${a(this,P)&&`Label: "${a(this,P)}". `}`;Ce(T.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one.")}return this.CreateCommandEncoder()}return a(this,A)}DestroyCommandEncoder(){E(this,A,void 0)}SubmitCommandBuffer(){this.Device.queue.submit([a(this,A).finish()])}set CommandEncoderLabel(t){E(this,P,t)}get ProgramName(){return a(this,S)}GetDescriptor(){return this.Descriptor}GetPipeline(){return this.Pipeline}}G=new WeakMap,S=new WeakMap,P=new WeakMap,A=new WeakMap;var X,U,f,D,g,L,F,I,d,c,$,J;class Ae extends re{constructor(e,r,i,s){super(e,r,"Render");u(this,$);u(this,X,void 0);u(this,U,!1);u(this,f,new Float32Array(2));u(this,D,void 0);u(this,g,void 0);u(this,L,void 0);u(this,F,[]);u(this,I,void 0);u(this,d,void 0);u(this,c,void 0);!i&&p(T.CANVAS_NOT_FOUND);const h=i.getContext("webgpu");!h&&p(T.CONTEXT_NOT_FOUND),E(this,I,s.format??navigator.gpu.getPreferredCanvasFormat()),h.configure({device:e,...s,format:a(this,I)}),E(this,L,this.CreateBuffer({size:a(this,f).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Render Pipeline Resolution Buffer"})),E(this,D,i),E(this,g,h),O(this,$,J).call(this)}SetCanvasSize(e,r){!this.Device&&p(T.DEVICE_NOT_FOUND),!a(this,D)&&p(T.CANVAS_NOT_FOUND);const{maxTextureDimension2D:i}=this.Device.limits;e=Math.max(1,Math.min(e,i)),r=Math.max(1,Math.min(r,i)),(a(this,D).width!==e||a(this,D).height!==r)&&(a(this,D).width=e,a(this,D).height=r,O(this,$,J).call(this))}CreateColorAttachment(e,r="clear",i="store",s,h,l){return{view:e,loadOp:r,storeOp:i,clearValue:s,resolveTarget:h,depthSlice:l}}CreatePassDescriptor(e,r,i,s,h,l){const N=Array.isArray(e)&&e||[e];return E(this,U,!N.some(({view:R})=>!!R)),r??(r=this.CreatePipelineLabel("Render Pass")),this.Descriptor={colorAttachments:N,depthStencilAttachment:i,occlusionQuerySet:s,timestampWrites:h,maxDrawCount:l,label:r}}SetPassDescriptor(e){this.Descriptor=e}CreateVertexBufferAttribute(e,r=0,i=0){return{format:e,shaderLocation:r,offset:i}}CreateVertexState(e,r="vertex",i,s){return i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,buffers:i,constants:s}}CreateFragmentColorTarget(e=a(this,I),r,i){return{format:e,blend:r,writeMask:i}}CreateFragmentState(e,r="fragment",i,s){return i??(i=[this.CreateFragmentColorTarget()]),i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,targets:i,constants:s}}CreatePipeline(e){const r=e.layout??"auto";let{module:i,vertex:s,fragment:h}=e;i&&(s??(s=this.CreateVertexState(i)),h??(h=this.CreateFragmentState(i))),!i&&!s&&p(T.VERTEX_STATE_NOT_FOUND);const l=e.label??this.CreatePipelineLabel("Render Pipeline");return this.Pipeline=this.Device.createRenderPipeline({...e,vertex:s,fragment:h,label:l,layout:r})}SetPipeline(e){this.Pipeline=e}SetVertexBuffers(e,r,i){r=Array.isArray(r)&&r||[r],i=Array.isArray(i)&&i||[i],E(this,F,Array.isArray(e)&&e.map((s,h)=>({buffer:s,offset:r[h],size:i[h]}))||[{buffer:e,offset:r[0],size:i[0]}])}AddVertexBuffers(e,r,i){r=Array.isArray(r)&&r||[r],i=Array.isArray(i)&&i||[i],a(this,F).push(...Array.isArray(e)&&e.map((s,h)=>({buffer:s,offset:r[h],size:i[h]}))||[{buffer:e,offset:r[0],size:i[0]}])}SetIndexBuffer(e,r="uint32",i,s){E(this,d,{buffer:e,format:r,offset:i,size:s})}Render(e,r=!0){a(this,c)||(a(this,U)&&(this.Descriptor.colorAttachments[0].view=this.CurrentTextureView),E(this,c,this.GetCommandEncoder().beginRenderPass(this.Descriptor)),a(this,c).setPipeline(this.Pipeline),E(this,X,a(this,d)?a(this,c).drawIndexed.bind(a(this,c)):a(this,c).draw.bind(a(this,c))));for(let i=0,s=a(this,F).length;i<s;++i){const{buffer:h,offset:l,size:N}=a(this,F)[i];a(this,c).setVertexBuffer(i,h,l,N)}a(this,d)&&a(this,c).setIndexBuffer(a(this,d).buffer,a(this,d).format,a(this,d).offset,a(this,d).size);for(let i=0,s=0,h=this.BindGroups.length;i<h;++i){const{bindGroup:l,dynamicOffsets:N,active:R}=this.BindGroups[i];R&&a(this,c).setBindGroup(s++,l,N)}a(this,X).call(this,...Array.isArray(e)&&e||[e]),r&&this.Submit()}Submit(){a(this,c).end(),this.SubmitCommandBuffer(),this.DestroyCommandEncoder(),E(this,c,void 0)}Destroy(){var e;E(this,c,void 0),(e=a(this,g))==null||e.unconfigure()}get Canvas(){return a(this,D)}get Context(){return a(this,g)}get AspectRatio(){return!a(this,D)&&p(T.CANVAS_NOT_FOUND),a(this,D).width/a(this,D).height}get CurrentTexture(){return a(this,g).getCurrentTexture()}get CurrentTextureView(){return this.CurrentTexture.createView()}set UseCurrentTextureView(e){E(this,U,e)}get UseCurrentTextureView(){return a(this,U)}get ResolutionBuffer(){return a(this,L)}get CurrentPass(){return a(this,c)}}X=new WeakMap,U=new WeakMap,f=new WeakMap,D=new WeakMap,g=new WeakMap,L=new WeakMap,F=new WeakMap,I=new WeakMap,d=new WeakMap,c=new WeakMap,$=new WeakSet,J=function(){a(this,f).set([a(this,D).width,a(this,D).height]),this.WriteBuffer(a(this,L),a(this,f))};var Q;class Pe extends re{constructor(e,r){super(e,r,"Compute");u(this,Q,[1])}CreatePassDescriptor(e,r,i,s){return e??(e=this.CreatePipelineLabel("Compute Pass")),this.Descriptor={label:e,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:i,endOfPassWriteIndex:s}:void 0}}SetPassDescriptor(e){this.Descriptor=e}CreatePipeline(e){const r=e.layout??"auto",i=e.label??this.CreatePipelineLabel("Compute Pipeline");return this.Pipeline=this.Device.createComputePipeline({label:i,layout:r,compute:e})}SetPipeline(e){this.Pipeline=e}Compute(){const e=this.GetCommandEncoder().beginComputePass(this.Descriptor);e.setPipeline(this.Pipeline);for(let r=0,i=0,s=this.BindGroups.length;r<s;++r){const{bindGroup:h,dynamicOffsets:l,active:N}=this.BindGroups[r];N&&e.setBindGroup(i++,h,l)}e.dispatchWorkgroups(...a(this,Q)),e.end()}set Workgroups(e){E(this,Q,Array.isArray(e)&&e||[e])}}Q=new WeakMap;var _,B,H,ie,q,K,w,z;class _e{constructor(t,e){u(this,H);u(this,q);u(this,w);u(this,_,void 0);u(this,B,void 0);!t&&p(T.DEVICE_NOT_REQUESTED),E(this,B,e),E(this,_,t)}CreateTexture(t){const e=t.label??O(this,H,ie).call(this,"Texture");return a(this,_).createTexture({...t,label:e})}WriteTexture(t,e){const{texture:r,mipLevel:i,origin:s,aspect:h,offset:l,bytesPerRow:N,rowsPerImage:R}=e;a(this,_).queue.writeTexture({texture:r,mipLevel:i,origin:s,aspect:h},t,{offset:l,bytesPerRow:N,rowsPerImage:R},O(this,q,K).call(this,e))}CreateBitmapImage(t,e){return createImageBitmap(t,e)}CreateTextureFromSource(t,e){const r=e.mipLevelCount??(e.mipmaps&&this.GetMipmapLevels(t)||void 0),i=e.size,s=e.size,h=Array.isArray(e.size)||!e.size?i??O(this,w,z).call(this,t):[s.width,s.height];return this.CreateTexture({mipLevelCount:r,size:h,...e})}CopyImageToTexture(t,e){let{texture:r}=e;const[i,s]=O(this,w,z).call(this,t),{create:h,flipY:l,mipLevel:N,aspect:R,colorSpace:oe,premultipliedAlpha:ue}=e;return!r&&!h&&p(T.TEXTURE_SIZE_NOT_FOUND),r??(r=this.CreateTextureFromSource(t,h)),a(this,_).queue.copyExternalImageToTexture({source:t,origin:e.sourceOrigin,flipY:l},{texture:r,mipLevel:N,origin:e.destinationOrigin,aspect:R,colorSpace:oe,premultipliedAlpha:ue},O(this,q,K).call(this,{width:i,height:s,...e})),r}CreateSampler(t){return a(this,_).createSampler(t)}GetMipmapLevels(t){const[e,r]=O(this,w,z).call(this,t);return(Math.log2(Math.max(e,r))|0)+1}}_=new WeakMap,B=new WeakMap,H=new WeakSet,ie=function(t){return a(this,B)&&t&&`${a(this,B)} ${t}`||""},q=new WeakSet,K=function(t){const{size:e,width:r,height:i,depthOrArrayLayers:s}=t;return!e&&!r&&p(T.TEXTURE_SIZE_NOT_FOUND),e??{width:r,height:i,depthOrArrayLayers:s}},w=new WeakSet,z=function(t){return t instanceof VideoFrame?[t.codedWidth,t.codedHeight]:[t.width,t.height]};C({ALL:"all",STENCIL:"stencil-only",DEPTH:"depth-only"});const Re=C({CLAMP:"clamp-to-edge",REPEAT:"repeat",MIRROR:"mirror-repeat"}),Se=C({NEAREST:"nearest",LINEAR:"linear"});C({NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"});/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.4
 * @license MIT
 */var V,x,y,m,b,M,W,j,ae,Z,se,k,ne;const n=class n{static SetAdapterOptions(t,e=!1){a(n,x).powerPreference=t,a(n,x).forceFallbackAdapter=e}static SetDeviceDescriptor(t,e=[],r={}){a(n,m).label=t,a(n,m).requiredFeatures=e,a(n,m).requiredLimits=r}static RenderPipeline(t,e="",r={}){return O(this,M,W).call(this,e),(async()=>{const i=await n.Device;return new Proxy(Ae,{construct(s){return new s(i,e,t,r)}})})()}static ComputePipeline(t=""){return O(this,M,W).call(this,t),(async()=>{const e=await n.Device;return new Proxy(Pe,{construct(r){return new r(e,t)}})})()}static Texture(t=""){return O(this,M,W).call(this,t),(async()=>{const e=await n.Device;return new Proxy(_e,{construct(r){return new r(e,t)}})})()}static Destroy(t,e,r){var i;t=Array.isArray(t)&&t||[t],t.forEach(s=>s==null?void 0:s.destroy()),e=Array.isArray(e)&&e||[e],e.forEach(s=>s==null?void 0:s.destroy()),r=Array.isArray(r)&&r||[r],r.forEach(s=>s==null?void 0:s.destroy()),(i=a(n,y))==null||i.destroy(),n.SetAdapterOptions(),n.SetDeviceDescriptor(),E(n,b,void 0),E(n,V,E(n,y,null))}static get AdapterLimits(){return a(this,b)}static get Adapter(){return(async()=>{var t;return a(n,V)??await O(t=n,Z,se).call(t)()})()}static get Device(){return(async()=>{var t;return a(n,y)??await O(t=n,k,ne).call(t)()})()}static get VERSION(){return"0.0.4"}};V=new WeakMap,x=new WeakMap,y=new WeakMap,m=new WeakMap,b=new WeakMap,M=new WeakSet,W=function(t){var e;(e=a(n,m)).label??(e.label=t&&`${t} Device`||"")},j=new WeakSet,ae=function(t){if(n.OnDeviceLost)return n.OnDeviceLost(t);const e=(t.message&&` | Message: ${t.message}`)??".";p(T.DEVICE_LOST,` Reason: ${t.reason}`+e)},Z=new WeakSet,se=function(){return!navigator.gpu&&p(T.WEBGPU_NOT_SUPPORTED),async()=>{const t=await navigator.gpu.requestAdapter(a(n,x));return!t&&p(T.ADAPTER_NOT_FOUND),E(this,b,t.limits),E(n,V,t)}},k=new WeakSet,ne=function(){return async()=>{const{requiredFeatures:t,requiredLimits:e,label:r}=a(n,m),i=await(await n.Adapter).requestDevice({requiredFeatures:t,requiredLimits:e,defaultQueue:{label:r}});return!i&&p(T.DEVICE_NOT_FOUND),i.lost.then(O(n,j,ae)),E(n,y,i)}},u(n,M),u(n,j),u(n,Z),u(n,k),u(n,V,null),u(n,x,{powerPreference:void 0,forceFallbackAdapter:!1}),u(n,y,null),u(n,m,{label:void 0,requiredFeatures:[],requiredLimits:{}}),u(n,b,void 0),v(n,"OnDeviceLost");let ee=n;C({HPI:Math.PI/2,TAU:Math.PI*2});C({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});console.info("%cUWAL v0.0.4","background:#005a9c;padding:3px;color:#fff;");export{Re as A,Se as F,ee as U};
