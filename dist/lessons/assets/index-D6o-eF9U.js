import{U as R,A as b,F as c}from"./index-C4iHMEF5.js";import{v as U,m as a}from"./wgpu-matrix.module-BCZfl02X.js";import{Q as _,C as I}from"./Quad-BFiS1mN9.js";var L="struct Transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_external;@group(0)@binding(2)var<uniform>transform: Transform;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=transform.matrix*vec4f(position,0.0,1.0);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSampleBaseClampToEdge(Texture,Sampler,textureCoord);}";const z=""+new URL("video-BxXy5_gQ.mp4",import.meta.url).href;/**
 * @module Using Video
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Using Video Efficiently
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.6
 * @license MIT
 */(async function(l){let t;try{t=new(await R.RenderPipeline(l,"Using Video"))}catch(e){alert(e)}const P=0,m=[],d=1,f=2e3,y=[0,1,0],B=[0,0,0],x=Math.PI*60/180,F=[0,0,2],E=U.set(1.2,.5),p=a.perspective(x,t.AspectRatio,d,f),v=a.lookAt(F,B,y),g=a.multiply(p,v),i=document.createElement("video");i.muted=i.loop=!0,i.preload="auto",i.src=z,t.CreatePipeline({module:t.CreateShaderModule([_,L])});const A=t.CreateColorAttachment();A.clearValue=new I(5000268).rgba,t.CreatePassDescriptor(A);const C=new(await R.Texture());await h(i);for(let e=0;e<4;e++){const r=C.CreateSampler({addressModeU:b.REPEAT,addressModeV:b.REPEAT,magFilter:e&1?c.LINEAR:c.NEAREST,minFilter:e&2?c.LINEAR:c.NEAREST}),o=16*Float32Array.BYTES_PER_ELEMENT,n=t.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:o}),s=new Float32Array(o/Float32Array.BYTES_PER_ELEMENT),u=s.subarray(P,16);m.push({sampler:r,matrixBuffer:n,matrixValues:s,matrix:u})}function h(e){return new Promise((r,o)=>{if(e.addEventListener("error",o),"requestVideoFrameCallback"in e)e.requestVideoFrameCallback(r);else{const n=()=>e.currentTime?r():requestAnimationFrame(n);n()}e.play().catch(o)})}function S(){requestAnimationFrame(S);const e=C.ImportExternalTexture(i);m.forEach(({matrix:r,sampler:o,matrixBuffer:n,matrixValues:s},u)=>{const M=u%2-.5,T=+(u<2)*2-1,V=[M*E[0],T*E[1],-.5];a.translate(g,V,r),a.rotateX(r,Math.PI*.25*Math.sign(T),r),a.scale(r,[1,-1,1],r),a.translate(r,[-.5,-.5,0],r),t.WriteBuffer(n,s),t.SetBindGroups(t.CreateBindGroup(t.CreateBindGroupEntries([o,e,{buffer:n}]))),t.Render(6,!1)}),t.Submit()}const w=new ResizeObserver(e=>{for(const r of e){const{inlineSize:o,blockSize:n}=r.contentBoxSize[0];t.SetCanvasSize(o,n)}a.perspective(x,t.AspectRatio,d,f,p),a.multiply(p,v,g),requestAnimationFrame(S)});l.addEventListener("click",()=>i[i.paused?"play":"pause"]()),w.observe(l)})(document.getElementById("lesson"));
