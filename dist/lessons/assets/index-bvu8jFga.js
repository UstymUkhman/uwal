import{D as _,U as y,b as q,a as T}from"./index-CWG6eoQD.js";import{M as H}from"./MatrixStack-CjTeTXWK.js";import{c as J}from"./ConeVertices-DQO7wRFY.js";import{C as K,a as N}from"./Cube-Uz7Qg183.js";import{P as Q}from"./PerspectiveCamera-MopHud7N.js";/**
 * @module Recursive Tree
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Stacks
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html#a-recursive-tree}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 *
 * This approach uses one render pipeline with different vertex buffers and `DrawMethods` and switches
 * between them at render time using `Pipeline.SetVertexBuffers` and `Pipeline.SetIndexBuffer` methods.
 * @version 0.1.0
 * @license MIT
 */(async function(b){let r;b.style.backgroundColor="#000";try{r=new(await _.Renderer(b,"Recursive Tree",{alphaMode:"premultiplied"}))}catch(t){alert(t)}const c={rotationX:y.DegreesToRadians(20),rotationY:y.DegreesToRadians(10),baseRotation:0,scale:.9},U={min:-180,max:180,step:1,converters:GUI.converters.radToDeg},C={min:0,max:90,step:1,converters:GUI.converters.radToDeg},v=[20,150,20],A=[1,1,1,1],p=[],G=6;let f=0;const a=new H,u=new GUI().onChange(g);u.add(c,"scale",.1,1.2),u.add(c,"rotationX",C),u.add(c,"rotationY",C),u.add(c,"baseRotation",U);const s=new Q(60,1,2e3);s.Position=[0,450,1e3],s.LookAt([0,450,0]);const I=s.UpdateViewProjection(!1);r.CreatePassDescriptor(r.CreateColorAttachment(),r.CreateDepthStencilAttachment());const l=new N,e=new r.Pipeline,x=e.CreateShaderModule(K),{layout:k,buffer:S}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);l.SetRenderPipeline(await r.AddPipeline(e,{primitive:{cullMode:"back"},fragment:e.CreateFragmentState(x),depthStencil:e.CreateDepthStencilState(),vertex:e.CreateVertexState(x,void 0,[l.GetPositionBufferLayout(e),k])}));const z=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],V=l.UV.length/2,m=new Uint8Array(V*4);for(let t=0,o=0;t<V;o=(++t/4|0)*3){const n=z.slice(o,o+3);m.set(n,t*4),m[t*4+3]=255}const{vertexData:P,colorData:M,vertices:O}=J(20,60),h=e.CreateVertexBuffer(P),{buffer:w}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},O);e.WriteBuffer(w,M),e.WriteBuffer(h,P),e.WriteBuffer(S,m),l.AddVertexBuffers(S);const W=[h,w],Y=Object.values(e.IndexBuffer),L=e.VertexBuffers.map(({buffer:t})=>t);function R(t,o){if(f===p.length){const{projection:F,buffer:D}=e.CreateUniformBuffer("projection"),{color:Z,buffer:j}=e.CreateUniformBuffer("color");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([j,D]))),p.push({projectionValue:F,projectionBuffer:D,colorValue:Z,colorBuffer:j})}const{projectionValue:n,projectionBuffer:i,colorValue:d,colorBuffer:E}=p[f];d.set(A),e.WriteBuffer(E,d),T.multiply(I,t,n),e.WriteBuffer(i,n),e.SetVertexBuffers(o?W:L),e.SetIndexBuffer(...!o&&Y||[void 0]),e.SetActiveBindGroups(f++),r.Render(!1)}function X(){a.Push().Scale(v).Translate([0,.5,0]),R(a.Get()),a.Pop()}function B(t,o){const n=t?c.scale:1,i=t?v[1]:0;if(a.Push().Translate([0,i,0]).RotateZ(t*c.rotationX).RotateY(Math.abs(t)*c.rotationY).Scale([n,n,n]),X(),0<o&&(B(-1,o-1),B(1,o-1)),0<t&&!o){const d=q.getTranslation(a.Get());R(T.translation(d),!0)}a.Pop()}function g(){a.Push(),a.RotateY(c.baseRotation),f=0,B(0,G),a.Pop(),r.Submit()}new ResizeObserver(t=>{for(const o of t){const{inlineSize:n,blockSize:i}=o.contentBoxSize[0];r.SetCanvasSize(n,i),s.AspectRatio=r.AspectRatio,s.UpdateViewProjection(!1)}g()}).observe(document.body)})(document.getElementById("lesson"));
