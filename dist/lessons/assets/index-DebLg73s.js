import{m as c,c as _,v as D,N as H,G as I,D as W,C as A,U as E}from"./index-BEuvW3M9.js";var K="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec3f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution.xy*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0,1);}@vertex fn shapeVertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}";class X{#e;#o=0;#s=!1;#n=c.create();#S=c.create();#B=c.create();#C=c.create();#f;#a;#v;#p;#i;#h;#c;#t;#l=[];#d=[void 0];#m=new Float32Array([1,1]);#r=new Float32Array([0,0]);#y=new Float32Array([0,0]);#x=new Float32Array([0,0]);#g;#u=_({min:D.create(),max:D.create()});constructor(t){this.#t=t.renderer,this.#a=t.segments,this.#e=t.radius??0,this.#f=t.label??"Shape";const{startAngle:e,endAngle:r,innerRadius:n}=t;this.#A(e,r,n),this.#E(),this.#V(),this.Scale=this.#m,this.Origin=this.#r,this.Rotation=this.#o,this.Position=this.#x}#A(t=0,e=H.TAU,r=0){const n=e-t,l=new Float32Array((this.#a+1)*2*3);for(let p=0,d=0;d<=this.#a;++d){const f=t+d*n/this.#a,m=Math.cos(f),o=Math.sin(f);l[p++]=m*this.#e,l[p++]=o*this.#e,l[p++]=m*r,l[p++]=o*r}const y=this.#t.CreateVertexBuffer(l,{label:`${this.#f} Vertex Buffer`});this.#t.WriteBuffer(y,l),this.#l.push(y)}#E(){const t=new Uint32Array(this.#v=this.#a*6);for(let e=0,r=0;r<this.#a;++r){const n=r*2;t[e++]=n+1,t[e++]=n+3,t[e++]=n+2,t[e++]=n+2,t[e++]=n+0,t[e++]=n+1}this.#h=this.#t.CreateIndexBuffer(t,{label:`${this.#f} Index Buffer`}),this.#t.WriteBuffer(this.#h,t)}#V(){const{buffer:t,shape:{color:e,matrix:r}}=this.#t.CreateUniformBuffer("shape",{label:`${this.#f} Uniform Buffer`});this.#c=t,this.#i=r,this.#p=e,this.#d[0]=this.#t.CreateBindGroup(this.#t.CreateBindGroupEntries([{buffer:this.#t.ResolutionBuffer},{buffer:this.#c}]),0,`${this.#f} Bind Group`),this.#g=_({matrix:e.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT})}#b(){if(this.#s){c.multiply(this.#C,this.#B,this.#i),c.multiply(this.#i,this.#S,this.#i),c.multiply(this.#i,this.#n,this.#i),this.#t.WriteBuffer(this.#c,this.#i,this.#g.matrix);const t=this.#y[0]=this.#i[8],e=this.#y[1]=this.#i[9];this.#u.min[0]=t-this.#e,this.#u.min[1]=e-this.#e,this.#u.max[0]=t+this.#e,this.#u.max[1]=e+this.#e,this.#s=!1}return this}Update(){return this.#t.SetVertexBuffers(this.#l),this.#t.SetIndexBuffer(this.#h),this.#t.SetBindGroups(this.#d),this.#b()}Render(t=!0){this.#t.SavePipelineState(),this.#t.Render(this.Update().#v,t),this.#t.RestorePipelineState()}AddBindGroups(t){this.#d.push(...I(t))}AddVertexBuffers(t){this.#l.push(...I(t))}set Color(t){this.#p.set(Array.isArray(t)||ArrayBuffer.isView(t)?t:t.rgba),this.#t.WriteBuffer(this.#c,this.#p,this.#g.color)}get Color(){return this.#p}set Position(t){this.#x.set(t),c.translation(this.#x,this.#C),this.#s=!0}get Position(){return this.#x}set Rotation(t){this.#o=t,c.rotation(this.#o,this.#B),this.#s=!0}get Rotation(){return this.#o}set Scale(t){this.#m.set(t),c.scaling(this.#m,this.#S),this.#s=!0}get Scale(){return this.#m}set Origin(t){this.#r[0]=t[0],this.#r[1]=t[1],this.#r[0]*=-this.#e,this.#r[1]*=-this.#e,c.translation(this.#r,this.#n),this.#r[0]=t[0]||0,this.#r[1]=t[1]||0,this.#s=!0}get Origin(){return this.#r}get Center(){return this.#b().#y}get Vertices(){return this.#v}get Transform(){return this.#i}get BoundingBox(){return this.#u}Destroy(){this.#l.forEach(t=>t.destroy()),this.#c=this.#c.destroy(),this.#h=this.#h.destroy(),this.#l.splice(0),this.#d.splice(0)}}class V{#e=0;#o=0;#s=0;#n=[];constructor(t=30){this.#e=t}addSample(t){if(Number.isFinite(t)&&!Number.isNaN(t)&&0<=t){const e=this.#n[this.#s]||0;this.#o+=t-e,this.#n[this.#s]=t,this.#s=(this.#s+1)%this.#e}}get(){return this.#o/this.#n.length}}var Z="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;let clipSpace=GetVertexClipSpace(position*scale).xy;output.position=vec4f(clipSpace+(offset+0.9)/1.8*vec2f(2,-2),0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Timing Performance
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Timing Performance
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(B){let t,e=0;try{await W.SetRequiredFeatures("timestamp-query"),t=new(await W.RenderPipeline(B,"Timing Performance"))}catch(s){alert(s)}const r=24,n=0,l=0,y=2,p=new GUI,d=[],f=1e4,m={objects:100};p.add(m,"objects",0,f,1);const o=document.createElement("pre"),w=document.createElement("span"),R=document.createElement("span"),P=document.createElement("span");o.style.backgroundColor="rgb(0 0 0 / 0.8)",o.style.position="absolute",o.style.padding="0.5em",o.style.display="grid",o.style.color="white",o.style.margin="0px",o.style.left="0px",o.style.top="0px",o.append(w,R,P),document.body.appendChild(o);const U=new V,F=new V,G=new V,T=t.CreateShaderModule([K,Z]),M=t.CreateColorAttachment();M.clearValue=new A(5000268).rgba;const C=new E.LegacyGPUTiming(t),$=await C.QuerySet;t.CreatePassDescriptor(M,void 0,void 0,void 0,t.CreateTimestampWrites($,0,1));const q=t.CreateVertexBufferLayout("position"),{buffer:g,layout:Y}=t.CreateVertexBuffer([{name:"color",format:"unorm8x4"}],f,"instance"),{buffer:S,layout:k}=t.CreateVertexBuffer(["offset","scale"],f,"instance"),{buffer:O,layout:J}=t.CreateVertexBuffer({name:"vertexColor",format:"unorm8x4"},f);t.CreatePipeline({fragment:t.CreateFragmentState(T),vertex:t.CreateVertexState(T,void 0,[q,Y,k,J])});const Q=new X({renderer:t,innerRadius:120,radius:240,segments:r}).Update().Vertices,b=new Float32Array(S.size/Float32Array.BYTES_PER_ELEMENT);t.AddVertexBuffers([g,S,O]);{const s=g.size/f,i=new Uint8Array(g.size);for(let a=0;a<f;++a)i.set([u(255),u(255),u(255),255],s*a+n),d.push({scale:u(.2,.5),offset:[u(-.9,.9),u(-.9,.9)],velocity:[u(-.1,.1),u(-.1,.1)]});t.WriteBuffer(g,i)}{const s=new A(1644825),i=new A(16777215),a=new Uint8Array((r+1)*8);for(let x=0,h=0;x<=r;x++,h+=8)a.set(s.RGBA,h),a.set(i.RGBA,h+4);t.WriteBuffer(O,a)}function u(s,i){return s===void 0?(s=0,i=1):i===void 0&&(i=s,s=0),Math.random()*(i-s)+s}async function N(s){s*=.001;const i=s-e,a=performance.now(),x=S.size/f/4;for(let h=0;h<m.objects;h++){const{scale:z,offset:v,velocity:L}=d[h];v[0]=E.EuclideanModulo(v[0]+L[0]*i+1.5,3)-1.5,v[1]=E.EuclideanModulo(v[1]+L[1]*i+1.5,3)-1.5;const j=h*x;b.set(v,j+l),b.set([z,z],j+y)}t.WriteBuffer(S,b),t.Render([Q,m.objects],!1),t.DestroyCurrentPass(),U.addSample(1/i),G.addSample(performance.now()-a),C.ResolveAndSubmit().then(h=>F.addSample(h/1e3)),w.textContent=`FPS: ${U.get().toFixed(1)}`,P.textContent=`JS: ${G.get().toFixed(1)}ms`,R.textContent=`GPU: ${C.Enabled&&`${F.get().toFixed(1)}Âµs`||"N/A"}`,requestAnimationFrame(N),e=s}new ResizeObserver(s=>{for(const i of s){const{inlineSize:a,blockSize:x}=i.contentBoxSize[0];t.SetCanvasSize(a,x)}requestAnimationFrame(N)}).observe(document.body)})(document.getElementById("lesson"));
