import{U as p,C as n}from"./index-CDSOL_j-.js";import{Q as w}from"./Quad-VFYOTGYq.js";var G="struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=vec4f(position,0.0,1.0);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}",S="@group(0)@binding(0)var<storage,read_write>src0: array<f32>;@group(0)@binding(1)var<storage,read_write>src1: array<f32>;@group(0)@binding(2)var<storage,read_write>dst: array<f32>;@compute @workgroup_size(1)fn compute(@builtin(global_invocation_id)id: vec3u){let i=id.x;dst[i]=src0[i]+src1[i];}";/**
 * @module Bind Group Layouts
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Bind Group Layouts
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(u){let t,r;try{t=new(await p.RenderPipeline(u,"Bind Group Layouts")),r=new(await p.ComputePipeline(u,"Dynamic Offsets"))}catch(f){alert(f)}const s=new(await p.Texture()),c=5,d=t.CreateColorAttachment();d.clearValue=new n(5000268).rgba,t.CreatePassDescriptor(d);const m=s.CreateSampler(),g=s.CreateTexture({format:"rgba32float",size:[c,7]}),e=new n(16711680).RGBA,o=new n(16776960).RGBA,C=new n(255).RGBA,y=new Float32Array([C,e,e,e,e,e,o,o,o,e,e,o,e,e,e,e,o,o,e,e,e,o,e,e,e,e,o,e,e,e,e,e,e,e,e].flat());s.WriteTexture(y,{texture:g,bytesPerRow:c*4*4}),t.CreatePipeline({module:t.CreateShaderModule([w,G]),layout:t.CreatePipelineLayout(t.CreateBindGroupLayout([{visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}},{visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float",viewDimension:"2d",multisampled:!1}}]))}),t.SetBindGroups(t.CreateBindGroup(t.CreateBindGroupEntries([m,g.createView()]))),r.CreatePipeline({module:t.CreateShaderModule(S),layout:t.CreatePipelineLayout(t.CreateBindGroupLayout(Array.from({length:3}).fill({visibility:GPUShaderStage.COMPUTE,buffer:{hasDynamicOffset:!0,type:"storage"}})))});const a=new Float32Array(64*3);a.set([1,3,5]),a.set([11,12,13],64);const l=r.CreateBuffer({usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,size:a.byteLength}),i=r.CreateReadableBuffer(a.byteLength);r.WriteBuffer(l,a),r.SetBindGroups(r.CreateBindGroup(r.CreateBindGroupEntries(Array.from({length:3}).fill({buffer:l,size:256}))),[[0,256,512]]),r.Workgroups=3,r.Compute(),r.CopyBufferToBuffer(l,i,i.size),r.SubmitCommandBuffer(),await i.mapAsync(GPUMapMode.READ);const x=new Float32Array(i.getMappedRange());console.log("src0:",a.slice(0,3)),console.log("src1:",a.slice(64,67)),console.log("dst:",x.slice(128,131)),i.unmap(),new ResizeObserver(f=>{for(const b of f){const{inlineSize:v,blockSize:B}=b.contentBoxSize[0];t.SetCanvasSize(v,B)}t.Render(6)}).observe(u)})(document.getElementById("lesson"));
