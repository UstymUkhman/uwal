import{D as T,U as f,a as c}from"./index-DkLC8RgG.js";import{C as y}from"./Cube-DE902Bpq.js";var U="struct transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)normal: vec3f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>Transform: transform;@group(0)@binding(2)var CubeTexture: texture_cube<f32>;@vertex fn vertex(@location(0)position: vec4f)->VertexOutput {var output: VertexOutput;output.position=Transform.matrix*position;output.normal=normalize(position.xyz);return output;}@fragment fn fragment(@location(0)normal: vec3f)->@location(0)vec4f {return textureSample(CubeTexture,Sampler,normalize(normal));}";/**
 * @module Cubemaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cubemaps
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cube-maps.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.6
 * @license MIT
 */(async function(v){let e,d;try{e=new(await T.RenderPipeline(v,"Cubemaps",{alphaMode:"premultiplied"}))}catch(t){alert(t)}const x=e.CreateColorAttachment();x.clearValue=[0,0,0,1],e.CreatePassDescriptor(x,void 0,e.CreateDepthAttachment());const C=e.CreateShaderModule(U),b=f.DegreesToRadians(60);e.CreatePipeline({primitive:{cullMode:"back"},fragment:e.CreateFragmentState(C),vertex:e.CreateVertexState(C,void 0,{arrayStride:Float32Array.BYTES_PER_ELEMENT*3,attributes:[e.CreateVertexBufferAttribute("float32x3")]}),depthStencil:{depthWriteEnabled:!0,format:"depth24plus",depthCompare:"less"}});const l=new(await T.Texture()),u=new y(e),o=u.Transform;l.SetRenderer(e);const F=[{faceColor:"#F00",textColor:"#0FF",text:"+X"},{faceColor:"#FF0",textColor:"#00F",text:"-X"},{faceColor:"#0F0",textColor:"#F0F",text:"+Y"},{faceColor:"#0FF",textColor:"#F00",text:"-Y"},{faceColor:"#00F",textColor:"#FF0",text:"+Z"},{faceColor:"#F0F",textColor:"#0F0",text:"-Z"}].map(t=>R(t)),S=l.CreateSampler({filter:"linear"}),h=D(F);e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([S,{buffer:u.TransformBuffer},h.createView({dimension:"cube"})])));const E=c.lookAt([0,1,5],[0,0,0],[0,1,0]),i={rotation:[f.DegreesToRadians(20),f.DegreesToRadians(25),f.DegreesToRadians(0)]},p={converters:GUI.converters.radToDeg,min:-360,max:360,step:1},m=new GUI;m.onChange(g),m.add(i.rotation,"0",p).name("rotation.x"),m.add(i.rotation,"1",p).name("rotation.y"),m.add(i.rotation,"2",p).name("rotation.z");function R({faceColor:t,textColor:n,text:s}){const a=document.createElement("canvas"),r=a.getContext("2d");return a.width=a.height=128,r.fillStyle=t,r.fillRect(0,0,128,128),r.textAlign="center",r.fillStyle=n,r.textBaseline="middle",r.font="90px sans-serif",r.fillText(s,64,64),a}function D(t){const n=t[0],s=l.CreateTextureFromSource(n,{size:[n.width,n.height,t.length],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm"});return t.forEach((a,r)=>l.CopyImageToTexture(a,{mipmaps:r===t.length-1,destinationOrigin:[0,0,r],texture:s})),s}function g(){c.perspective(b,d,.1,10,o),c.multiply(o,E,o),c.rotateX(o,i.rotation[0],o),c.rotateY(o,i.rotation[1],o),c.rotateZ(o,i.rotation[2],o),u.UpdateTransformBuffer(),e.Render(u.Vertices)}new ResizeObserver(t=>{for(const n of t){const{inlineSize:s,blockSize:a}=n.contentBoxSize[0];e.SetCanvasSize(s,a)}d=e.AspectRatio,g()}).observe(document.body)})(document.getElementById("lesson"));
