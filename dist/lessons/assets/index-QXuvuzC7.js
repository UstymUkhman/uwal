import{U as i}from"./index-BEcPMtkb.js";var d="@vertex fn vertex(@builtin(vertex_index)index: u32)->@builtin(position)vec4f {let position=array(vec2f(0.0,0.5),vec2f(-0.5,-0.5),vec2f(0.5,-0.5));return vec4f(position[index],0.0,1.0);}@fragment fn fragment()->@location(0)vec4f {return vec4f(1.0,0.0,0.0,1.0);}",p="@group(0)@binding(0)var<storage,read_write>data: array<f32>;@compute @workgroup_size(1)fn compute(@builtin(global_invocation_id)id: vec3u){let i=id.x;data[i]*=2;}";/**
 * @module Fundamentals
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Fundamentals
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.3
 * @license MIT
 */(async function(a){{let s=function(){i.SetCanvasSize(a.width,a.height),e.colorAttachments[0].view=i.CurrentTextureView,t.Render(e,u,3)},t;try{t=new(await i.RenderPipeline(a,"Red Triangle"))}catch(o){alert(o)}const e=t.CreateRenderPassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),n=t.CreateShaderModule(d),u=t.CreateRenderPipeline({vertex:t.CreateVertexState(n),fragment:t.CreateFragmentState(n)});new ResizeObserver(o=>{for(const r of o){const{inlineSize:f,blockSize:l}=r.contentBoxSize[0];i.SetCanvasSize(f,l)}s()}).observe(a)}{const t=new Float32Array([1,3,5]),e=new(await i.ComputePipeline("Double Compute")),n=e.CreateBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});e.WriteBuffer(n,t);const u=e.CreateShaderModule(p),s=e.CreateComputePipeline({module:u}),c=e.CreateBindGroup(e.CreateBindGroupEntries({buffer:n})),o=e.CreateComputePassDescriptor();e.SetBindGroups(c),e.Workgroups=t.length,e.Compute(s,o);const r=e.CreateBuffer({size:t.byteLength,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});e.CopyBufferToBuffer(n,r,r.size),e.SubmitCommandBuffer(),await r.mapAsync(GPUMapMode.READ);const f=new Float32Array(r.getMappedRange());console.info("Input:",...t),console.info("Result:",...f),r.unmap()}})(document.getElementById("lesson"));
