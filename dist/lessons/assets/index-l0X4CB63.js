import{D as Z,U as I,a as P,b as q}from"./index-CWG6eoQD.js";import{C as H,a as J,M as K}from"./Cube-BElpkTDe.js";import{P as N}from"./PerspectiveCamera-DHdY3D6g.js";function Q(u=1,a=1,s=6){const B=[],b=[],x=Math.PI*2,f=(t,r,n,p)=>{B.push(Math.cos(t)*r,n,Math.sin(t)*r),b.push(...p)};for(let t=0;t<s;++t){const r=Array.from({length:2}).map((p,m)=>(t+m)/s*x),n=[(t+1)/s*128+127,0,0];f(r[0],0,0,n),f(r[1],u,-a,n),f(r[0],u,-a,n),f(r[0],u,-a,n),f(r[1],u,-a,n),f(r[0],0,-a,n)}const l=B.length/3,C=new Uint8Array(l*4),d=new Float32Array(l*3);d.set(B);for(let t=0;t<l;++t){const r=t*3,n=t*4,p=b.slice(r,r+3);C.set(p,n),C[n+3]=255}return{vertexData:d,colorData:C,vertices:l}}/**
 * @module Recursive Tree
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Stacks
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html#a-recursive-tree}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 *
 * This approach uses one render pipeline with different vertex buffers and `DrawMethods` and switches
 * between them at render time using `Pipeline.SetVertexBuffers` and `Pipeline.SetIndexBuffer` methods.
 * @version 0.1.0
 * @license MIT
 */(async function(u){let a;u.style.backgroundColor="#000";try{a=new(await Z.Renderer(u,"Recursive Tree",{alphaMode:"premultiplied"}))}catch(o){alert(o)}const s={rotationX:I.DegreesToRadians(20),rotationY:I.DegreesToRadians(10),baseRotation:0,scale:.9},B={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},b={min:0,max:90,step:1,converters:GUI.converters.radToDeg},x=[20,150,20],f=[1,1,1,1],l=[],C=6;let d=0;P.create();const t=new K,r=new GUI().onChange(U);r.add(s,"scale",.1,1.2),r.add(s,"rotationX",b),r.add(s,"rotationY",b),r.add(s,"baseRotation",B);const n=new N(60,1,2e3);n.Position=[0,450,1e3],n.LookAt([0,450,0]);const p=n.UpdateViewProjection(!1);a.CreatePassDescriptor(a.CreateColorAttachment(),a.CreateDepthStencilAttachment());const m=new J,e=new a.Pipeline,D=e.CreateShaderModule(H),{layout:M,buffer:R}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);m.SetRenderPipeline(await a.AddPipeline(e,{primitive:{cullMode:"back"},fragment:e.CreateFragmentState(D),depthStencil:e.CreateDepthStencilState(),vertex:e.CreateVertexState(D,void 0,[m.GetPositionBufferLayout(e),M])}));const k=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],h=m.UV.length/2,V=new Uint8Array(h*4);for(let o=0,c=0;o<h;c=(++o/4|0)*3){const i=k.slice(c,c+3);V.set(i,o*4),V[o*4+3]=255}const{vertexData:y,colorData:z,vertices:O}=Q(20,60),g=e.CreateVertexBuffer(y),{buffer:A}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},O);e.WriteBuffer(A,z),e.WriteBuffer(g,y),e.WriteBuffer(R,V),m.AddVertexBuffers(R);const W=[g,A],Y=Object.values(e.IndexBuffer),L=e.VertexBuffers.map(({buffer:o})=>o);function j(o,c){if(d===l.length){const{projection:F,buffer:T}=e.CreateUniformBuffer("projection"),{color:_,buffer:G}=e.CreateUniformBuffer("color");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([G,T]))),l.push({projectionValue:F,projectionBuffer:T,colorValue:_,colorBuffer:G})}const{projectionValue:i,projectionBuffer:v,colorValue:S,colorBuffer:E}=l[d];S.set(f),e.WriteBuffer(E,S),P.multiply(p,o,i),e.WriteBuffer(v,i),e.SetVertexBuffers(c?W:L),e.SetIndexBuffer(...!c&&Y||[void 0]),e.SetActiveBindGroups(d++),a.Render(!1)}function X(){t.Push().Scale(x).Translate([0,.5,0]),j(t.Get()),t.Pop()}function w(o,c){const i=o?s.scale:1,v=o?x[1]:0;if(t.Push().Translate([0,v,0]).RotateZ(o*s.rotationX).RotateY(Math.abs(o)*s.rotationY).Scale([i,i,i]),X(),0<c&&(w(-1,c-1),w(1,c-1)),0<o&&!c){const S=q.getTranslation(t.Get());j(P.translation(S),!0)}t.Pop()}function U(){t.Push(),t.RotateY(s.baseRotation),d=0,w(0,C),t.Pop(),a.Submit()}new ResizeObserver(o=>{for(const c of o){const{inlineSize:i,blockSize:v}=c.contentBoxSize[0];a.SetCanvasSize(i,v),n.AspectRatio=a.AspectRatio,n.UpdateViewProjection(!1)}U()}).observe(document.body)})(document.getElementById("lesson"));
