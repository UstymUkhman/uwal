import{D as C,v as P,C as R,A as T,F as s,a as c}from"./index-Dm8t6IxS.js";import{P as h}from"./PerspectiveCamera-pv-jk_Mf.js";import{Q as y}from"./Quad-VFYOTGYq.js";var F="struct VertexOutput{@location(0)textureCoord: vec2f,@builtin(position)position: vec4f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_external;@group(0)@binding(2)var<uniform>projection: mat4x4f;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=projection*vec4f(position,0,1);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSampleBaseClampToEdge(Texture,Sampler,textureCoord);}";/**
 * @module Using Camera
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Using Video Efficiently
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-textures-external-video.html#a-web-camera}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.12
 * @license MIT
 */(async function(u){let t;try{t=new(await C.RenderPipeline(u,"Using Camera"))}catch(e){alert(e)}const n=new h,i=document.createElement("video"),l=[],m=P.set(1.2,.5);n.Position=[0,0,2],n.LookAt([0,0,0]);const g=n.UpdateViewProjection(!1);t.CreatePipeline(t.CreateShaderModule([y,F]));const d=t.CreateColorAttachment();d.clearValue=new R(5000268).rgba,t.CreatePassDescriptor(d);const p=new(await C.Texture());await E(i),await S(i);for(let e=0;e<4;e++)l.push({...t.CreateUniformBuffer("projection"),sampler:p.CreateSampler({magFilter:e&1?s.LINEAR:s.NEAREST,minFilter:e&2?s.LINEAR:s.NEAREST,addressModeUV:T.REPEAT})});async function E(e){try{e.srcObject=await navigator.mediaDevices.getUserMedia({video:!0}),e.play()}catch(a){const o=a.message&&`: ${a.message}`||"";console.error(`Could not access the camera${o}.`)}}function S(e){return new Promise((a,o)=>{if(e.addEventListener("error",o),"requestVideoFrameCallback"in e)e.requestVideoFrameCallback(a);else{const r=()=>e.currentTime?a():requestAnimationFrame(r);r()}})}function f(){requestAnimationFrame(f);const e=p.ImportExternalTexture(i);l.forEach(({sampler:a,buffer:o,projection:r},x)=>{const A=x%2-.5,v=+(x<2)*2-1,b=[A*m[0],v*m[1],-.5];c.translate(g,b,r),c.rotateX(r,Math.PI*.25*Math.sign(v),r),c.scale(r,[1,-1,1],r),c.translate(r,[-.5,-.5,0],r),t.WriteBuffer(o,r),t.SetBindGroups(t.CreateBindGroup(t.CreateBindGroupEntries([a,e,{buffer:o}]))),t.Render(6,!1)}),t.Submit()}const w=new ResizeObserver(e=>{for(const a of e){const{inlineSize:o,blockSize:r}=a.contentBoxSize[0];t.SetCanvasSize(o,r)}n.AspectRatio=t.AspectRatio,n.UpdateViewProjection(!1),requestAnimationFrame(f)});u.addEventListener("click",()=>i[i.paused?"play":"pause"]()),w.observe(document.body)})(document.getElementById("lesson"));
