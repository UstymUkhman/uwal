import{D as H,F as re,B as i,a as W}from"./index-Dm8t6IxS.js";import{Q as ne}from"./Quad-VFYOTGYq.js";var oe="struct Matrix{values: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>matrix: Matrix;@group(0)@binding(2)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=matrix.values*vec4f(position,0.0,1.0);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}";/**
 * @module Blend Settings
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Transparency and Blending
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-transparency.html#blend-settings}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.7
 * @license MIT
 */(async function(C){let r;C.style.backgroundPosition="0 0, 0 16px, 16px -16px, -16px 0px",C.style.backgroundSize="32px 32px",C.style.backgroundColor="#404040",C.style.backgroundImage=`
        linear-gradient( 45deg,     #808080 25%, transparent 25%),
        linear-gradient(-45deg,     #808080 25%, transparent 25%),
        linear-gradient( 45deg, transparent 75%,     #808080 75%),
        linear-gradient(-45deg, transparent 75%,     #808080 75%)
    `;try{r=new(await H.RenderPipeline(C,"Blend Settings",{alphaMode:"premultiplied"}))}catch(e){alert(e)}const U=(e,t,n)=>`hsl(${e*360|0}, ${t*100}%, ${n*100|0}%)`,A=(e,t,n,o)=>`hsla${U(e,t,n).slice(3,-1)}, ${o})`;function J(e){const t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d");n.translate(e/2,e/2),n.globalCompositeOperation="screen";const o=Math.PI*2,a=3;for(let l=0;l<a;++l){n.rotate(o/a),n.save(),n.translate(e/6,0),n.beginPath();const u=e/3,q=l/a;n.arc(0,0,u,0,o);const I=n.createRadialGradient(0,0,u/2,0,0,u);I.addColorStop(.5,A(q,1,.5,1)),I.addColorStop(1,A(q,1,.5,0)),n.fillStyle=I,n.fill(),n.restore()}return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function K(e){const t=document.createElement("canvas");t.width=t.height=e;const n=t.getContext("2d"),o=n.createLinearGradient(0,0,e,e);for(let a=0;a<=6;++a)o.addColorStop(a/6,U(a/-6,1,.5));n.fillStyle=o,n.fillRect(0,0,e,e),n.fillStyle="rgba(0, 0, 0, 255)",n.globalCompositeOperation="destination-out",n.rotate(Math.PI/-4);for(let a=0;a<e*2;a+=32)n.fillRect(-300,a,e*2,16);return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function F(){const{values:e}=r.CreateUniformBufferLayout("matrix"),t=r.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:e.buffer.byteLength});return{values:e,buffer:t}}function h(e,t=!0){return N.CopyImageToTexture(e,{premultipliedAlpha:t,create:{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:!1}})}function c(e){typeof e=="string"&&!["constant","one-minus-constant"].includes(e)||(r.BlendConstant=[...b.color,b.alpha])}function y(){const{premultiply:e,alpha:t,color:n}=m,o=e&&t||1,[a,l,u]=n;f.clearValue[0]=a*o,f.clearValue[1]=l*o,f.clearValue[2]=u*o,f.clearValue[3]=t}function D(e){const{operation:t}=e;(t==="min"||t==="max")&&(e.srcFactor=e.dstFactor="one")}function R(e,t,n){const o=W.ortho(0,t.width,t.height,0,-1,1);W.scale(o,[n.width,n.height,1],e.values),r.WriteBuffer(e.buffer,e.values)}const N=new(await H.Texture(r)),B=r.CreateShaderModule([ne,oe]),x=N.CreateSampler({filter:re.LINEAR}),V=J(300),_=K(300),v=F(),G=F(),w=h(V),M=h(_),L=h(V,!1),$=h(_,!1),g=r.CreateBindGroupLayout([{visibility:GPUShaderStage.FRAGMENT,sampler:{}},{visibility:GPUShaderStage.VERTEX,buffer:{}},{visibility:GPUShaderStage.FRAGMENT,texture:{}}]);r.SetBindGroups([r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},w.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},M.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},L.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},$.createView()]),g)]);const Z=[{sourceBindGroup:0,destinationBindGroup:1,sourceTexture:w,destinationTexture:M},{sourceBindGroup:2,destinationBindGroup:3,sourceTexture:L,destinationTexture:$}],s=new GUI().onChange(X),S={textureSet:0,alphaMode:"premultiplied",preset:"Copy (Default)"};s.add(S,"alphaMode",["opaque","premultiplied"]).name("Canvas Alpha Mode").onChange(e=>r.ConfigureContext({alphaMode:e})),s.add(S,"textureSet",["premultiplied alpha","un-premultiplied alpha"]).name("Texture Set");const z=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),ee=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),k={"Copy (Default)":i.COPY,"Additive (Lighten)":i.ADDITIVE,"Un-premultiplied Blend":{color:z,alpha:ee},"Source Over (Premultiplied Blend)":i.SOURCE_OVER,"Destination Over":i.DESTINATION_OVER,"Source In":i.SOURCE_IN,"Destination In":i.DESTINATION_IN,"Source Out":i.SOURCE_OUT,"Destination Out":i.DESTINATION_OUT,"Source Atop":i.SOURCE_ATOP,"Destination Atop":i.DESTINATION_ATOP};s.add(S,"preset",Object.keys(k)).name("Blending Preset").onChange(e=>{const t=k[e];Object.assign(d,t.color),Object.assign(p,t.alpha)});const O=s.addFolder("Color"),d=r.CreateBlendComponent(),j=["add","subtract","reverse-subtract","min","max"],T=["zero","one","src","one-minus-src","src-alpha","one-minus-src-alpha","dst","one-minus-dst","dst-alpha","one-minus-dst-alpha","src-alpha-saturated","constant","one-minus-constant"];O.add(d,"operation",j).name("Operation"),O.add(d,"srcFactor",T).name("Source Factor").onChange(c),O.add(d,"dstFactor",T).name("Destination Factor").onChange(c);const P=s.addFolder("Alpha"),p=r.CreateBlendComponent();P.add(p,"operation",j).name("Operation"),P.add(p,"srcFactor",T).name("Source Factor").onChange(c),P.add(p,"dstFactor",T).name("Destination Factor").onChange(c);const Q=s.addFolder("Constant"),b={color:[1,.5,.25],alpha:1};Q.addColor(b,"color").name("Color").onChange(c),Q.add(b,"alpha",0,1).name("Alpha").onChange(c);const E=s.addFolder("Canvas Clear Color"),m={color:[0,0,0],alpha:0,premultiply:!0};E.addColor(m,"color").name("Color").onChange(y),E.add(m,"alpha",0,1).name("Alpha").onChange(y),E.add(m,"premultiply").name("Premultiply").onChange(y);const f=r.CreateColorAttachment();f.clearValue=[...m.color,m.alpha];const Y=r.CreatePipelineLayout(g);r.CreatePassDescriptor(f),r.CreatePipeline({module:B,layout:Y});const te=r.CreateVertexState(B);function X(){D(d),D(p),s.updateDisplay();const{sourceTexture:e,destinationTexture:t,destinationBindGroup:n,sourceBindGroup:o}=Z[S.textureSet],a=r.CurrentTexture;R(v,a,e),R(G,a,t),r.SetActiveBindGroups(n),r.Render(6,!1),r.SavePipelineState();const l=r.CreateTargetState(void 0,{color:d,alpha:p}),u=r.CreateFragmentState(B,void 0,l);r.CreatePipeline({vertex:te,fragment:u,layout:Y},!0),r.SetActiveBindGroups(o),r.Render(6),r.RestorePipelineState()}new ResizeObserver(e=>{for(const t of e){const{inlineSize:n,blockSize:o}=t.contentBoxSize[0];r.SetCanvasSize(n,o)}X()}).observe(document.body)})(document.getElementById("lesson"));
