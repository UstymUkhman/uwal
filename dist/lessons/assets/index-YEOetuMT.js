import{U as i}from"./index-DRM5NqZO.js";var l="@vertex fn vertex(@builtin(vertex_index)index: u32)->@builtin(position)vec4f {let position=array(vec2f(0.0,0.5),vec2f(-0.5,-0.5),vec2f(0.5,-0.5));return vec4f(position[index],0.0,1.0);}@fragment fn fragment()->@location(0)vec4f {return vec4f(1.0,0.0,0.0,1.0);}",p="@group(0)@binding(0)var<storage,read_write>data: array<f32>;@compute @workgroup_size(1)fn compute(@builtin(global_invocation_id)id: vec3u){let i=id.x;data[i]*=2;}";/**
 * @module Fundamentals
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Fundamentals
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.2
 * @license MIT
 */(async function(a){{let u=function(){i.SetCanvasSize(a.width,a.height),e.colorAttachments[0].view=i.CurrentTextureView,t.Render(e,s,3)},t;try{t=new(await i.RenderPipeline(a,"Red Triangle"))}catch(o){alert(o)}const e=t.CreateRenderPassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),n=t.CreateShaderModule(l),s=t.CreateRenderPipeline({vertex:t.CreateVertexState(n),fragment:t.CreateFragmentState(n)});new ResizeObserver(o=>{for(const r of o){const{inlineSize:f,blockSize:d}=r.contentBoxSize[0];i.SetCanvasSize(f,d)}u()}).observe(a)}{const t=new Float32Array([1,3,5]),e=new(await i.ComputePipeline("Double Compute")),n=e.CreateBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});e.WriteBuffer(n,t);const s=e.CreateShaderModule(p),u=e.CreateComputePipeline({module:s}),c=e.CreateBindGroup({layout:u.getBindGroupLayout(0),entries:e.CreateBindGroupEntries({buffer:n})}),o=e.CreateComputePassDescriptor();e.AddBindGroups(c),e.CreateCommandEncoder(),e.Workgroups=t.length,e.Compute(u,o);const r=e.CreateBuffer({size:t.byteLength,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST});e.CopyBufferToBuffer(n,r,r.size),e.SubmitCommandBuffer(),await r.mapAsync(GPUMapMode.READ);const f=new Float32Array(r.getMappedRange());console.info("Input:",...t),console.info("Result:",...f),r.unmap()}})(document.getElementById("lesson"));
