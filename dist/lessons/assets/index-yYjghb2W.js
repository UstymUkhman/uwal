import{d as y,T as de,E as le,a as K,b as J,c as me,e as pe,M as I,D as Ce}from"./index-BlHGMWAm.js";import{addButtonLeftJustified as xe}from"https://webgpufundamentals.org/webgpu/resources/js/gui-helpers.js";import{N as Q,S as Be,C as be}from"./Scene-sn7G2fBr.js";let ge=class extends Q{#r;Visible=!0;#t;#s;#i;#o=[];constructor(e,t,o="Mesh",i=null){super(o,i),this.#r=e,this.#i=t}SetRenderPipeline(e,t=!0){this.#t=e,this.#r.CreateBuffers(e),this.#i?.CreateColorBuffer(e),this.#n(t)}#n(e=!0,t){const{projection:o,buffer:i}=this.#t.CreateUniformBuffer("projection",{label:`${this.Label} Projection Buffer`,...t});this.ProjectionMatrix=y.identity(o),this.#s=i,e&&(this.#o=this.#t.SetBindGroupFromResources([i,this.#i?.ColorBuffer].filter(Boolean),0,0,`${this.Label} Bind Group`))}UpdateProjectionMatrix(e){const t=super.UpdateProjectionMatrix(e);this.#t.WriteBuffer(this.#s,t)}SetBindGroups(){!this.#t&&de(le.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Call `Mesh.SetRenderPipeline` method before setting its data."),this.#t.BindGroups=this.#o}get ProjectionBuffer(){return this.#s}get Geometry(){return this.#r}get Material(){return this.#i}get Pipeline(){return this.#t}Destroy(){this.#r.Destroy(),this.#i?.Destroy(),this.#t=void 0,this.#o.splice(0),this.#s.destroy(),this.#s=void 0}},we=class{#r;Label;IndexFormat;#t=crypto.randomUUID();VertexBuffers;IndexBuffer;constructor(e="Mesh",t){this.IndexFormat=t,this.Label=e}CreateVertexBuffer(e,t,o=this.Label){const i=e.CreateVertexBuffer(t,{label:`${o} Vertex Buffer`});this.VertexBuffers=e.SetVertexBuffers(i),e.WriteBuffer(i,t)}CreateIndexBuffer(e,t,o=this.Label){const i=e.CreateIndexBuffer(t,{label:`${o} Index Buffer`});this.IndexBuffer=e.SetIndexBuffer(i,this.IndexFormat),e.SetDrawParams(this.#r=t.length),e.WriteBuffer(i,t)}get Vertices(){return this.#r}get ID(){return this.#t}Destroy(){this.IndexBuffer?.buffer.destroy(),this.VertexBuffers?.[0].buffer.destroy()}};class ye extends we{#r;#t;constructor(e="Cube"){super(e,"uint16")}GetPositionBufferLayout(e,t={name:"position",format:"float32x3"},o="vertex",i="vertex"){return e.CreateVertexBufferLayout(t,o,i)}CreateTextureCoordsBuffer(e,t,o="vertex",i="vertex"){!Array.isArray(t)&&t?.name,t??="textureCoords";const m=new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]);return this.AddVertexBuffer(e,m,t,o,i)}AddVertexBuffer(e,t,o,i="vertex",m="vertex"){const{buffer:b,layout:V}=e.CreateVertexBuffer(o,this.Vertices,i,m);return this.VertexBuffers=e.AddVertexBuffers(b),e.WriteBuffer(b,t),{buffer:b,layout:V}}#s(e,t=this.Label){super.CreateVertexBuffer(e,this.#t??new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),t)}#i(e,t=this.Label){super.CreateIndexBuffer(e,this.#r??new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),t)}CreateBuffers(e,t=this.Label){this.#s(e,t),this.#i(e,t)}set VertexData(e){this.#t=e}set IndexData(e){this.#r=e}get Vertices(){return(this.#t&&this.#t.length/3)??this.#r?.length??super.Vertices??24}Destroy(){super.Destroy(),this.#r=void 0,this.#t=void 0}}class N{#r;#t;#s;#i=crypto.randomUUID();#o;#n;#e=new K(0,0);constructor(e=16777215,t="Mesh"){this.Color=e,this.#r=t}CreateColorBuffer(e,t=this.#r){const{color:o,buffer:i}=e.CreateUniformBuffer("color",{label:`${t} Color Buffer`});this.#t=o,this.#s=e,this.#n=i,this.#t.set(this.#o),e.WriteBuffer(i,o)}SetBlendConstant(e){if(!e?.BlendConstant||!this.#e.Equals(e.BlendConstant))return this.#s.BlendConstant=this.#e}set BlendConstant(e){typeof e=="number"&&this.#e.Set(e)||(this.#e.rgba=J(e))}get BlendConstant(){return this.#e}get ColorBuffer(){return this.#n}set Color(e){this.#o=typeof e=="number"&&me(e)||J(e),this.#t?.fill(1).set(this.#o),this.#s?.WriteBuffer(this.#n,this.#t)}get Color(){return this.#o}get ID(){return this.#i}Destroy(){this.#s=void 0,this.#n.destroy(),this.#n=void 0}}class ve extends Q{#r=pe.set(0,1,0);#t=60;#s=1;#i=1e3;#o=innerWidth/innerHeight;#n=y.identity();#e=new Float32Array(24);#a=y.identity();constructor(e=60,t=1,o=1e3,i=innerWidth/innerHeight){super("PerspectiveCamera"),this.#t=e,this.#s=t,this.#i=o,this.#o=typeof i!="number"?i.AspectRatio:i,this.UpdateProjectionMatrix()}#h(e=!1){const[t,o,i,m,b,V,M,g,S,j,f,D,p,C,x,d]=this.#a;if(this.#e[0]=p+S,this.#e[1]=C+j,this.#e[2]=x+f,this.#e[3]=d+D,this.#e[4]=p-S,this.#e[5]=C-j,this.#e[6]=x-f,this.#e[7]=d-D,this.#e[8]=p-b,this.#e[9]=C-V,this.#e[10]=x-M,this.#e[11]=d-g,this.#e[12]=p-t,this.#e[13]=C-o,this.#e[14]=x-i,this.#e[15]=d-m,this.#e[16]=p+b,this.#e[17]=C+V,this.#e[18]=x+M,this.#e[19]=d+g,this.#e[20]=p+t,this.#e[21]=C+o,this.#e[22]=x+i,this.#e[23]=d+m,!e)return this.#e;for(let P=0;P<6;++P){const B=P*4,w=Math.hypot(this.#e[B+0],this.#e[B+1],this.#e[B+2])||1;this.#e[B+0]/=w,this.#e[B+1]/=w,this.#e[B+2]/=w,this.#e[B+3]/=w}return this.#e}UpdateViewProjectionMatrix(){return y.inverse(this.LocalMatrix,this.#n),y.multiply(this.ProjectionMatrix,this.#n,this.#a),this.#h(),this.#a}UpdateProjectionMatrix(){const e=I.DegreesToRadians(this.#t);return y.perspective(e,this.#o,this.#s,this.#i,this.ProjectionMatrix)}LookAt(e,t=this.#r){return y.lookAt(this.Position,e,t,this.#n),y.multiply(this.ProjectionMatrix,this.#n,this.#a)}set AspectRatio(e){this.#o=typeof e!="number"?e.AspectRatio:e,this.UpdateProjectionMatrix()}get AspectRatio(){return this.#o}get ViewProjectionMatrix(){return this.#a}set FieldOfView(e){this.#t=e,this.UpdateProjectionMatrix()}get FieldOfView(){return this.#t}set Near(e){this.#s=e,this.UpdateProjectionMatrix()}get Near(){return this.#s}set Far(e){this.#i=e,this.UpdateProjectionMatrix()}get Far(){return this.#i}get Frustum(){return this.#e}}var Ve="struct VertexInput{@location(0)position: vec4f,@location(1)color: vec4f};struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@vertex fn cubeVertex(input: VertexInput)->VertexOutput {return VertexOutput(input.color,GetVertexClipSpace(input.position));}@fragment fn cubeFragment(vertex: VertexOutput)->@location(0)vec4f {return vertex.color*color;}";/**
 * @module Scene Graphs
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Scene Graphs
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-scene-graphs.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */(async function(v){let e;v.style.backgroundColor="#000";try{e=new(await Ce.Renderer(v,"Scene Graphs"))}catch(s){alert(s)}const t={min:-90,max:90,step:1,converters:GUI.converters.radToDeg},o={min:-180,max:180,step:1,converters:GUI.converters.radToDeg},i=new K,m=new N,b=new N(i.Set(8355711)),V=new N(i.Set(12566463,191)),[M,g,S]=[0,1,2],j=new Set([0,1,2]),f=[40,30,50],D=[10,2,2],p=4,C=[];let x=!1,d,P;const B=5;let w,O=0;const n={cameraRotation:I.DegreesToRadians(-45),animate:!1,showMeshNodes:!1,showAllTransforms:!1,position:I.Vec3.create(),rotation:I.Vec3.create(),scale:I.Vec3.set(1,1,1)},U=new Be,R=new GUI().onChange($);R.add(n,"cameraRotation",o).onChange(q),R.add(n,"animate").onChange(s=>u.enable(!s)),R.add(n,"showMeshNodes").onChange(Z),R.add(n,"showAllTransforms").onChange(Y);const u=R.addFolder("Orientation");u.onChange(()=>w.Transform=[n.position,n.rotation,n.scale]);const ee=[u.add(n.position,"0",-200,200,1).name("Position X"),u.add(n.position,"1",-200,200,1).name("Position Y"),u.add(n.position,"2",-200,200,1).name("Position Z"),u.add(n.rotation,"0",t).name("Rotation X"),u.add(n.rotation,"1",t).name("Rotation Y"),u.add(n.rotation,"2",t).name("Rotation Z"),u.add(n.scale,"0",.1,100).name("Scale X"),u.add(n.scale,"1",.1,100).name("Scale Y"),u.add(n.scale,"2",.1,100).name("Scale Z")],te=[0,f[g]/3*2-f[g]/2,D[S]/2+f[S]/2],E=f[M]+10,W=f[g]+3,L=[f[M]+6,W*p+6,f[S]+4],A=new ve,G=new ye,l=new e.Pipeline,re=(L[M]+E)/2*(B-1)/2+4,z=l.CreateShaderModule([be,Ve]),{layout:se,buffer:ie}=ne();await e.AddPipeline(l,{primitive:l.CreatePrimitiveState(),depthStencil:l.CreateDepthStencilState(),fragment:l.CreateFragmentState(z,void 0,void 0,"cubeFragment"),vertex:l.CreateVertexState(z,[G.GetPositionBufferLayout(l),se],void 0,"cubeVertex")}),Array.from({length:5}).forEach((s,r)=>he(U,r));const oe=k(R.addFolder("Nodes"),U);e.CreatePassDescriptor(e.CreateColorAttachment(),e.CreateDepthStencilAttachment()),_(U.Children[0]),Y(!1),Z(!1);function k(s,r,a,h){const c=[],H=h===void 0;if(r.Label!=="Scene"){const T=`${H?"":`${h} +-`}${r.Label}`;c.push(xe(s,T,()=>_(r)))}return h=H?"":`${h}${a?"   ":" | "}`,c.push(...r.Children.map((T,ue)=>k(s,T,ue===r.Children.length-1,h))),c.flat()}function q(s){A.Transform=[[re,20,0],[0,s,0]],A.Position=[0,0,300],A.UpdateViewProjectionMatrix()}function X(){const{Position:s,Rotation:r,Scaling:a}=w;n.position.set(s),n.rotation.set(r),n.scale.set(a),u.updateDisplay()}function ne(){const r=new Uint8Array(96),a=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200];for(let h=0,c=0;h<24;c=(++h/4|0)*3)r.set(a.slice(c,c+3),h*4),r[h*4+3]=255;return G.AddVertexBuffer(l,r,{name:"color",format:"unorm8x4"},void 0,"cubeVertex")}function _(s){w=s,u.name(`Orientation: ${s.Label}`),X()}function Y(s){ee.forEach((r,a)=>r.show(s||j.has(a)))}function Z(s){for(const r of oe)r.domElement.textContent.includes("mesh")&&r.show(s)}function F(s,r,a,h){const c=new ge(G,h??m,s,r);return c.SetRenderPipeline(l),l.AddVertexBuffers(ie),c.Transform=a,c}function ae(s,r){const a=`drawer${r}`,h=L[g]/2-f[g]/2-5,c=F(a,s,[[0,W*r-h,3]]);C.push(c),F(`${a}-drawer-mesh`,c,[void 0,void 0,f],m),F(`${a}-handle-mesh`,c,[te,void 0,D],b)}function he(s,r){const a=`cabinet${r}`,h=F(a,s,[[r*E,0,0]]);F(`${a}-mesh`,h,[void 0,void 0,L],V);for(let c=0;c<p;++c)ae(h,c)}function $(){d||(d=requestAnimationFrame(fe))}function ce(){C.forEach((s,r)=>s.Position[2]=I.Lerp(3,f[2]*.8,Math.sin(O+r)*.5+.5))}function fe(){d=void 0,e.Render(U);const s=n.animate,r=performance.now()*.001,a=x&&r-P||0;P=r,x=s,s&&(O+=a),n.animate&&(ce(),X(),$())}new ResizeObserver(s=>{for(const r of s){const{inlineSize:a,blockSize:h}=r.contentBoxSize[0];e.SetCanvasSize(a,h),A.AspectRatio=e.AspectRatio,q(n.cameraRotation),U.AddCamera(A)}$()}).observe(document.body)})(document.getElementById("lesson"));
