import{D as V,a as s}from"./index-W5DKnw4f.js";var y="struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>projection: mat4x4f;@vertex fn vertex(@location(1)position: vec4f,@location(0)color: vec4f)->VertexOutput{var output: VertexOutput;output.position=projection*position;output.color=color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";function A(){const l=[-50,75,15,-20,75,15,-50,-75,15,-20,-75,15,-20,75,15,50,75,15,-20,45,15,50,45,15,-20,15,15,20,15,15,-20,-15,15,20,-15,15,-50,75,-15,-20,75,-15,-50,-75,-15,-20,-75,-15,-20,75,-15,50,75,-15,-20,45,-15,50,45,-15,-20,15,-15,20,15,-15,-20,-15,-15,20,-15,-15],e=[0,2,1,2,3,1,4,6,5,6,7,5,8,10,9,10,11,9,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23,0,5,12,12,5,17,5,7,17,17,7,19,6,18,7,18,19,7,6,8,18,18,8,20,8,9,20,20,9,21,9,11,21,21,11,23,10,22,11,22,23,11,10,3,22,22,3,15,2,14,3,14,15,3,0,12,2,12,14,2],f=[200,70,120,200,70,120,200,70,120,80,70,200,80,70,200,80,70,200,70,200,210,160,160,220,90,130,110,200,200,70,210,100,70,210,160,70,70,180,210,100,70,210,76,210,100,140,210,80],c=e.length,i=new Float32Array(c*4),a=new Uint8Array(i.buffer);for(let t=0;t<c;t++){let r=e[t]*3;i.set(l.slice(r,r+3),t*4),r=(t/6|0)*3,a.set(f.slice(r,r+3),t*16+12),a[t*16+15]=255}return{vertexData:i,vertices:c}}/**
 * @module Cameras
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cameras
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cameras.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.12
 * @license MIT
 */(async function(l){let e;l.style.backgroundColor="#000";try{e=new(await V.RenderPipeline(l,"Cameras",{alphaMode:"premultiplied"}))}catch(o){alert(o)}const f={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},c=5,i=200,a={fieldOfView:100,cameraAngle:0},t=[],r=new GUI().onChange(x);r.add(a,"fieldOfView",{min:1,max:179}).name("Field of View"),r.add(a,"cameraAngle",f).name("Camera Angle");const{vertexData:h,vertices:m}=A(),p=e.CreateShaderModule(y),{layout:S,buffer:v}=e.CreateVertexBuffer([{name:"position",format:"float32x3"},{name:"color",format:"unorm8x4"}],m);e.CreatePipeline({vertex:e.CreateVertexState(p,void 0,S),depthStencil:e.CreateDepthStencilState(),fragment:e.CreateFragmentState(p),primitive:{cullMode:"back"}}),e.CreatePassDescriptor(e.CreateColorAttachment(),void 0,e.CreateDepthAttachment()),e.WriteBuffer(v,h),e.SetVertexBuffers(v),e.Depth=400;for(let o=0;o<c;++o){const n=e.CreateUniformBuffer("projection");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([{buffer:n.buffer}]))),t.push(n)}function x(){const o=e.UpdatePerspectiveProjection(a.fieldOfView,1,2e3),n=s.rotationY(a.cameraAngle);s.translate(n,[0,0,i*1.5],n);const u=s.inverse(n),d=s.multiply(o,u);t.forEach(({projection:g,buffer:w},C)=>{const b=C/c*Math.PI*2,B=Math.cos(b)*i,D=Math.sin(b)*i;s.translate(d,[B,0,D],g),e.WriteBuffer(w,g),e.SetActiveBindGroups(C),e.Render(m,!1)}),e.Submit()}new ResizeObserver(o=>{for(const n of o){const{inlineSize:u,blockSize:d}=n.contentBoxSize[0];e.SetCanvasSize(u,d)}x()}).observe(document.body)})(document.getElementById("lesson"));
