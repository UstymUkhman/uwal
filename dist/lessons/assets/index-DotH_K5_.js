import{U as R,A,F as u}from"./index-DWxnOMSU.js";import{v as V,m as n}from"./wgpu-matrix.module-D3z0rCw6.js";import{F as O}from"./f-CdSZvatx.js";import{Q as w,C as D}from"./Quad-C4zpvK4p.js";const z=""+new URL("granite-Bhx_bMIh.jpeg",import.meta.url).href;var j="struct Transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@group(0)@binding(2)var<uniform>transform: Transform;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=transform.matrix*vec4f(position,0.0,1.0);output.textureCoord=position*vec2f(1,50);return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}",Y="struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=GetQuadCoord(index);let coord=(position+1)*0.5;var output: VertexOutput;output.position=vec4f(position,0.0,1.0);output.textureCoord=vec2f(coord.x,1-coord.y);return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}";const Q=""+new URL("coins-DSWNLmZu.jpg",import.meta.url).href;/**
 * @module GPU Mipmaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Loading Images into Textures
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html#generating-mips-on-the-gpu}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.5
 * @license MIT
 */(async function(c){let t;try{t=new(await R.RenderPipeline(c,"GPU Mipmaps"))}catch(e){alert(e)}const P=(()=>{let e,o;return r=>{e||(e=t.CreateShaderModule([w,Y]),o=p.CreateSampler({minFilter:u.LINEAR})),t.CreatePipeline({fragment:t.CreateFragmentState(e,"fragment",{format:r.format}),vertex:t.CreateVertexState(e)});let a=0,i=r.width,s=r.height;for(;1<i||1<s;)i=Math.max(i/2|0,1),s=Math.max(s/2|0,1),t.SetBindGroups(t.CreateBindGroup(t.CreateBindGroupEntries([o,r.createView({baseMipLevel:a++,mipLevelCount:1})]))),t.CreatePassDescriptor(t.CreateColorAttachment(r.createView({baseMipLevel:a,mipLevelCount:1}),"clear","store")),t.Render(6)}})(),B=async e=>await p.CreateBitmapImage(await(await fetch(e)).blob(),{colorSpaceConversion:"none"}),p=new(await R.Texture()),l=await Promise.all([d(O,{mipmaps:!0}),d(Q,{mipmaps:!0}),d(z,{mipmaps:!0})]);let m=0;const G=0,v=[],C=1,g=2e3,M=[0,1,0],I=[0,0,0],E=Math.PI*60/180,U=[0,0,2],T=V.set(1.2,.7),f=n.perspective(E,t.AspectRatio,C,g),S=n.inverse(n.lookAt(U,I,M)),h=n.multiply(f,S);t.CreatePipeline({module:t.CreateShaderModule([w,j])});const L=t.CreatePassDescriptor(t.CreateColorAttachment(void 0,"clear","store",new D(5000268).rgba));t.ClearBindGroups();for(let e=0;e<8;e++){const o=p.CreateSampler({addressModeU:A.REPEAT,addressModeV:A.REPEAT,magFilter:e&1?u.LINEAR:u.NEAREST,minFilter:e&2?u.LINEAR:u.NEAREST,mipmapFilter:e&4?u.LINEAR:u.NEAREST}),r=16*Float32Array.BYTES_PER_ELEMENT,a=t.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:r}),i=new Float32Array(r/Float32Array.BYTES_PER_ELEMENT),s=i.subarray(G,16);t.AddBindGroups(l.map(x=>t.CreateBindGroup(t.CreateBindGroupEntries([o,x.createView(),{buffer:a}])))),v.push({matrixBuffer:a,matrixValues:i,matrix:s})}function y(e,o,r=!1){return p.CopyImageToTexture(e,{texture:o,flipY:r}),o.mipLevelCount>1&&P(o),o}function _(e,{mipmaps:o,flip:r}={}){const a=p.CreateTextureFromSource(e,{format:"rgba8unorm",mipmaps:o,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT});return y(e,a,r)}async function d(e,o){const r=await B(e);return _(r,o)}function b(){L.colorAttachments[0].view=t.CurrentTextureView,v.forEach(({matrix:e,matrixBuffer:o,matrixValues:r},a)=>{const s=a%4-1.5,x=+(a<4)*2-1,F=a*l.length+m,N=[s*T[0],x*T[1],-50*.5];n.translate(h,N,e),n.rotateX(e,Math.PI*.5,e),n.scale(e,[1,50*2,1],e),n.translate(e,[-.5,-.5,0],e),t.WriteBuffer(o,r),t.SetActiveBindGroups(F),t.Render(6,!1)}),t.Submit()}new ResizeObserver(e=>{for(const o of e){const{inlineSize:r,blockSize:a}=o.contentBoxSize[0];t.SetCanvasSize(r,a)}n.perspective(E,t.AspectRatio,C,g,f),n.multiply(f,S,h),b()}).observe(c),c.addEventListener("click",()=>{m=(m+1)%l.length,b()})})(document.getElementById("lesson"));
