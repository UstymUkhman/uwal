import{U as R}from"./index-CT6toc-h.js";var m="struct ConstStruct{color: vec4f,offset: vec2f};struct VarStruct{scale: vec2f};struct VertStruct{position: vec2f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@group(0)@binding(0)var<storage,read>constStructs: array<ConstStruct>;@group(0)@binding(1)var<storage,read>varStructs: array<VarStruct>;@group(0)@binding(2)var<storage,read>vertStructs: array<VertStruct>;@vertex fn vertex(@builtin(vertex_index)vertex: u32,@builtin(instance_index)instance: u32)->VertexOutput{let constStruct=constStructs[instance];let varStruct=varStructs[instance];var output: VertexOutput;output.position=vec4f(vertStructs[vertex].position*varStruct.scale+constStruct.offset,0.0,1.0);output.color=constStruct.color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Storage Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Storage Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.4
 * @license MIT
 */(async function(f){let t;try{t=new(await R.RenderPipeline(f,"Storage Buffers"))}catch(e){alert(e)}const M=0,O=4,F=0,u=100,p=[],w=t.CreatePassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),d=t.CreateShaderModule(m);t.CreatePipeline({vertex:t.CreateVertexState(d),fragment:t.CreateFragmentState(d)});const C=4*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT,_=C*u,b=2*Float32Array.BYTES_PER_ELEMENT,P=b*u,{vertexData:T,vertices:Y}=D({innerRadius:.25,outerRadius:.5}),h=t.CreateBuffer({label:"Constant Storage Buffer",size:_,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),y=t.CreateBuffer({label:"Variable Storage Buffer",size:P,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=t.CreateBuffer({label:"Vertices Storage Buffer",size:T.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});t.WriteBuffer(V,T);{const e=new Float32Array(_/Float32Array.BYTES_PER_ELEMENT);for(let r=0;r<u;++r){const o=C/4*r;e.set([c(),c(),c(),1],o+M),e.set([c(-.9,.9),c(-.9,.9)],o+O),p.push({scale:c(.2,.5)})}t.WriteBuffer(h,e)}const x=new Float32Array(P/Float32Array.BYTES_PER_ELEMENT),L=t.CreateBindGroup(t.CreateBindGroupEntries([{buffer:h},{buffer:y},{buffer:V}]));t.SetBindGroups(L);function D({endAngle:e=Math.PI*2,subdivisions:r=24,innerRadius:o=0,outerRadius:a=1,startAngle:S=0}){const A=r*3*2,l=new Float32Array(A*2);let U=0;const s=(n,i)=>{l[U++]=n,l[U++]=i},z=e-S;for(let n=0;n<r;n++){const i=S+(n+0)*z/r,G=S+(n+1)*z/r,g=Math.cos(i),E=Math.sin(i),v=Math.cos(G),B=Math.sin(G);s(g*o,E*o),s(v*o,B*o),s(v*a,B*a),s(v*a,B*a),s(g*a,E*a),s(g*o,E*o)}return{vertexData:l,vertices:A}}function c(e,r){return e===void 0?(e=0,r=1):r===void 0&&(r=e,e=0),Math.random()*(r-e)+e}function N(){t.SetCanvasSize(f.width,f.height);const e=t.AspectRatio;w.colorAttachments[0].view=t.CurrentTextureView,p.forEach(({scale:r},o)=>{const a=b/4*o;x.set([r/e,r],a+F)}),t.WriteBuffer(y,x),t.Render([Y,u])}new ResizeObserver(e=>{for(const r of e){const{inlineSize:o,blockSize:a}=r.contentBoxSize[0];t.SetCanvasSize(o,a)}N()}).observe(f)})(document.getElementById("lesson"));
