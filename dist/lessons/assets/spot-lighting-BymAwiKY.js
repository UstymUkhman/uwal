import{a as e,c as t,d as n,f as r,i,n as a,u as o}from"./lib-CYVhTx45.js";import{t as s}from"./F-WmVUQw7f.js";var c=`struct Uniforms{color: vec4f,light: vec3f,camera: vec3f,world: mat4x4f,normal: mat3x3f,direction: vec3f,intensity: f32,limit: vec2f};struct VertexOutput{@location(0)normal: vec3f,@location(1)lightVector: vec3f,@location(2)cameraVector: vec3f,@builtin(position)position: vec4f};@group(0)@binding(1)var<uniform>uniforms: Uniforms;@group(0)@binding(0)var<uniform>meshModelViewProjection: mat4x4f;@vertex fn vertex(@location(0)position: vec4f,@location(1)normal: vec3f)->VertexOutput {var output: VertexOutput;let worldPosition=(uniforms.world*position).xyz;output.lightVector=uniforms.light-worldPosition;output.cameraVector=uniforms.camera-worldPosition;output.position=meshModelViewProjection*position;output.normal=uniforms.normal*normal;return output;}@fragment fn fragment(vertex: VertexOutput)->@location(0)vec4f {let normal=normalize(vertex.normal);let lightDirection=normalize(vertex.lightVector);let direction=dot(lightDirection,-uniforms.direction);let inside=smoothstep(uniforms.limit.y,uniforms.limit.x,direction);let light=dot(normal,lightDirection)*inside;let cameraDirection=normalize(vertex.cameraVector);var specular=dot(normal,normalize(lightDirection+cameraDirection));specular=pow(max(0,specular),uniforms.intensity)*inside;let color=uniforms.color.rgb*light+specular;return vec4f(color,uniforms.color.a);}`;(async function(l){let u;try{u=new(await(r.Renderer(l,`Spot Lighting`)))}catch(e){alert(e)}let d=new e,f=new GUI;f.onChange(k);let p=new a,m=new t,h=new i(m,null),g=new u.Pipeline;u.CreatePassDescriptor(u.CreateColorAttachment(),u.CreateDepthStencilAttachment());let _={innerLimit:n.DegreesToRadians(15),outerLimit:n.DegreesToRadians(25),rotation:n.DegreesToRadians(0),limit:n.DegreesToRadians(15),aimOffsetX:-10,aimOffsetY:10,shininess:30},v=g.CreateShaderModule(c),{uniforms:y,buffer:b}=g.CreateUniformBuffer(`uniforms`),x={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},S={min:0,max:90,minRange:1,step:1,converters:GUI.converters.radToDeg},C=[g.CreateVertexBufferLayout({name:`position`,format:`float32x3`}),g.CreateVertexBufferLayout({name:`normal`,format:`float32x3`})],{vertexData:w,normalData:T,vertices:E}=s(),D=g.CreateVertexBuffer(T);h.SetRenderPipeline(await u.AddPipeline(g,{vertex:g.CreateVertexState(v,C),depthStencil:g.CreateDepthStencilState(),fragment:g.CreateFragmentState(v),primitive:g.CreatePrimitiveState()}),b),f.add(_,`rotation`,x),f.add(_,`shininess`,{min:1,max:250}),GUI.makeMinMaxPair(f,_,`innerLimit`,`outerLimit`,S),f.add(_,`aimOffsetX`,-50,50),f.add(_,`aimOffsetY`,-50,50),m.CreateVertexBuffer(g,w),g.WriteBuffer(D,T),g.AddVertexBuffers(D),m.SetDrawParams(E),y.color.set(new o(3407667).rgba),y.light.set([-10,30,100]);let O=[0,35,0];d.Add(h);function k(){y.camera.set(p.Position),y.intensity[0]=_.shininess,y.limit[0]=Math.cos(_.innerLimit),y.limit[1]=Math.cos(_.outerLimit);let{aimOffsetX:e,aimOffsetY:t}=_,r=[O[0]+e,O[1]+t,O[2]];y.direction.set(n.Mat4.aim(y.light,r,[0,1,0]).slice(8,11));let i=n.Mat4.rotationY(_.rotation,y.world);n.Mat3.fromMat4(n.Mat4.transpose(n.Mat4.inverse(i)),y.normal),g.WriteBuffer(b,y.normal.buffer),h.Rotation=[0,_.rotation,0],u.Render(d)}new ResizeObserver(e=>{for(let t of e){let{inlineSize:e,blockSize:n}=t.contentBoxSize[0];u.SetCanvasSize(e,n),p.AspectRatio=u.AspectRatio,p.UpdateViewProjectionMatrix(),p.Position=[100,150,200],p.LookAt(O),d.AddCamera(p)}k()}).observe(document.body)})(document.getElementById(`lesson`));