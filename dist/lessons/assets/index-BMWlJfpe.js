import{U as f}from"./index-BEcPMtkb.js";var W="struct ConstStruct{color: vec4f,offset: vec2f};struct VarStruct{scale: vec2f};struct VertStruct{position: vec2f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@group(0)@binding(0)var<storage,read>constStructs: array<ConstStruct>;@group(0)@binding(1)var<storage,read>varStructs: array<VarStruct>;@group(0)@binding(2)var<storage,read>vertStructs: array<VertStruct>;@vertex fn vertex(@builtin(vertex_index)vertex: u32,@builtin(instance_index)instance: u32)->VertexOutput{let constStruct=constStructs[instance];let varStruct=varStructs[instance];var output: VertexOutput;output.position=vec4f(vertStructs[vertex].position*varStruct.scale+constStruct.offset,0.0,1.0);output.color=constStruct.color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Storage Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Storage Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.3
 * @license MIT
 */(async function(u){let t;try{t=new(await f.RenderPipeline(u,"Storage Buffers"))}catch(r){alert(r)}const F=0,w=4,Y=0,i=100,d=[],C=t.CreateRenderPassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),_=t.CreateShaderModule(W),m=t.CreateRenderPipeline({vertex:t.CreateVertexState(_),fragment:t.CreateFragmentState(_)}),b=4*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT,P=b*i,T=2*Float32Array.BYTES_PER_ELEMENT,h=T*i,{vertexData:y,vertices:L}=D({innerRadius:.25,outerRadius:.5}),x=t.CreateBuffer({label:"Constant Storage Buffer",size:P,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=t.CreateBuffer({label:"Variable Storage Buffer",size:h,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),A=t.CreateBuffer({label:"Vertices Storage Buffer",size:y.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});t.WriteBuffer(A,y);{const r=new Float32Array(P/Float32Array.BYTES_PER_ELEMENT);for(let e=0;e<i;++e){const o=b/4*e;r.set([c(),c(),c(),1],o+F),r.set([c(-.9,.9),c(-.9,.9)],o+w),d.push({scale:c(.2,.5)})}t.WriteBuffer(x,r)}const U=new Float32Array(h/Float32Array.BYTES_PER_ELEMENT),R=t.CreateBindGroup(t.CreateBindGroupEntries([{buffer:x},{buffer:V},{buffer:A}]));t.SetBindGroups(R);function D({endAngle:r=Math.PI*2,subdivisions:e=24,innerRadius:o=0,outerRadius:a=1,startAngle:l=0}){const z=e*3*2,g=new Float32Array(z*2);let G=0;const n=(s,S)=>{g[G++]=s,g[G++]=S},M=r-l;for(let s=0;s<e;s++){const S=l+(s+0)*M/e,O=l+(s+1)*M/e,E=Math.cos(S),v=Math.sin(S),B=Math.cos(O),p=Math.sin(O);n(E*o,v*o),n(B*o,p*o),n(B*a,p*a),n(B*a,p*a),n(E*a,v*a),n(E*o,v*o)}return{vertexData:g,vertices:z}}function c(r=0,e=1){return e===void 0&&(e=r,r=0),Math.random()*(e-r)+r}function N(){f.SetCanvasSize(u.width,u.height);const r=f.AspectRatio;C.colorAttachments[0].view=f.CurrentTextureView,d.forEach(({scale:e},o)=>{const a=T/4*o;U.set([e/r,e],a+Y)}),t.WriteBuffer(V,U),t.Render(C,m,[L,i])}new ResizeObserver(r=>{for(const e of r){const{inlineSize:o,blockSize:a}=e.contentBoxSize[0];f.SetCanvasSize(o,a)}N()}).observe(u)})(document.getElementById("lesson"));
