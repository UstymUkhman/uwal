var Y=i=>{throw TypeError(i)};var U=(i,e,r)=>e.has(i)||Y("Cannot "+r);var t=(i,e,r)=>(U(i,e,"read from private field"),r?r.call(i):e.get(i)),p=(i,e,r)=>e.has(i)?Y("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,r),c=(i,e,r,l)=>(U(i,e,"write to private field"),l?l.call(i,r):e.set(i,r),r),x=(i,e,r)=>(U(i,e,"access private method"),r);import{T as re,E as ie,b as ne,a as h,D as oe}from"./index-sDmynApN.js";import{P as se}from"./PerspectiveCamera-CKyxE2MN.js";var y,d,P,o,B,u,j,I,T;class ae{constructor(e){p(this,u);p(this,y,new Float32Array([.5,.5,.75,.5,.5,1,.75,1,.25,.5,.5,.5,.25,1,.5,1,0,0,0,.5,.25,0,.25,.5,.5,0,.5,.5,.75,0,.75,.5,0,.5,.25,.5,0,1,.25,1,.25,0,.5,0,.25,.5,.5,.5]));p(this,d);p(this,P,new Float32Array(16));p(this,o);p(this,B);c(this,d,e??"Cube")}async CreatePipeline(e,r){const l=`${t(this,d)} Pipeline`;return Array.isArray(r)||typeof r=="string"?r={shader:r,pipelineName:l}:r instanceof GPUShaderModule?r={module:r,pipelineName:l}:r.pipelineName??(r.pipelineName=l),c(this,o,await e.CreatePipeline(r)),x(this,u,j).call(this),x(this,u,I).call(this),x(this,u,T).call(this),t(this,o)}AddVertexBuffers(e,r,l){!t(this,o)&&re(ie.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Use `Cube.CreatePipeline` or `Cube.SetRenderPipeline` method before adding vertex buffers."),t(this,o).AddVertexBuffers(e,r,l)}SetRenderPipeline(e){c(this,o,e),x(this,u,j).call(this),x(this,u,I).call(this),x(this,u,T).call(this)}Update(){t(this,o).WriteBuffer(t(this,B),t(this,P))}get PositionAttribute(){return{name:"position",format:"float32x3"}}get TransformBuffer(){return t(this,B)}get Transform(){return t(this,P)}get Pipeline(){return t(this,o)}get UV(){return t(this,y)}Destroy(){t(this,o).Destroy(),t(this,B).destroy(),c(this,B,void 0)}}y=new WeakMap,d=new WeakMap,P=new WeakMap,o=new WeakMap,B=new WeakMap,u=new WeakSet,j=function(){c(this,B,t(this,o).CreateBuffer({size:t(this,P).length*Float32Array.BYTES_PER_ELEMENT,label:`${t(this,d)} Uniform Buffer`,usage:ne.UNIFORM}))},I=function(){const e=new Float32Array([-.5,.5,.5,.5,.5,.5,-.5,.5,-.5,.5,.5,-.5,.5,-.5,.5,-.5,-.5,.5,.5,-.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,-.5,.5,.5,.5,.5,.5,-.5,.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,-.5,-.5,.5,.5,-.5,.5,-.5,-.5,-.5,.5,-.5,-.5,-.5,.5,.5,-.5,.5,.5,.5,.5,-.5,-.5,.5,-.5,.5]),r=t(this,o).CreateVertexBuffer(e,{label:`${t(this,d)} Vertex Buffer`});t(this,o).WriteBuffer(r,e),t(this,o).SetVertexBuffers(r)},T=function(){const e=new Uint16Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]),r=t(this,o).CreateIndexBuffer(e,{label:`${t(this,d)} Index Buffer`});t(this,o).WriteBuffer(r,e),t(this,o).SetIndexBuffer(r,"uint16"),t(this,o).SetDrawParams(e.length)};var n,m;class ue{constructor(){p(this,n,h.identity());p(this,m,[])}Push(){return t(this,m).push(t(this,n)),c(this,n,h.copy(t(this,n))),this}Pop(){return c(this,n,t(this,m).pop()),this}Translate(e){return h.translate(t(this,n),e,t(this,n)),this}RotateX(e){return h.rotateX(t(this,n),e,t(this,n)),this}RotateY(e){return h.rotateY(t(this,n),e,t(this,n)),this}RotateZ(e){return h.rotateZ(t(this,n),e,t(this,n)),this}Scale(e){return h.scale(t(this,n),e,t(this,n)),this}Set(e){return t(this,n).set(e)}Get(){return t(this,n)}Reset(){return c(this,n,h.identity()),c(this,m,[]),this}}n=new WeakMap,m=new WeakMap;var fe="struct VertexInput{@location(0)position: vec4f,@location(1)color: vec4f};struct VertexOutput{@location(0)color: vec4f,@builtin(position)position: vec4f};@group(0)@binding(0)var<uniform>color: vec4f;@group(0)@binding(1)var<uniform>projection: mat4x4f;@vertex fn vertex(input: VertexInput)->VertexOutput {var output: VertexOutput;output.position=projection*input.position;output.color=input.color;return output;}@fragment fn fragment(input: VertexOutput)->@location(0)vec4f {return input.color*color;}";/**
 * @module Matrix Stacks
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cameras
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.1.0
 * @license MIT
 */(async function(i){let e;i.style.backgroundColor="#000";try{e=new(await oe.Renderer(i,"Matrix Stacks",{alphaMode:"premultiplied"}))}catch(f){alert(f)}const r={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},[l,E,O]=[0,1,2],$=[.5,.5,.5,1],D=[1,1,1,1],g=[40,30,50],G=[10,2,2],V=[];let R=0;h.create();const a=new ue,M={baseRotation:0};new GUI().onChange(L).add(M,"baseRotation",r);const S=new se(60,1,2e3);S.Position=[0,20,100],S.LookAt([0,20,0]);const X=S.UpdateViewProjection(!1),Z=[0,g[E]/3*2-g[E]/2,G[O]/2+g[O]/2];e.CreatePassDescriptor(e.CreateColorAttachment(),e.CreateDepthStencilAttachment());const v=new ae,s=new e.Pipeline,k=s.CreateShaderModule(fe),{layout:q,buffer:z}=s.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);v.SetRenderPipeline(await e.AddPipeline(s,{primitive:{cullMode:"back"},fragment:s.CreateFragmentState(k),depthStencil:s.CreateDepthStencilState(),vertex:s.CreateVertexState(k,void 0,[s.CreateVertexBufferLayout(v.PositionAttribute),q])}));const H=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],F=v.UV.length/2,A=new Uint8Array(F*4);for(let f=0,b=0;f<F;b=(++f/4|0)*3){const C=H.slice(b,b+3);A.set(C,f*4),A[f*4+3]=255}s.WriteBuffer(z,A),v.AddVertexBuffers(z);function N(f,b){if(R===V.length){const{color:K,buffer:Q}=s.CreateUniformBuffer("color"),{projection:ee,buffer:te}=s.CreateUniformBuffer("projection");V.push({projectionValue:ee,projectionBuffer:te,colorValue:K,colorBuffer:Q})}const{projectionValue:C,projectionBuffer:w,colorValue:W,colorBuffer:_}=V[R++];W.set(b),s.WriteBuffer(_,W),h.multiply(X,f,C),s.WriteBuffer(w,C),s.SetBindGroups(s.CreateBindGroup(s.CreateBindGroupEntries([_,w]))),e.Render(!1)}function J(){a.Push(),a.Scale(g),N(a.Get(),D),a.Pop(),a.Push(),a.Translate(Z),a.Scale(G),N(a.Get(),$),a.Pop()}function L(){a.Push(),a.RotateY(M.baseRotation),R=0,J(),a.Pop(),e.Submit()}new ResizeObserver(f=>{for(const b of f){const{inlineSize:C,blockSize:w}=b.contentBoxSize[0];e.SetCanvasSize(C,w),S.AspectRatio=e.AspectRatio,S.UpdateViewProjection(!1)}L()}).observe(document.body)})(document.getElementById("lesson"));
