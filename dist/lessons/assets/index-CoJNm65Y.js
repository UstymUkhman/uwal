import{U as f}from"./index-DEecJYvT.js";var I="struct ConstStruct{color: vec4f,offset: vec2f};struct VarStruct{scale: vec2f};struct VertStruct{position: vec2f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@group(0)@binding(0)var<storage,read>constStructs: array<ConstStruct>;@group(0)@binding(1)var<storage,read>varStructs: array<VarStruct>;@group(0)@binding(2)var<storage,read>vertStructs: array<VertStruct>;@vertex fn vertex(@builtin(vertex_index)vertex: u32,@builtin(instance_index)instance: u32)->VertexOutput{let constStruct=constStructs[instance];let varStruct=varStructs[instance];var output: VertexOutput;output.position=vec4f(vertStructs[vertex].position*varStruct.scale+constStruct.offset,0.0,1.0);output.color=constStruct.color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Storage Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Storage Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.2
 * @license MIT
 */(async function(u){let t;try{t=new(await f.RenderPipeline(u,"Storage Buffers"))}catch(r){alert(r)}const w=0,L=4,Y=0,i=100,d=[],C=t.CreateRenderPassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),_=t.CreateShaderModule(I),b=t.CreateRenderPipeline({vertex:t.CreateVertexState(_),fragment:t.CreateFragmentState(_)}),y=4*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT,P=y*i,T=2*Float32Array.BYTES_PER_ELEMENT,h=T*i,{vertexData:x,vertices:m}=N({innerRadius:.25,outerRadius:.5}),A=t.CreateBuffer({label:"Constant Storage Buffer",size:P,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=t.CreateBuffer({label:"Variable Storage Buffer",size:h,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),G=t.CreateBuffer({label:"Vertices Storage Buffer",size:x.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});t.WriteBuffer(G,x);{const r=new Float32Array(P/Float32Array.BYTES_PER_ELEMENT);for(let e=0;e<i;++e){const o=y/4*e;r.set([n(),n(),n(),1],o+w),r.set([n(-.9,.9),n(-.9,.9)],o+L),d.push({scale:n(.2,.5)})}t.WriteBuffer(A,r)}const U=new Float32Array(h/Float32Array.BYTES_PER_ELEMENT),R=t.CreateBindGroupEntries([{buffer:A},{buffer:V},{buffer:G}]),D=t.CreateBindGroup({layout:b.getBindGroupLayout(0),entries:R});function N({endAngle:r=Math.PI*2,subdivisions:e=24,innerRadius:o=0,outerRadius:a=1,startAngle:l=0}){const z=e*3*2,g=new Float32Array(z*2);let M=0;const c=(s,S)=>{g[M++]=s,g[M++]=S},O=r-l;for(let s=0;s<e;s++){const S=l+(s+0)*O/e,F=l+(s+1)*O/e,E=Math.cos(S),v=Math.sin(S),B=Math.cos(F),p=Math.sin(F);c(E*o,v*o),c(B*o,p*o),c(B*a,p*a),c(B*a,p*a),c(E*a,v*a),c(E*o,v*o)}return{vertexData:g,vertices:z}}function n(r=0,e=1){return e===void 0&&(e=r,r=0),Math.random()*(e-r)+r}function W(){f.SetCanvasSize(u.width,u.height);const r=f.AspectRatio;C.colorAttachments[0].view=f.CurrentTextureView,d.forEach(({scale:e},o)=>{const a=T/4*o;U.set([e/r,e],a+Y)}),t.AddBindGroups(D),t.WriteBuffer(V,U),t.Render(C,b,[m,i])}new ResizeObserver(r=>{for(const e of r){const{inlineSize:o,blockSize:a}=e.contentBoxSize[0];f.SetCanvasSize(o,a)}W()}).observe(u)})(document.getElementById("lesson"));
