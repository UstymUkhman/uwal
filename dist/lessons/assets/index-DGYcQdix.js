import{D as N}from"./index-BEuvW3M9.js";var R="struct ConstStruct{color: vec4f,offset: vec2f};struct VarStruct{scale: vec2f};struct VertStruct{position: vec2f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@group(0)@binding(0)var<storage,read>constStructs: array<ConstStruct>;@group(0)@binding(1)var<storage,read>varStructs: array<VarStruct>;@group(0)@binding(2)var<storage,read>vertStructs: array<VertStruct>;@vertex fn vertex(@builtin(vertex_index)vertex: u32,@builtin(instance_index)instance: u32)->VertexOutput{let constStruct=constStructs[instance];let varStruct=varStructs[instance];var output: VertexOutput;output.position=vec4f(vertStructs[vertex].position*varStruct.scale+constStruct.offset,0.0,1.0);output.color=constStruct.color;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Storage Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Storage Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-storage-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.4
 * @license MIT
 */(async function(O){let t;try{t=new(await N.RenderPipeline(O,"Storage Buffers"))}catch(e){alert(e)}const z=0,U=4,F=0,f=100,B=[],Y=t.CreatePassDescriptor(t.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),p=t.CreateShaderModule(R);t.CreatePipeline({vertex:t.CreateVertexState(p),fragment:t.CreateFragmentState(p)});const d=4*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT+2*Float32Array.BYTES_PER_ELEMENT,C=d*f,_=2*Float32Array.BYTES_PER_ELEMENT,b=_*f,{vertexData:P,vertices:w}=L({innerRadius:.25,outerRadius:.5}),T=t.CreateBuffer({label:"Constant Storage Buffer",size:C,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),y=t.CreateBuffer({label:"Variable Storage Buffer",size:b,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),V=t.CreateBuffer({label:"Vertices Storage Buffer",size:P.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});t.WriteBuffer(V,P);{const e=new Float32Array(C/Float32Array.BYTES_PER_ELEMENT);for(let r=0;r<f;++r){const o=d/4*r;e.set([c(),c(),c(),1],o+z),e.set([c(-.9,.9),c(-.9,.9)],o+U),B.push({scale:c(.2,.5)})}t.WriteBuffer(T,e)}const h=new Float32Array(b/Float32Array.BYTES_PER_ELEMENT),D=t.CreateBindGroup(t.CreateBindGroupEntries([{buffer:T},{buffer:y},{buffer:V}]));t.SetBindGroups(D);function L({endAngle:e=Math.PI*2,subdivisions:r=24,innerRadius:o=0,outerRadius:a=1,startAngle:i=0}){const x=r*3*2,S=new Float32Array(x*2);let A=0;const s=(n,u)=>{S[A++]=n,S[A++]=u},G=e-i;for(let n=0;n<r;n++){const u=i+(n+0)*G/r,M=i+(n+1)*G/r,l=Math.cos(u),v=Math.sin(u),g=Math.cos(M),E=Math.sin(M);s(l*o,v*o),s(g*o,E*o),s(g*a,E*a),s(g*a,E*a),s(l*a,v*a),s(l*o,v*o)}return{vertexData:S,vertices:x}}function c(e,r){return e===void 0?(e=0,r=1):r===void 0&&(r=e,e=0),Math.random()*(r-e)+e}function m(){const e=t.AspectRatio;Y.colorAttachments[0].view=t.CurrentTextureView,B.forEach(({scale:r},o)=>{const a=_/4*o;h.set([r/e,r],a+F)}),t.WriteBuffer(y,h),t.Render([w,f])}new ResizeObserver(e=>{for(const r of e){const{inlineSize:o,blockSize:a}=r.contentBoxSize[0];t.SetCanvasSize(o,a)}m()}).observe(document.body)})(document.getElementById("lesson"));
