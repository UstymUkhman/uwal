var L=Object.defineProperty;var Q=(s,e,t)=>e in s?L(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var F=(s,e,t)=>(Q(s,typeof e!="symbol"?e+"":e,t),t),S=(s,e,t)=>{if(!e.has(s))throw TypeError("Cannot "+t)};var a=(s,e,t)=>(S(s,e,"read from private field"),t?t.call(s):e.get(s)),u=(s,e,t)=>{if(e.has(s))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(s):e.set(s,t)},O=(s,e,t,n)=>(S(s,e,"write to private field"),n?n.call(s,t):e.set(s,t),t);var R=(s,e,t)=>(S(s,e,"access private method"),t);function V(s){const e={};for(let t in s)e[t]={value:s[t]};return Object.freeze(Object.create(null,e))}const W=V({DEVICE_LOST:"Device::Lost"}),C=V({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND"}),G=V({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost.",CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder."}),X=V({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7});function $(s,e){console.warn(G[s]+(e??""))}function d(s,e){throw new Error(G[s]+(e??""),{cause:X[s]})}var p,h;class I{constructor(e,t){u(this,p,void 0);F(this,"Device");F(this,"BindGroups",[]);u(this,h,void 0);!e&&d(C.DEVICE_NOT_REQUESTED),this.Device=e,O(this,p,t)}CreateBuffer(e){return this.Device.createBuffer(e)}WriteBuffer(e,t,n=0,i,o){this.Device.queue.writeBuffer(e,n,t,i,o)}CopyBufferToBuffer(e,t,n,i=0,o=0){this.CommandEncoder.copyBufferToBuffer(e,i,t,o,n)}CreateShaderModule(e,t="",n,i){const o=Array.isArray(e)&&e.join(`

`)||e;return this.Device.createShaderModule({label:t,code:o,sourceMap:n,compilationHints:i})}CreateBindGroupEntries(e){return Array.isArray(e)&&e.map((t,n)=>({binding:n,resource:t}))||[{binding:0,resource:e}]}CreateBindGroup(e){return this.Device.createBindGroup(e)}AddBindGroups(e){this.BindGroups=Array.isArray(e)&&e||[e]}CreateCommandEncoder(){return O(this,h,this.Device.createCommandEncoder({label:a(this,p)}))}SubmitCommandBuffer(){this.Device.queue.submit([this.CommandEncoder.finish()])}get CommandEncoder(){if(!a(this,h)){const e=` ${a(this,p)&&`Label: "${a(this,p)}". `}`;return $(C.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one."),this.CreateCommandEncoder()}return a(this,h)}}p=new WeakMap,h=new WeakMap;var A,D;class j extends I{constructor(t,n,i){super(t,n);u(this,A,void 0);u(this,D,void 0);O(this,A,i)}CreateColorAttachment(t,n="load",i="store",o,c,T){return{view:t,loadOp:n,storeOp:i,clearValue:o,resolveTarget:c,depthSlice:T}}CreateRenderPassDescriptor(t,n="",i,o,c,T){return{colorAttachments:Array.isArray(t)&&t||[t],depthStencilAttachment:i,occlusionQuerySet:o,timestampWrites:c,maxDrawCount:T,label:n}}CreateVertexState(t,n="vertex",i,o){return{module:t,entryPoint:n,constants:i,buffers:o}}CreateFragmentState(t,n="fragment",i,o){return i??(i=[{format:a(this,A)}]),{module:t,entryPoint:n,targets:i,constants:o}}CreateRenderPipeline(t){const n=t.layout??"auto";return this.Device.createRenderPipeline({...t,layout:n})}Render(t,n,i,o=!0){if(!a(this,D)){const c=this.CreateCommandEncoder();O(this,D,c.beginRenderPass(t)),a(this,D).setPipeline(n)}for(let c=0,T=this.BindGroups.length;c<T;++c)a(this,D).setBindGroup(c,this.BindGroups[c]);a(this,D).draw(...Array.isArray(i)&&i||[i]),o&&(a(this,D).end(),O(this,D,void 0),this.SubmitCommandBuffer())}get CurrentPass(){return a(this,D)}}A=new WeakMap,D=new WeakMap;var g;class k extends I{constructor(t,n){super(t,n);u(this,g,[1])}CreateComputePassDescriptor(t="",n,i,o){return{label:t,timestampWrites:n?{querySet:n,beginningOfPassWriteIndex:i,endOfPassWriteIndex:o}:void 0}}CreateComputePipeline(t){const n=t.layout??"auto";return this.Device.createComputePipeline({label:t.label,layout:n,compute:t})}Compute(t,n){const i=this.CommandEncoder.beginComputePass(n);i.setPipeline(t);for(let o=0,c=this.BindGroups.length;o<c;++o)i.setBindGroup(o,this.BindGroups[o]);i.dispatchWorkgroups(...a(this,g)),i.end()}set Workgroups(t){O(this,g,Array.isArray(t)&&t||[t])}}g=new WeakMap;/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.1
 * @license MIT
 */var f,N,E,l,v,P,m,U,M,_,b,y,x;const r=class r{static SetAdapterOptions(e=void 0,t=!1){a(r,P).powerPreference=e,a(r,P).forceFallbackAdapter=t}static SetDeviceDescriptor(e="",t=[],n={}){a(r,m).label=e,a(r,m).requiredFeatures=t,a(r,m).requiredLimits=n}static SetCanvasSize(e=innerWidth,t=innerHeight){!a(r,E)&&d(C.CANVAS_NOT_FOUND),!a(r,N)&&d(C.DEVICE_NOT_FOUND);const{maxTextureDimension2D:n}=a(r,N).limits;e=Math.max(1,Math.min(e,n)),t=Math.max(1,Math.min(t,n)),(a(r,E).width!==e||a(r,E).height!==t)&&(a(r,E).height=t,a(r,E).width=e)}static RenderPipeline(e,t="",n={}){return(async()=>{const i=await r.Device,o=e.getContext("webgpu");!o&&d(C.CONTEXT_NOT_FOUND);const c=n.format??a(r,v),T={...n,format:c};return o.configure({device:i,...T}),O(r,E,e),O(r,l,o),new Proxy(j,{construct(w){return new w(i,t,c)}})})()}static ComputePipeline(e=""){return(async()=>{const t=await r.Device;return new Proxy(k,{construct(n){return new n(t,e)}})})()}static Destroy(e,t,n){var i,o;e=Array.isArray(e)&&e||[e],e.forEach(c=>c==null?void 0:c.destroy()),t=Array.isArray(t)&&t||[t],t.forEach(c=>c==null?void 0:c.destroy()),n=Array.isArray(n)&&n||[n],n.forEach(c=>c==null?void 0:c.destroy()),(i=a(r,l))==null||i.unconfigure(),(o=a(r,N))==null||o.destroy()}static get Adapter(){return(async()=>{var e;return a(r,f)??await R(e=r,U,M).call(e)()})()}static get Device(){return(async()=>{var e;return a(r,N)??await R(e=r,_,b).call(e)()})()}static get Canvas(){return a(r,E)}static get Context(){return a(r,l)}static get AspectRatio(){return!a(r,E)&&d(C.CANVAS_NOT_FOUND),a(r,E).width/a(r,E).height}static get CurrentTexture(){return a(r,l).getCurrentTexture()}static get CurrentTextureView(){return r.CurrentTexture.createView()}static get VERSION(){return"0.0.1"}};f=new WeakMap,N=new WeakMap,E=new WeakMap,l=new WeakMap,v=new WeakMap,P=new WeakMap,m=new WeakMap,U=new WeakSet,M=function(){return!navigator.gpu&&d(C.WEBGPU_NOT_SUPPORTED),O(r,v,navigator.gpu.getPreferredCanvasFormat()),async()=>{const e=await navigator.gpu.requestAdapter(a(r,P));return!e&&d(C.ADAPTER_NOT_FOUND),O(r,f,e)}},_=new WeakSet,b=function(){return async()=>{const{requiredFeatures:e,requiredLimits:t,label:n}=a(r,m),i=await(await r.Adapter).requestDevice({requiredFeatures:e,requiredLimits:t,defaultQueue:{label:n}});return!i&&d(C.DEVICE_NOT_FOUND),i.lost.then(R(r,y,x)),O(r,N,i)}},y=new WeakSet,x=function(e){if(r.OnDeviceLost)return r.OnDeviceLost(e);a(r,E).dispatchEvent(new CustomEvent(W.DEVICE_LOST,{detail:e}));const t=(e.message&&` | Message: ${e.message}`)??".";d(C.DEVICE_LOST,` Reason: ${e.reason}`+t)},u(r,U),u(r,_),u(r,y),u(r,f,null),u(r,N,null),u(r,E,void 0),u(r,l,void 0),u(r,v,void 0),u(r,P,{powerPreference:void 0,forceFallbackAdapter:!1}),u(r,m,{label:"",requiredFeatures:[],requiredLimits:{}}),F(r,"OnDeviceLost");let B=r;console.info(`%cUWAL v${B.VERSION}`,"background:#005a9c;padding:3px;color:#fff;");export{B as U};
