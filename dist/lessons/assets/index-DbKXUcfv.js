var pe=Object.defineProperty;var le=(u,t,e)=>t in u?pe(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var F=(u,t,e)=>(le(u,typeof t!="symbol"?t+"":t,e),e),ee=(u,t,e)=>{if(!t.has(u))throw TypeError("Cannot "+e)};var s=(u,t,e)=>(ee(u,t,"read from private field"),e?e.call(u):t.get(u)),h=(u,t,e)=>{if(t.has(u))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(u):t.set(u,e)},c=(u,t,e,r)=>(ee(u,t,"write to private field"),r?r.call(u,e):t.set(u,e),e);var D=(u,t,e)=>(ee(u,t,"access private method"),e);function m(u){for(let t in u)u[t]={value:u[t]};return Object.freeze(Object.create(null,u))}const de={CANVAS_NOT_FOUND:"CANVAS_NOT_FOUND",CONTEXT_NOT_FOUND:"CONTEXT_NOT_FOUND",COMMAND_ENCODER_NOT_FOUND:"COMMAND_ENCODER_NOT_FOUND",VERTEX_STATE_NOT_FOUND:"VERTEX_STATE_NOT_FOUND",PIPELINE_NOT_FOUND:"PIPELINE_NOT_FOUND"},Te={CANVAS_NOT_FOUND:"Failed to get a WebGPU canvas.",CONTEXT_NOT_FOUND:"Failed to get a WebGPU context.",COMMAND_ENCODER_NOT_FOUND:"Failed to get a GPUCommandEncoder.",VERTEX_STATE_NOT_FOUND:"Failed to get a GPUVertexState.",PIPELINE_NOT_FOUND:"Failed to get a GPU"},De={CANVAS_NOT_FOUND:5,CONTEXT_NOT_FOUND:6,COMMAND_ENCODER_NOT_FOUND:7,VERTEX_STATE_NOT_FOUND:8,PIPELINE_NOT_FOUND:9},Oe={RENDER_PIPELNE_NOT_FOUND:"RENDER_PIPELNE_NOT_FOUND",TEXTURE_SIZE_NOT_FOUND:"TEXTURE_SIZE_NOT_FOUND",TEXTURE_NOT_FOUND:"TEXTURE_NOT_FOUND"},Ce={RENDER_PIPELNE_NOT_FOUND:'"UWAL.RenderPipeline" is required in `Texture` when generating mipmaps.\n        Use `Texture.SetRenderer` method before creating a texture with mipmaps.',TEXTURE_SIZE_NOT_FOUND:"`size` array or a `width` value is required in `options` parameter of ",TEXTURE_NOT_FOUND:"CopyImageToTexture `options` is required to have a `texture` value or a `create` entry."},Ne={REQUIRED_SEGMENTS:"REQUIRED_SEGMENTS"},me={REQUIRED_SEGMENTS:"Shape `segments` is required to be an integer value."};m({DEVICE_LOST:"Device::Lost"});const d=m({WEBGPU_NOT_SUPPORTED:"WEBGPU_NOT_SUPPORTED",ADAPTER_NOT_FOUND:"ADAPTER_NOT_FOUND",DEVICE_NOT_FOUND:"DEVICE_NOT_FOUND",DEVICE_NOT_REQUESTED:"DEVICE_NOT_REQUESTED",DEVICE_LOST:"DEVICE_LOST",...de,...Oe,...Ne}),se=m({WEBGPU_NOT_SUPPORTED:"WebGPU is not supported in this browser.",ADAPTER_NOT_FOUND:"Failed to get a GPUAdapter.",DEVICE_NOT_FOUND:"Failed to get a GPUDevice.",DEVICE_NOT_REQUESTED:"GPUDevice was not requested.",DEVICE_LOST:"WebGPU device was lost. ",...Te,...Ce,...me}),Ae=m({WEBGPU_NOT_SUPPORTED:0,ADAPTER_NOT_FOUND:1,DEVICE_NOT_FOUND:2,DEVICE_NOT_REQUESTED:3,DEVICE_LOST:4,...De});function Pe(u,t){console.warn(se[u]+(t??""))}function T(u,t){throw new Error(se[u]+(t??""),{cause:Ae[u]})}var x,g,_,A;class ae{constructor(t,e,r){h(this,x,void 0);h(this,g,void 0);h(this,_,void 0);F(this,"Device");F(this,"BindGroups",[]);h(this,A,void 0);F(this,"Pipeline");F(this,"Descriptor");!t&&T(d.DEVICE_NOT_REQUESTED),c(this,x,r),this.Device=t,c(this,g,e),c(this,_,this.CreatePipelineLabel("Command Encoder"))}CreatePipelineLabel(t){return s(this,g)&&t&&`${s(this,g)} ${t}`||""}CreatePipelineLayout(t,e){const r=Array.isArray(t)&&t||[t];return e??(e=this.CreatePipelineLabel(`${s(this,x)} Pipeline Layout`)),this.Device.createPipelineLayout({label:e,bindGroupLayouts:r})}CreateShaderModule(t,e,r,i){e??(e=this.CreatePipelineLabel("Shader Module"));const a=Array.isArray(t)&&t.join(`

`)||t;return this.Device.createShaderModule({label:e,code:a,sourceMap:r,compilationHints:i})}CreateBuffer(t){const e=t.label??this.CreatePipelineLabel("Buffer");return this.Device.createBuffer({...t,label:e})}WriteBuffer(t,e,r=0,i,a){this.Device.queue.writeBuffer(t,r,e,i,a)}CopyBufferToBuffer(t,e,r,i=0,a=0){this.GetCommandEncoder(!0).copyBufferToBuffer(t,i,e,a,r)}CreateBindGroupLayout(t,e){e??(e=this.CreatePipelineLabel("Bind Group Layout")),t=Array.isArray(t)&&t.map((i,a)=>({...i,binding:i.binding??a}))||[{...t,binding:t.binding??0}];const r=t;return this.Device.createBindGroupLayout({entries:r,label:e})}CreateBindGroupEntries(t,e=0){return Array.isArray(t)&&t.map((r,i)=>({binding:(e==null?void 0:e[i])??i,resource:r}))||[{binding:e,resource:t}]}CreateBindGroup(t,e=0,r){return r??(r=this.CreatePipelineLabel("Bind Group")),typeof e=="number"&&(e=this.Pipeline?this.Pipeline.getBindGroupLayout(e):T(d.PIPELINE_NOT_FOUND,`${s(this,x)}Pipeline.`)),this.Device.createBindGroup({entries:t,label:r,layout:e})}SetBindGroups(t,e){Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups=Array.isArray(t)&&t.map((r,i)=>({bindGroup:r,dynamicOffsets:e[i],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}]}AddBindGroups(t,e){Array.isArray(e)?e[0].length||(e=e.map(r=>[r])):e=[e],this.BindGroups.push(...Array.isArray(t)&&t.map((r,i)=>({bindGroup:r,dynamicOffsets:e[i],active:!0}))||[{bindGroup:t,dynamicOffsets:e[0],active:!0}])}SetActiveBindGroups(t){t=Array.isArray(t)&&t||[t];for(let e=this.BindGroups.length;e--;)this.BindGroups[e].active=t.includes(e)}RestoreBindGroups(t){const e=t.map(({bindGroup:n})=>n),r=t.map(({dynamicOffsets:n})=>n),i=r.some(n=>typeof n=="number")&&r||void 0,a=t.map(({active:n},p)=>n&&p).filter(n=>typeof n=="number");this.SetBindGroups(e,i),this.SetActiveBindGroups(a)}ClearBindGroups(){this.BindGroups.splice(0)}CreateCommandEncoder(){return c(this,A,this.Device.createCommandEncoder({label:s(this,_)}))}SetCommandEncoder(t){c(this,A,t)}GetCommandEncoder(t=!1){if(!s(this,A)){if(t){const e=` ${s(this,_)&&`Label: "${s(this,_)}". `}`;Pe(d.COMMAND_ENCODER_NOT_FOUND,e+"Creating a new one.")}return this.CreateCommandEncoder()}return s(this,A)}DestroyCommandEncoder(){c(this,A,void 0)}SubmitCommandBuffer(){this.Device.queue.submit([s(this,A).finish()])}set CommandEncoderLabel(t){c(this,_,t)}get ProgramName(){return s(this,g)}CopyBindGroups(){return[...this.BindGroups]}GetDescriptor(){return this.Descriptor}GetPipeline(){return this.Pipeline}}x=new WeakMap,g=new WeakMap,_=new WeakMap,A=new WeakMap;var q,P,L,O,v,B,f,I,N,l,W,te;class _e extends ae{constructor(e,r,i,a){super(e,r,"Render");h(this,W);h(this,q,void 0);h(this,P,!1);h(this,L,new Float32Array(2));h(this,O,void 0);h(this,v,void 0);h(this,B,void 0);h(this,f,[]);h(this,I,void 0);h(this,N,void 0);h(this,l,void 0);!i&&T(d.CANVAS_NOT_FOUND);const n=i.getContext("webgpu");!n&&T(d.CONTEXT_NOT_FOUND),c(this,I,a.format??navigator.gpu.getPreferredCanvasFormat()),n.configure({device:e,...a,format:s(this,I)}),c(this,B,this.CreateBuffer({size:s(this,L).length*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,label:"Render Pipeline Resolution Buffer"})),c(this,O,i),c(this,v,n),D(this,W,te).call(this)}SetCanvasSize(e,r){!this.Device&&T(d.DEVICE_NOT_FOUND),!s(this,O)&&T(d.CANVAS_NOT_FOUND);const{maxTextureDimension2D:i}=this.Device.limits;e=Math.max(1,Math.min(e,i)),r=Math.max(1,Math.min(r,i)),(s(this,O).width!==e||s(this,O).height!==r)&&(s(this,O).width=e,s(this,O).height=r,D(this,W,te).call(this))}CreateColorAttachment(e,r="clear",i="store",a,n,p){return{view:e,loadOp:r,storeOp:i,clearValue:a,resolveTarget:n,depthSlice:p}}CreatePassDescriptor(e,r,i,a,n,p){const C=Array.isArray(e)&&e||[e];return c(this,P,!C.some(({view:U})=>!!U)),r??(r=this.CreatePipelineLabel("Render Pass")),this.Descriptor={colorAttachments:C,depthStencilAttachment:i,occlusionQuerySet:a,timestampWrites:n,maxDrawCount:p,label:r}}SetPassDescriptor(e){if(!(this.Descriptor=e))return c(this,P,!0);const r=e.colorAttachments;c(this,P,!r.some(({view:i})=>!!i))}CreateVertexBufferAttribute(e,r=0,i=0){return{format:e,shaderLocation:r,offset:i}}CreateVertexState(e,r="vertex",i,a){return i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,buffers:i,constants:a}}CreateFragmentColorTarget(e=s(this,I),r,i){return{format:e,blend:r,writeMask:i}}CreateFragmentState(e,r="fragment",i,a){return i??(i=[this.CreateFragmentColorTarget()]),i=Array.isArray(i)&&i||[i],{module:e,entryPoint:r,targets:i,constants:a}}CreatePipeline(e){const r=e.layout??"auto";let{module:i,vertex:a,fragment:n}=e;i&&(a??(a=this.CreateVertexState(i)),n??(n=this.CreateFragmentState(i))),!i&&!a&&T(d.VERTEX_STATE_NOT_FOUND);const p=e.label??this.CreatePipelineLabel("Render Pipeline");return this.Pipeline=this.Device.createRenderPipeline({...e,vertex:a,fragment:n,label:p,layout:r})}SetPipeline(e){this.Pipeline=e}SetVertexBuffers(e,r,i){r=Array.isArray(r)&&r||[r],i=Array.isArray(i)&&i||[i],c(this,f,Array.isArray(e)&&e.map((a,n)=>({buffer:a,offset:r[n],size:i[n]}))||[{buffer:e,offset:r[0],size:i[0]}])}AddVertexBuffers(e,r,i){r=Array.isArray(r)&&r||[r],i=Array.isArray(i)&&i||[i],s(this,f).push(...Array.isArray(e)&&e.map((a,n)=>({buffer:a,offset:r[n],size:i[n]}))||[{buffer:e,offset:r[0],size:i[0]}])}SetIndexBuffer(e,r="uint32",i,a){c(this,N,{buffer:e,format:r,offset:i,size:a})}Render(e,r=!0){s(this,l)||(s(this,P)&&(this.Descriptor.colorAttachments[0].view=this.CurrentTextureView),c(this,l,this.GetCommandEncoder().beginRenderPass(this.Descriptor)),s(this,l).setPipeline(this.Pipeline),c(this,q,s(this,N)?s(this,l).drawIndexed.bind(s(this,l)):s(this,l).draw.bind(s(this,l))));for(let i=0,a=s(this,f).length;i<a;++i){const{buffer:n,offset:p,size:C}=s(this,f)[i];s(this,l).setVertexBuffer(i,n,p,C)}s(this,N)&&s(this,l).setIndexBuffer(s(this,N).buffer,s(this,N).format,s(this,N).offset,s(this,N).size);for(let i=0,a=0,n=this.BindGroups.length;i<n;++i){const{bindGroup:p,dynamicOffsets:C,active:U}=this.BindGroups[i];U&&s(this,l).setBindGroup(a++,p,C)}s(this,q).call(this,...Array.isArray(e)&&e||[e]),r&&this.Submit()}Submit(){s(this,l).end(),this.SubmitCommandBuffer(),this.DestroyCommandEncoder(),c(this,l,void 0)}Destroy(){var e;c(this,l,void 0),(e=s(this,v))==null||e.unconfigure()}get Canvas(){return s(this,O)}get Context(){return s(this,v)}get AspectRatio(){return!s(this,O)&&T(d.CANVAS_NOT_FOUND),s(this,O).width/s(this,O).height}get CurrentTexture(){return s(this,v).getCurrentTexture()}get CurrentTextureView(){return this.CurrentTexture.createView()}set UseCurrentTextureView(e){c(this,P,e)}get UseCurrentTextureView(){return s(this,P)}get ResolutionBuffer(){return s(this,B)}get CurrentPass(){return s(this,l)}}q=new WeakMap,P=new WeakMap,L=new WeakMap,O=new WeakMap,v=new WeakMap,B=new WeakMap,f=new WeakMap,I=new WeakMap,N=new WeakMap,l=new WeakMap,W=new WeakSet,te=function(){s(this,L).set([s(this,O).width,s(this,O).height]),this.WriteBuffer(s(this,B),s(this,L))};var z;class Re extends ae{constructor(e,r){super(e,r,"Compute");h(this,z,[1])}CreatePassDescriptor(e,r,i,a){return e??(e=this.CreatePipelineLabel("Compute Pass")),this.Descriptor={label:e,timestampWrites:r?{querySet:r,beginningOfPassWriteIndex:i,endOfPassWriteIndex:a}:void 0}}SetPassDescriptor(e){this.Descriptor=e}CreatePipeline(e){const r=e.layout??"auto",i=e.label??this.CreatePipelineLabel("Compute Pipeline");return this.Pipeline=this.Device.createComputePipeline({label:i,layout:r,compute:e})}SetPipeline(e){this.Pipeline=e}Compute(){const e=this.GetCommandEncoder().beginComputePass(this.Descriptor);e.setPipeline(this.Pipeline);for(let r=0,i=0,a=this.BindGroups.length;r<a;++r){const{bindGroup:n,dynamicOffsets:p,active:C}=this.BindGroups[r];C&&e.setBindGroup(i++,n,p)}e.dispatchWorkgroups(...s(this,z)),e.end()}set Workgroups(e){c(this,z,Array.isArray(e)&&e||[e])}}z=new WeakMap;m({ALL:"all",STENCIL:"stencil-only",DEPTH:"depth-only"});const fe=m({CLAMP:"clamp-to-edge",REPEAT:"repeat",MIRROR:"mirror-repeat"}),Se=m({NEAREST:"nearest",LINEAR:"linear"});m({NEVER:"never",LESS:"less",EQUAL:"equal",LESS_EQUAL:"less-equal",GREATER:"greater",NOT_EQUAL:"not-equal",GREATER_EQUAL:"greater-equal",ALWAYS:"always"});var Ue="const QUAD=array(vec2f(-1.0,-1.0),vec2f(1.0,-1.0),vec2f(1.0,1.0),vec2f(1.0,1.0),vec2f(-1.0,1.0),vec2f(-1.0,-1.0));fn GetQuadCoord(index: u32)->vec2f{return QUAD[index];}struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {let position=GetQuadCoord(index);let coord=(position+1)*0.5;var output: VertexOutput;output.position=vec4f(position,0.0,1.0);output.textureCoord=vec2f(coord.x,1-coord.y);return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}",R,w,V,G,E,Y,ne,H,re,b,j;class ge{constructor(t,e){h(this,Y);h(this,H);h(this,b);h(this,R,void 0);h(this,w,void 0);h(this,V,void 0);h(this,G,void 0);h(this,E,void 0);!t&&T(d.DEVICE_NOT_REQUESTED),c(this,w,e),c(this,R,t)}GenerateMipmaps(t){!s(this,E)&&T(d.RENDER_PIPELNE_NOT_FOUND),(!s(this,G)||!s(this,V))&&(c(this,G,s(this,E).CreateShaderModule(Ue)),c(this,V,this.CreateSampler({minFilter:Se.LINEAR})));let e=0,r=t.width,i=t.height;const a=s(this,E).CopyBindGroups(),n=s(this,E).UseCurrentTextureView,p=s(this,E).GetPipeline(),C=s(this,E).GetDescriptor();for(s(this,E).CreatePipeline({fragment:s(this,E).CreateFragmentState(s(this,G),void 0,{format:t.format}),vertex:s(this,E).CreateVertexState(s(this,G))});1<r||1<i;)r=Math.max(r*.5|0,1),i=Math.max(i*.5|0,1),s(this,E).SetBindGroups(s(this,E).CreateBindGroup(s(this,E).CreateBindGroupEntries([s(this,V),t.createView({baseMipLevel:e++,mipLevelCount:1})]))),s(this,E).CreatePassDescriptor(s(this,E).CreateColorAttachment(t.createView({baseMipLevel:e,mipLevelCount:1}))),s(this,E).Render(6);s(this,E).SetPipeline(p),s(this,E).RestoreBindGroups(a),s(this,E).SetPassDescriptor(C),s(this,E).UseCurrentTextureView=n}CreateTexture(t){const e=t.label??D(this,Y,ne).call(this,"Texture");return s(this,R).createTexture({...t,label:e})}WriteTexture(t,e){const{texture:r,mipLevel:i,origin:a,aspect:n,offset:p,bytesPerRow:C,rowsPerImage:U}=e;s(this,R).queue.writeTexture({texture:r,mipLevel:i,origin:a,aspect:n},t,{offset:p,bytesPerRow:C,rowsPerImage:U},D(this,H,re).call(this,e,"WriteTexture"))}CreateBitmapImage(t,e){return createImageBitmap(t,e)}CreateTextureFromSource(t,e){const r=e.mipLevelCount??(e.mipmaps&&this.GetMipmapLevels(t)||void 0),i=e.size,a=e.size,n=Array.isArray(e.size)||!e.size?i??D(this,b,j).call(this,t):[a.width,a.height];return this.CreateTexture({mipLevelCount:r,size:n,...e})}CopyImageToTexture(t,e){let{texture:r}=e;const[i,a]=D(this,b,j).call(this,t),{create:n,flipY:p,mipLevel:C,aspect:U,colorSpace:ce,premultipliedAlpha:Ee}=e;return!r&&!n&&T(d.TEXTURE_NOT_FOUND),r??(r=this.CreateTextureFromSource(t,n)),s(this,R).queue.copyExternalImageToTexture({source:t,origin:e.sourceOrigin,flipY:p},{texture:r,mipLevel:C,origin:e.destinationOrigin,aspect:U,colorSpace:ce,premultipliedAlpha:Ee},D(this,H,re).call(this,{width:i,height:a,...e},"CopyImageToTexture")),1<r.mipLevelCount&&this.GenerateMipmaps(r),r}CreateSampler(t){return s(this,R).createSampler(t)}GetMipmapLevels(t){const[e,r]=D(this,b,j).call(this,t);return(Math.log2(Math.max(e,r))|0)+1}SetRenderer(t){c(this,E,t)}}R=new WeakMap,w=new WeakMap,V=new WeakMap,G=new WeakMap,E=new WeakMap,Y=new WeakSet,ne=function(t){return s(this,w)&&t&&`${s(this,w)} ${t}`||""},H=new WeakSet,re=function(t,e){const{size:r,width:i,height:a,depthOrArrayLayers:n}=t;return!r&&!i&&T(d.TEXTURE_SIZE_NOT_FOUND,`\`${e}\` method.`),r??{width:i,height:a,depthOrArrayLayers:n}},b=new WeakSet,j=function(t){return t instanceof HTMLVideoElement?[t.videoWidth,t.videoHeight]:t instanceof VideoFrame?[t.codedWidth,t.codedHeight]:[t.width,t.height]};/**
 * @module UWAL
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description Unopinionated WebGPU Abstraction Library
 * @version 0.0.4
 * @license MIT
 */var M,$,y,S,Q,X,k,Z,oe,J,ue,K,he;const o=class o{static SetAdapterOptions(t,e=!1){s(o,$).powerPreference=t,s(o,$).forceFallbackAdapter=e}static SetDeviceDescriptor(t,e=[],r={}){s(o,S).label=t,s(o,S).requiredFeatures=e,s(o,S).requiredLimits=r}static RenderPipeline(t,e="",r={}){return D(this,X,k).call(this,e),(async()=>{const i=await o.Device;return new Proxy(_e,{construct(a){return new a(i,e,t,r)}})})()}static ComputePipeline(t=""){return D(this,X,k).call(this,t),(async()=>{const e=await o.Device;return new Proxy(Re,{construct(r){return new r(e,t)}})})()}static Texture(t=""){return D(this,X,k).call(this,t),(async()=>{const e=await o.Device;return new Proxy(ge,{construct(r){return new r(e,t)}})})()}static Destroy(t,e,r){var i;t=Array.isArray(t)&&t||[t],t.forEach(a=>a==null?void 0:a.destroy()),e=Array.isArray(e)&&e||[e],e.forEach(a=>a==null?void 0:a.destroy()),r=Array.isArray(r)&&r||[r],r.forEach(a=>a==null?void 0:a.destroy()),(i=s(o,y))==null||i.destroy(),o.SetAdapterOptions(),o.SetDeviceDescriptor(),c(o,Q,void 0),c(o,M,c(o,y,null))}static get AdapterLimits(){return s(this,Q)}static get Adapter(){return(async()=>{var t;return s(o,M)??await D(t=o,J,ue).call(t)()})()}static get Device(){return(async()=>{var t;return s(o,y)??await D(t=o,K,he).call(t)()})()}static get VERSION(){return"0.0.4"}};M=new WeakMap,$=new WeakMap,y=new WeakMap,S=new WeakMap,Q=new WeakMap,X=new WeakSet,k=function(t){var e;(e=s(o,S)).label??(e.label=t&&`${t} Device`||"")},Z=new WeakSet,oe=function(t){if(o.OnDeviceLost)return o.OnDeviceLost(t);const e=(t.message&&` | Message: ${t.message}`)??".";T(d.DEVICE_LOST,`Reason: ${t.reason}`+e)},J=new WeakSet,ue=function(){return!navigator.gpu&&T(d.WEBGPU_NOT_SUPPORTED),async()=>{const t=await navigator.gpu.requestAdapter(s(o,$));return!t&&T(d.ADAPTER_NOT_FOUND),c(this,Q,t.limits),c(o,M,t)}},K=new WeakSet,he=function(){return async()=>{const{requiredFeatures:t,requiredLimits:e,label:r}=s(o,S),i=await(await o.Adapter).requestDevice({requiredFeatures:t,requiredLimits:e,defaultQueue:{label:r}});return!i&&T(d.DEVICE_NOT_FOUND),i.lost.then(D(o,Z,oe)),c(o,y,i)}},h(o,X),h(o,Z),h(o,J),h(o,K),h(o,M,null),h(o,$,{powerPreference:void 0,forceFallbackAdapter:!1}),h(o,y,null),h(o,S,{label:void 0,requiredFeatures:[],requiredLimits:{}}),h(o,Q,void 0),F(o,"OnDeviceLost");let ie=o;m({HPI:Math.PI/2,TAU:Math.PI*2});m({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});console.info("%cUWAL v0.0.4","background:#005a9c;padding:3px;color:#fff;");export{fe as A,Se as F,ie as U};
