import{U as q,F as re,B as i}from"./index-B1jZ--9m.js";import{m as H}from"./wgpu-matrix.module-BIbWF_bz.js";import{Q as oe}from"./Quad-VFYOTGYq.js";var ne="struct Matrix{values: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)textureCoord: vec2f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>matrix: Matrix;@group(0)@binding(2)var Texture: texture_2d<f32>;@vertex fn vertex(@builtin(vertex_index)index: u32)->VertexOutput {var output: VertexOutput;var position=GetQuadCoord(index);position=(position+1)*0.5;output.position=matrix.values*vec4f(position,0.0,1.0);output.textureCoord=position;return output;}@fragment fn fragment(@location(0)textureCoord: vec2f)->@location(0)vec4f {return textureSample(Texture,Sampler,textureCoord);}";/**
 * @module Blend Settings
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Transparency and Blending
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-transparency.html#blend-settings}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.7
 * @license MIT
 */(async function(C){let r;C.style.backgroundPosition="0 0, 0 16px, 16px -16px, -16px 0px",C.style.backgroundSize="32px 32px",C.style.backgroundColor="#404040",C.style.backgroundImage=`
        linear-gradient( 45deg,     #808080 25%, transparent 25%),
        linear-gradient(-45deg,     #808080 25%, transparent 25%),
        linear-gradient( 45deg, transparent 75%,     #808080 75%),
        linear-gradient(-45deg, transparent 75%,     #808080 75%)
    `;try{r=new(await q.RenderPipeline(C,"Blend Settings",{alphaMode:"premultiplied"}))}catch(e){alert(e)}const I=(e,t,o)=>`hsl(${e*360|0}, ${t*100}%, ${o*100|0}%)`,A=(e,t,o,n)=>`hsla${I(e,t,o).slice(3,-1)}, ${n})`;function J(e){const t=document.createElement("canvas");t.width=t.height=e;const o=t.getContext("2d");o.translate(e/2,e/2),o.globalCompositeOperation="screen";const n=Math.PI*2,a=3;for(let l=0;l<a;++l){o.rotate(n/a),o.save(),o.translate(e/6,0),o.beginPath();const u=e/3,X=l/a;o.arc(0,0,u,0,n);const E=o.createRadialGradient(0,0,u/2,0,0,u);E.addColorStop(.5,A(X,1,.5,1)),E.addColorStop(1,A(X,1,.5,0)),o.fillStyle=E,o.fill(),o.restore()}return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function K(e){const t=document.createElement("canvas");t.width=t.height=e;const o=t.getContext("2d"),n=o.createLinearGradient(0,0,e,e);for(let a=0;a<=6;++a)n.addColorStop(a/6,I(a/-6,1,.5));o.fillStyle=n,o.fillRect(0,0,e,e),o.fillStyle="rgba(0, 0, 0, 255)",o.globalCompositeOperation="destination-out",o.rotate(Math.PI/-4);for(let a=0;a<e*2;a+=32)o.fillRect(-e,a,e*2,16);return t.style.position="absolute",t.style.height=`${e}px`,t.style.width=`${e}px`,t.style.left="8px",t.style.top="8px",t}function F(){const{values:e}=r.CreateUniformBufferLayout("matrix"),t=r.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:e.buffer.byteLength});return{values:e,buffer:t}}function h(e,t=!0){return N.CopyImageToTexture(e,{premultipliedAlpha:t,create:{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:!1}})}function c(e){typeof e=="string"&&!["constant","one-minus-constant"].includes(e)||(r.BlendConstant=[...b.color,b.alpha])}function y(){const{premultiply:e,alpha:t,color:o}=m,n=e&&t||1,[a,l,u]=o;f.clearValue[0]=a*n,f.clearValue[1]=l*n,f.clearValue[2]=u*n,f.clearValue[3]=t}function R(e){const{operation:t}=e;(t==="min"||t==="max")&&(e.srcFactor=e.dstFactor="one")}function D(e,t,o){const n=H.ortho(0,t.width,t.height,0,-1,1);H.scale(n,[o.width,o.height,1],e.values),r.WriteBuffer(e.buffer,e.values)}const N=new(await q.Texture(r)),B=r.CreateShaderModule([oe,ne]),x=N.CreateSampler({filter:re.LINEAR}),V=J(300),_=K(300),v=F(),G=F(),w=h(V),M=h(_),L=h(V,!1),$=h(_,!1),g=r.CreateBindGroupLayout([{visibility:GPUShaderStage.FRAGMENT,sampler:{}},{visibility:GPUShaderStage.VERTEX,buffer:{}},{visibility:GPUShaderStage.FRAGMENT,texture:{}}]);r.SetBindGroups([r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},w.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},M.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:v.buffer},L.createView()]),g),r.CreateBindGroup(r.CreateBindGroupEntries([x,{buffer:G.buffer},$.createView()]),g)]);const Z=[{sourceBindGroup:0,destinationBindGroup:1,sourceTexture:w,destinationTexture:M},{sourceBindGroup:2,destinationBindGroup:3,sourceTexture:L,destinationTexture:$}],s=new GUI().onChange(W),S={textureSet:0,alphaMode:"premultiplied",preset:"Copy (Default)"};s.add(S,"alphaMode",["opaque","premultiplied"]).name("Canvas Alpha Mode").onChange(e=>r.ConfigureContext({alphaMode:e})),s.add(S,"textureSet",["premultiplied alpha","un-premultiplied alpha"]).name("Texture Set");const z=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),ee=r.CreateBlendComponent("add","src-alpha","one-minus-src-alpha"),k={"Copy (Default)":i.COPY,"Additive (Lighten)":i.ADDITIVE,"Un-premultiplied Blend":{color:z,alpha:ee},"Source Over (Premultiplied Blend)":i.SOURCE_OVER,"Destination Over":i.DESTINATION_OVER,"Source In":i.SOURCE_IN,"Destination In":i.DESTINATION_IN,"Source Out":i.SOURCE_OUT,"Destination Out":i.DESTINATION_OUT,"Source Atop":i.SOURCE_ATOP,"Destination Atop":i.DESTINATION_ATOP};s.add(S,"preset",Object.keys(k)).name("Blending Preset").onChange(e=>{const t=k[e];Object.assign(d,t.color),Object.assign(p,t.alpha)});const O=s.addFolder("Color"),d=r.CreateBlendComponent(),j=["add","subtract","reverse-subtract","min","max"],T=["zero","one","src","one-minus-src","src-alpha","one-minus-src-alpha","dst","one-minus-dst","dst-alpha","one-minus-dst-alpha","src-alpha-saturated","constant","one-minus-constant"];O.add(d,"operation",j).name("Operation"),O.add(d,"srcFactor",T).name("Source Factor").onChange(c),O.add(d,"dstFactor",T).name("Destination Factor").onChange(c);const P=s.addFolder("Alpha"),p=r.CreateBlendComponent();P.add(p,"operation",j).name("Operation"),P.add(p,"srcFactor",T).name("Source Factor").onChange(c),P.add(p,"dstFactor",T).name("Destination Factor").onChange(c);const Q=s.addFolder("Constant"),b={color:[1,.5,.25],alpha:1};Q.addColor(b,"color").name("Color").onChange(c),Q.add(b,"alpha",0,1).name("Alpha").onChange(c);const U=s.addFolder("Canvas Clear Color"),m={color:[0,0,0],alpha:0,premultiply:!0};U.addColor(m,"color").name("Color").onChange(y),U.add(m,"alpha",0,1).name("Alpha").onChange(y),U.add(m,"premultiply").name("Premultiply").onChange(y);const f=r.CreateColorAttachment();f.clearValue=[...m.color,m.alpha];const Y=r.CreatePipelineLayout(g);r.CreatePassDescriptor(f),r.CreatePipeline({module:B,layout:Y});const te=r.CreateVertexState(B);function W(){R(d),R(p),s.updateDisplay();const{sourceTexture:e,destinationTexture:t,destinationBindGroup:o,sourceBindGroup:n}=Z[S.textureSet],a=r.CurrentTexture;D(v,a,e),D(G,a,t),r.SetActiveBindGroups(o),r.Render(6,!1),r.SavePipelineState();const l=r.CreateTargetState(void 0,{color:d,alpha:p}),u=r.CreateFragmentState(B,void 0,l);r.CreatePipeline({vertex:te,fragment:u,layout:Y},!0),r.SetActiveBindGroups(n),r.Render(6),r.RestorePipelineState()}new ResizeObserver(e=>{for(const t of e){const{inlineSize:o,blockSize:n}=t.contentBoxSize[0];r.SetCanvasSize(o,n)}W()}).observe(document.body)})(document.getElementById("lesson"));
