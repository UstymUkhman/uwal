import{U as B,A as G,F as l}from"./index-DUOumvAP.js";import{G as V,a as O}from"./GPUMipmap-ZyUDCfwU.js";import{v as Y,m as i}from"./wgpu-matrix.module-D3z0rCw6.js";import{Q as U,C as j}from"./Quad-C4zpvK4p.js";/**
 * @module Loading Canvas
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Loading Images into Textures
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-importing-textures.html#loading-canvas}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.5
 * @license MIT
 */(async function(d){let e;try{e=new(await B.RenderPipeline(d,"Loading Canvas"))}catch(t){alert(t)}const w=(()=>{let t,r;return a=>{t||(t=e.CreateShaderModule([U,O]),r=p.CreateSampler({minFilter:l.LINEAR})),e.CreatePipeline({fragment:e.CreateFragmentState(t,"fragment",{format:a.format}),vertex:e.CreateVertexState(t)});let n=0,s=a.width,u=a.height;for(;1<s||1<u;)s=Math.max(s/2|0,1),u=Math.max(u/2|0,1),e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([r,a.createView({baseMipLevel:n++,mipLevelCount:1})]))),e.CreatePassDescriptor(e.CreateColorAttachment(a.createView({baseMipLevel:n,mipLevelCount:1}))),e.Render(6)}})();e.CreatePipeline({module:e.CreateShaderModule([U,V])});const E=e.CreateColorAttachment();E.clearValue=new j(5000268).rgba,e.CreatePassDescriptor(E),e.ClearBindGroups();const c=256,m=c/2,x=0,C=[],h=1,v=2e3,F=[0,1,0],I=[0,0,0],S=Math.PI*60/180,y=[0,0,2],T=Y.set(1.2,.7),f=i.perspective(S,e.AspectRatio,h,v),A=i.inverse(i.lookAt(y,I,F)),R=i.multiply(f,A),o=document.createElement("canvas").getContext("2d");o.canvas.width=o.canvas.height=c;const p=new(await B.Texture()),g=N(o.canvas);for(let t=0;t<8;t++){const r=p.CreateSampler({addressModeU:G.REPEAT,addressModeV:G.REPEAT,magFilter:t&1?l.LINEAR:l.NEAREST,minFilter:t&2?l.LINEAR:l.NEAREST,mipmapFilter:t&4?l.LINEAR:l.NEAREST}),a=16*Float32Array.BYTES_PER_ELEMENT,n=e.CreateBuffer({usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,size:a}),s=new Float32Array(a/Float32Array.BYTES_PER_ELEMENT),u=s.subarray(x,16);e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([r,g.createView(),{buffer:n}]))),C.push({matrixBuffer:n,matrixValues:s,matrix:u})}const L=(t,r,a)=>`hsl(${t*360|0}, ${r*100}%, ${a*100|0}%)`;function N(t,{mipmaps:r,flip:a}={}){const n=p.CreateTextureFromSource(t,{usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm",mipmaps:r});return P(t,n,a),n}function P(t,r,a=!1){p.CopyImageToTexture(t,{texture:r,flipY:a}),r.mipLevelCount>1&&w(r)}function b(t){o.clearRect(0,0,c,c),o.save(),o.translate(m,m);const r=20;for(let a=0;a<r;a++)o.fillStyle=L(a/r*.2+t*.1,1,a%2*.5),o.fillRect(-m,-m,c,c),o.rotate(t*.5),o.scale(.85,.85),o.translate(c/16,0);o.restore()}function M(t){b(t*1e-4),requestAnimationFrame(M),P(o.canvas,g),C.forEach(({matrix:r,matrixBuffer:a,matrixValues:n},s)=>{const _=s%4-1.5,z=+(s<4)*2-1,D=[_*T[0],z*T[1],-50*.5];i.translate(R,D,r),i.rotateX(r,Math.PI*.5,r),i.scale(r,[1,50*2,1],r),i.translate(r,[-.5,-.5,0],r),e.WriteBuffer(a,n),e.SetActiveBindGroups(s),e.Render(6,!1)}),e.Submit()}new ResizeObserver(t=>{for(const r of t){const{inlineSize:a,blockSize:n}=r.contentBoxSize[0];e.SetCanvasSize(a,n)}i.perspective(S,e.AspectRatio,h,v,f),i.multiply(f,A,R),requestAnimationFrame(M)}).observe(d)})(document.getElementById("lesson"));
