import{D as T,U as f,a as c}from"./index-BLf8dJ29.js";import{C as A}from"./Cube-Di4jzhQv.js";var z="struct transform{matrix: mat4x4f};struct VertexOutput{@builtin(position)position: vec4f,@location(0)normal: vec3f};@group(0)@binding(0)var Sampler: sampler;@group(0)@binding(1)var<uniform>Transform: transform;@group(0)@binding(2)var CubeTexture: texture_cube<f32>;@vertex fn vertex(@location(0)position: vec4f)->VertexOutput {var output: VertexOutput;output.position=Transform.matrix*position;output.normal=normalize(position.xyz);return output;}@fragment fn fragment(@location(0)normal: vec3f)->@location(0)vec4f {return textureSample(CubeTexture,Sampler,normalize(normal));}";/**
 * @module Cubemaps
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Cubemaps
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-cube-maps.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.6
 * @license MIT
 */(async function(v){let e,d;try{e=new(await T.RenderPipeline(v,"Cubemaps",{alphaMode:"premultiplied"}))}catch(t){alert(t)}const x=e.CreateColorAttachment();x.clearValue=[0,0,0,1],e.CreatePassDescriptor(x,void 0,e.CreateDepthAttachment());const g=e.CreateShaderModule(z),b=f.DegreesToRadians(60);e.CreatePipeline({primitive:{cullMode:"back"},fragment:e.CreateFragmentState(g),vertex:e.CreateVertexState(g,void 0,{arrayStride:Float32Array.BYTES_PER_ELEMENT*3,attributes:[e.CreateVertexBufferAttribute("float32x3")]}),depthStencil:{depthWriteEnabled:!0,format:"depth24plus",depthCompare:"less"}});const u=new(await T.Texture()),l=new A(e),o=l.Transform;u.SetRenderer(e);const F=[{faceColor:"#F00",textColor:"#0FF",text:"+X"},{faceColor:"#FF0",textColor:"#00F",text:"-X"},{faceColor:"#0F0",textColor:"#F0F",text:"+Y"},{faceColor:"#0FF",textColor:"#F00",text:"-Y"},{faceColor:"#00F",textColor:"#FF0",text:"+Z"},{faceColor:"#F0F",textColor:"#0F0",text:"-Z"}].map(t=>R(t)),h=u.CreateSampler({filter:"linear"}),S=E(F);e.SetBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([h,{buffer:l.TransformBuffer},S.createView({dimension:"cube"})])));const B=c.lookAt([0,1,5],[0,0,0],[0,1,0]),s={rotation:[f.DegreesToRadians(20),f.DegreesToRadians(25),f.DegreesToRadians(0)]},p={converters:GUI.converters.radToDeg,min:-360,max:360,step:1},m=new GUI;m.onChange(C),m.add(s.rotation,"0",p).name("rotation.x"),m.add(s.rotation,"1",p).name("rotation.y"),m.add(s.rotation,"2",p).name("rotation.z");function R({faceColor:t,textColor:n,text:i}){const a=document.createElement("canvas"),r=a.getContext("2d");a.width=a.height=128,r.fillStyle=t,r.fillRect(0,0,128,128),r.textAlign="left",r.textBaseline="top",r.fillStyle=n,r.font="90px sans-serif";const{actualBoundingBoxLeft:D,actualBoundingBoxRight:y,actualBoundingBoxAscent:U,actualBoundingBoxDescent:w}=r.measureText(i);return r.fillText(i,(128-y+D)/2,(128-w+U)/2),a}function E(t){const n=t[0],i=u.CreateTextureFromSource(n,{size:[n.width,n.height,t.length],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,format:"rgba8unorm"});return t.forEach((a,r)=>u.CopyImageToTexture(a,{mipmaps:r===t.length-1,destinationOrigin:[0,0,r],texture:i})),i}function C(){c.perspective(b,d,.1,10,o),c.multiply(o,B,o),c.rotateX(o,s.rotation[0],o),c.rotateY(o,s.rotation[1],o),c.rotateZ(o,s.rotation[2],o),l.UpdateTransformBuffer(),e.Render(l.Vertices)}new ResizeObserver(t=>{for(const n of t){const{inlineSize:i,blockSize:a}=n.contentBoxSize[0];e.SetCanvasSize(i,a)}d=e.AspectRatio,C()}).observe(document.body)})(document.getElementById("lesson"));
