var yt=o=>{throw TypeError(o)};var st=(o,e,s)=>e.has(o)||yt("Cannot "+s);var t=(o,e,s)=>(st(o,e,"read from private field"),s?s.call(o):e.get(o)),r=(o,e,s)=>e.has(o)?yt("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(o):e.set(o,s),i=(o,e,s,c)=>(st(o,e,"write to private field"),c?c.call(o,s):e.set(o,s),s),z=(o,e,s)=>(st(o,e,"access private method"),s);import{b as Bt,T as Gt,E as Mt,N as Ot,U as Ct,C as rt,a as it}from"./index-BRbAh6QZ.js";import{a as m,v as bt}from"./wgpu-matrix.module-0Oa3LLlt.js";var zt="struct Shape{color: vec4f,matrix: mat3x3f};@group(0)@binding(0)var<uniform>resolution: vec2f;fn GetClipSpace(position: vec2f)->vec2f{let clipSpace=position/resolution*2-1;return clipSpace*vec2f(1,-1);}@group(0)@binding(1)var<uniform>shape: Shape;fn GetVertexClipSpace(position: vec2f)->vec4f{let matrixPosition=shape.matrix*vec3f(position,1);let clipSpace=GetClipSpace(matrixPosition.xy);return vec4f(clipSpace,0.0,1.0);}@vertex fn vertex(@location(0)position: vec2f)->@builtin(position)vec4f {return GetVertexClipSpace(position);}",u,L,y,q,Y,k,Q,E,B,_,n,U,l,V,R,C,J,P,p,j,T,I,w,x,At,Et,Vt,nt;class Lt{constructor(e){r(this,x);r(this,u);r(this,L,0);r(this,y,!1);r(this,q,m.create());r(this,Y,m.create());r(this,k,m.create());r(this,Q,m.create());r(this,E);r(this,B);r(this,_);r(this,n);r(this,U);r(this,l);r(this,V);r(this,R);r(this,C);r(this,J);r(this,P,new Float32Array([1,1]));r(this,p,new Float32Array([0,0]));r(this,j,new Float32Array([0,0]));r(this,T,new Float32Array([0,0]));r(this,I);r(this,w,Bt({min:bt.create(),max:bt.create()}));!e.segments&&Gt(Mt.REQUIRED_SEGMENTS),i(this,E,e.label??"Shape"),i(this,u,e.radius??0),i(this,n,e.renderer),i(this,B,e.segments);const{startAngle:s,endAngle:c,innerRadius:h}=e;z(this,x,At).call(this,s,c,h),z(this,x,Et).call(this),z(this,x,Vt).call(this),this.Scale=t(this,P),this.Origin=t(this,p),this.Rotation=t(this,L),this.Position=t(this,T)}Update(){return t(this,n).SetVertexBuffers(t(this,R)),t(this,n).SetIndexBuffer(t(this,V)),t(this,n).SetBindGroups(t(this,J)),z(this,x,nt).call(this)}Render(e=!0){t(this,n).SavePipelineState(),t(this,n).Render(t(this.Update(),_),e),t(this,n).RestorePipelineState()}set Color(e){t(this,U).set(Array.isArray(e)||ArrayBuffer.isView(e)?e:e.rgba),t(this,n).WriteBuffer(t(this,C),t(this,U),t(this,I).color)}get Color(){return t(this,U)}set Position(e){t(this,T).set(e),m.translation(t(this,T),t(this,Q)),i(this,y,!0)}get Position(){return t(this,T)}set Rotation(e){m.rotation(i(this,L,e),t(this,k)),i(this,y,!0)}get Rotation(){return t(this,L)}set Scale(e){t(this,P).set(e),m.scaling(t(this,P),t(this,Y)),i(this,y,!0)}get Scale(){return t(this,P)}set Origin(e){t(this,p)[0]=e[0],t(this,p)[1]=e[1],t(this,p)[0]*=-t(this,u),t(this,p)[1]*=-t(this,u),m.translation(t(this,p),t(this,q)),t(this,p)[0]=e[0]||0,t(this,p)[1]=e[1]||0,i(this,y,!0)}get Origin(){return t(this,p)}get Center(){return t(z(this,x,nt).call(this),j)}get Vertices(){return t(this,_)}get Transform(){return t(this,l)}get BoundingBox(){return t(this,w)}Destroy(){i(this,V,t(this,V).destroy()),i(this,R,t(this,R).destroy()),i(this,C,t(this,C).destroy())}}u=new WeakMap,L=new WeakMap,y=new WeakMap,q=new WeakMap,Y=new WeakMap,k=new WeakMap,Q=new WeakMap,E=new WeakMap,B=new WeakMap,_=new WeakMap,n=new WeakMap,U=new WeakMap,l=new WeakMap,V=new WeakMap,R=new WeakMap,C=new WeakMap,J=new WeakMap,P=new WeakMap,p=new WeakMap,j=new WeakMap,T=new WeakMap,I=new WeakMap,w=new WeakMap,x=new WeakSet,At=function(e=0,s=Ot.TAU,c=0){const h=s-e,b=new Float32Array((t(this,B)+1)*2*3);for(let G=0,$=0;$<=t(this,B);++$){const D=e+$*h/t(this,B),v=Math.cos(D),M=Math.sin(D);b[G++]=v*t(this,u),b[G++]=M*t(this,u),b[G++]=v*c,b[G++]=M*c}i(this,R,t(this,n).CreateVertexBuffer(b,{label:`${t(this,E)} Vertex Buffer`})),t(this,n).WriteBuffer(t(this,R),b)},Et=function(){const e=new Uint32Array(i(this,_,t(this,B)*6));for(let s=0,c=0;c<t(this,B);++c){const h=c*2;e[s++]=h+1,e[s++]=h+3,e[s++]=h+2,e[s++]=h+2,e[s++]=h+0,e[s++]=h+1}i(this,V,t(this,n).CreateIndexBuffer(e,{label:`${t(this,E)} Index Buffer`})),t(this,n).WriteBuffer(t(this,V),e)},Vt=function(){const{buffer:e,shape:{color:s,matrix:c}}=t(this,n).CreateUniformBuffer("shape",{label:`${t(this,E)} Uniform Buffer`});i(this,C,e),i(this,l,c),i(this,U,s),i(this,J,t(this,n).CreateBindGroup(t(this,n).CreateBindGroupEntries([{buffer:t(this,n).ResolutionBuffer},{buffer:t(this,C)}]),0,`${t(this,E)} Bind Group`)),i(this,I,Bt({matrix:s.length*Float32Array.BYTES_PER_ELEMENT,color:0*Float32Array.BYTES_PER_ELEMENT}))},nt=function(){if(t(this,y)){m.multiply(t(this,Q),t(this,k),t(this,l)),m.multiply(t(this,l),t(this,Y),t(this,l)),m.multiply(t(this,l),t(this,q),t(this,l)),t(this,n).WriteBuffer(t(this,C),t(this,l),t(this,I).matrix);const e=t(this,j)[0]=t(this,l)[8],s=t(this,j)[1]=t(this,l)[9];t(this,w).min[0]=e-t(this,u),t(this,w).min[1]=s-t(this,u),t(this,w).max[0]=e+t(this,u),t(this,w).max[1]=s+t(this,u),i(this,y,!1)}return this};var _t="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn mainVertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;let clipSpace=GetVertexClipSpace(position*scale).xy;output.position=vec4f(clipSpace+(offset+0.9)/1.8*vec2f(2,-2),0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}",H,K,F,W;class ot{constructor(e=30){r(this,H,0);r(this,K,0);r(this,F,0);r(this,W,[]);i(this,H,e)}addSample(e){const s=t(this,W)[t(this,F)]||0;i(this,K,t(this,K)+(e-s)),t(this,W)[t(this,F)]=e,i(this,F,(t(this,F)+1)%t(this,H))}get(){return t(this,K)/t(this,W).length}}H=new WeakMap,K=new WeakMap,F=new WeakMap,W=new WeakMap;/**
 * @module Timing Performance
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Timing Performance
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(o){let e,s=0;try{await Ct.SetRequiredFeatures("timestamp-query"),e=new(await Ct.RenderPipeline(o,"Timing Performance"))}catch(a){alert(a)}const c=24,h=0,b=0,G=2,$=new GUI,D=[],v=1e4,M={objects:100};$.add(M,"objects",0,v,1);const g=document.createElement("pre"),at=document.createElement("span"),ct=document.createElement("span"),ft=document.createElement("span");g.style.backgroundColor="rgb(0 0 0 / 0.8)",g.style.position="absolute",g.style.padding="0.5em",g.style.display="grid",g.style.color="white",g.style.margin="0px",g.style.left="0px",g.style.top="0px",g.append(at,ct,ft),document.body.appendChild(g);const lt=new ot,ht=new ot,ut=new ot,pt=e.CreateShaderModule([zt,_t]),dt=e.CreateColorAttachment();dt.clearValue=new rt(5000268).rgba;const tt=new it.GPUTiming(e),Rt=await tt.QuerySet;e.CreatePassDescriptor(dt,void 0,void 0,void 0,e.CreateTimestampWrites(Rt,0,1));const wt=e.CreateVertexBufferLayout("position",void 0,"mainVertex"),{buffer:X,layout:Ut}=e.CreateVertexBuffer([{name:"color",format:"unorm8x4"}],v,"instance","mainVertex"),{buffer:Z,layout:Pt}=e.CreateVertexBuffer(["offset","scale"],v,"instance","mainVertex"),{buffer:mt,layout:Tt}=e.CreateVertexBuffer({name:"vertexColor",format:"unorm8x4"},v,void 0,"mainVertex");e.CreatePipeline({fragment:e.CreateFragmentState(pt),vertex:e.CreateVertexState(pt,"mainVertex",[wt,Ut,Pt,Tt])});const Ft=new Lt({renderer:e,innerRadius:120,radius:240,segments:c}).Update().Vertices,et=new Float32Array(Z.size/Float32Array.BYTES_PER_ELEMENT);e.AddVertexBuffers([X,Z,mt]);{const a=X.size/v,f=new Uint8Array(X.size);for(let d=0;d<v;++d)f.set([A(255),A(255),A(255),255],a*d+h),D.push({scale:A(.2,.5),offset:[A(-.9,.9),A(-.9,.9)],velocity:[A(-.1,.1),A(-.1,.1)]});e.WriteBuffer(X,f)}{const a=new rt(1644825),f=new rt(16777215),d=new Uint8Array((c+1)*8);for(let O=0,S=0;O<=c;O++,S+=8)d.set(a.RGBA,S),d.set(f.RGBA,S+4);e.WriteBuffer(mt,d)}function A(a,f){return a===void 0?(a=0,f=1):f===void 0&&(f=a,a=0),Math.random()*(f-a)+a}async function xt(a){a*=.001;const f=a-s,d=performance.now(),O=Z.size/v/4;for(let S=0;S<M.objects;S++){const{scale:vt,offset:N,velocity:gt}=D[S];N[0]=it.EuclideanModulo(N[0]+gt[0]*f+1.5,3)-1.5,N[1]=it.EuclideanModulo(N[1]+gt[1]*f+1.5,3)-1.5;const St=S*O;et.set(N,St+b),et.set([vt,vt],St+G)}e.WriteBuffer(Z,et),e.Render([Ft,M.objects],!1),e.DestroyCurrentPass(),lt.addSample(1/f),ut.addSample(performance.now()-d),tt.ResolveAndSubmit().then(S=>ht.addSample(S/1e3)),at.textContent=`FPS: ${lt.get().toFixed(1)}`,ft.textContent=`JS: ${ut.get().toFixed(1)}ms`,ct.textContent=`GPU: ${tt.Enabled&&`${ht.get().toFixed(1)}Âµs`||"N/A"}`,requestAnimationFrame(xt),s=a}new ResizeObserver(a=>{for(const f of a){const{inlineSize:d,blockSize:O}=f.contentBoxSize[0];e.SetCanvasSize(d,O)}requestAnimationFrame(xt)}).observe(o)})(document.getElementById("lesson"));
