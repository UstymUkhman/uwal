import{m as s,v as u,G as b,C as y,T as R,E as j,M,a as U,b as P,D as O}from"./index-D1cRF4Z-.js";import{S as A}from"./index-BZJ7yk0V.js";class D{Children=[];Label;#r=null;TransformationOrder="TRS";ProjectionMatrix=s.identity();#t=s.identity();#e=s.identity();#i=u.create();#s=u.set(1,1);#a=0;constructor(t,e=null){this.Label=t,this.Parent=e}Add(t){t=b(t),t.forEach(e=>e.Parent=this)}Remove(t){t=b(t),t.forEach(e=>e.Parent=null)}Find(t){if(this.Label===t)return this;for(const e=0,r=this.Children.length;e<r;e++){const i=this.Children[e].Find(t);if(i)return i}return null}ResetLocalMatrix(){this.#t=s.identity()}UpdateWorldMatrix(){this.UpdateLocalMatrix(),this.#r?s.multiply(this.#r.WorldMatrix,this.#t,this.#e):s.copy(this.#t,this.#e),this.Children.forEach(t=>t.UpdateWorldMatrix())}UpdateLocalMatrix(){const t=this.TransformationOrder.split("");for(let e=0,r=t.length;e<r;e++)switch(t[e]){case"T":s.translation(this.#i,this.#t);break;case"R":s.rotate(this.#t,this.#a,this.#t);break;case"S":s.scale(this.#t,this.#s,this.#t);break}}UpdateProjectionMatrix(t){const e=this.#r&&this.#e||this.#t;return s.multiply(t,e,this.ProjectionMatrix)}ResetProjectionMatrix(){this.ProjectionMatrix=s.identity()}Rotate(t){s.rotate(this.#t,t,this.#t)}Scale(t){s.scale(this.#t,t,this.#t)}set Transform(t){const[e,r,i]=t,n=this.TransformationOrder.split("");for(let l=0,c=n.length;l<c;l++)switch(n[l]){case"T":e&&(this.Position=e);break;case"R":r!==void 0&&(this.Rotation=r);break;case"S":i&&(this.Scaling=i);break}}set Position(t){u.copy(t,this.#i),s.translate(this.#t,t,this.#t)}get Position(){return this.#i}set Rotation(t){this.#a=t,s.rotate(this.#t,t,this.#t)}get Rotation(){return this.#a}set Scaling(t){u.copy(t,this.#s),s.scale(this.#t,t,this.#t)}get Scaling(){return this.#s}get LocalMatrix(){return this.#t}get WorldMatrix(){return this.#e}set Parent(t){if(this.#r){const e=this.#r.Children.indexOf(this);0<=e&&this.#r.Children.splice(e,1)}t&&t.Children.push(this),this.#r=t}get Parent(){return this.#r}}let G=class extends D{#r;Visible=!0;#t;#e;#i=u.set(0,0);#s=u.set(0,0);#a;#n=y({min:u.create(),max:u.create()});#o=[];constructor(t,e,r="Shape",i=null){super(r,i),this.#r=t,this.#a=e}#h(t){const{projection:e,buffer:r}=this.#t.CreateUniformBuffer("projection",{label:`${this.Label} Projection Buffer`,...t});this.ProjectionMatrix=s.identity(e),this.#e=r,this.#o=this.#t.SetBindGroupFromResources([r,this.#a?.ColorBuffer].filter(Boolean),0,0,`${this.Label} Bind Group`)}SetRenderPipeline(t){this.#t=t,this.#r.CreateBuffers(t),this.#a?.CreateColorBuffer(t),this.#h()}SetPipelineData(){!this.#t&&R(j.PIPELINE_NOT_FOUND,"RenderPipeline.\n            Use `Shape.SetRenderPipeline` method before setting its data.");const{VertexBuffers:t,IndexBuffer:e,Vertices:r}=this.#r;this.#t.BindGroups=this.#o,this.#t.VertexBuffers=t,this.#t.IndexBuffer=e,this.#t.SetDrawParams(r)}UpdateLocalMatrix(){super.UpdateLocalMatrix();const t=this.LocalMatrix,{Radius:e}=this.#r;this.#n.min[0]=t[8]-e,this.#n.min[1]=t[9]-e,this.#n.max[0]=t[8]+e,this.#n.max[1]=t[9]+e,s.translate(t,this.#i,t),this.#s[0]=this.#i[0]+this.#n.max[0],this.#s[1]=this.#i[1]+this.#n.max[1]}UpdateProjectionMatrix(t){const e=super.UpdateProjectionMatrix(t);this.#t.WriteBuffer(this.#e,e)}get ProjectionBuffer(){return this.#e}set Origin(t){this.#i[0]=-t[0],this.#i[1]=-t[1];const e=this.LocalMatrix;s.translate(e,t,e)}get Origin(){return this.#i}get Center(){return this.#s}get BoundingBox(){return this.#n}get Geometry(){return this.#r}get Material(){return this.#a}Destroy(){this.#r.Destroy(),this.#a?.Destroy(),this.#t=void 0,this.#o.splice(0),this.#e?.destroy(),this.#e=void 0}};const I=y({TRIANGLE:3,SQUARE:4,PENTAGON:5,HEXAGON:6,HEPTAGON:7,OCTAGON:8,NONAGON:9,DECAGON:10,DODECAGON:12});let L=class{#r;#t;#e;IndexFormat;#i;#s;#a;VertexBuffers;IndexBuffer;constructor(t={segments:"SQUARE",radius:0}){const e=t.segments,r=typeof e=="number"&&e;this.#r=t.radius??0,this.#e=r||I[e||"SQUARE"],this.#i={label:"Shape",...t},this.IndexFormat=t.indexFormat??"uint16"}GetPositionBufferLayout(t,e="position",r="vertex",i="vertex"){return t.CreateVertexBufferLayout(e,r,i)}#n(t,e=this.#i.label){let r=this.#a;if(!r){r=new Float32Array((this.#e+1)*2*3);const{endAngle:n=M.TAU,startAngle:l=0,innerRadius:c=0}=this.#i,o=n-l;for(let x=0,f=0,m=this.#e;f<=m;++f){const d=l+f*o/m,p=Math.cos(d),C=Math.sin(d);r[x++]=p*this.#r,r[x++]=C*this.#r,r[x++]=p*c,r[x++]=C*c}}const i=t.CreateVertexBuffer(r,{label:`${e} Vertex Buffer`});this.VertexBuffers=t.SetVertexBuffers(i),t.WriteBuffer(i,r)}#o(t,e=this.#i.label){let r=this.#s;if(!r){r=new Uint16Array(this.#e*6);for(let n=0,l=0,c=this.#e;l<c;++l){const o=l*2;r[n++]=o+1,r[n++]=o+3,r[n++]=o+2,r[n++]=o+2,r[n++]=o+0,r[n++]=o+1}}const i=t.CreateIndexBuffer(r,{label:`${e} Index Buffer`});this.IndexBuffer=t.SetIndexBuffer(i,this.IndexFormat),t.SetDrawParams(this.#t=r.length),t.WriteBuffer(i,r)}CreateBuffers(t,e=this.#i.label){this.#n(t,e),this.#o(t,e)}set VertexData(t){this.#a=t}set IndexData(t){this.#s=t}get Vertices(){return this.#t}get Radius(){return this.#r}Destroy(){this.#s=void 0,this.#a=void 0,this.IndexBuffer?.buffer.destroy(),this.VertexBuffers?.[0].buffer.destroy()}};class w{#r;#t;#e;#i;#s;constructor(t=16777215,e="Shape"){this.Color=t,this.#r=e}CreateColorBuffer(t,e=this.#r){const{color:r,buffer:i}=t.CreateUniformBuffer("color",{label:`${e} Color Buffer`});this.#t=r,this.#e=t,this.#s=i,this.#t.set(this.#i),t.WriteBuffer(i,r)}get ColorBuffer(){return this.#s}set Color(t){this.#i=typeof t=="number"&&U(t)||t instanceof P&&t.rgba||Object.values(t),this.#t?.fill(1).set(this.#i),this.#e?.WriteBuffer(this.#s,this.#t)}get Color(){return this.#i}Destroy(){this.#e=void 0,this.#s.destroy(),this.#s=void 0}}class E extends D{#r="Camera2D";#t=innerWidth;#e=innerHeight;constructor(t=innerWidth,e=innerHeight){super("Camera2D"),this.Size=typeof t!="number"&&this.rendererWidth.CanvasSize||[t,e]}UpdateProjectionMatrix(){return s.set(2/this.#t,0,0,0,-2/this.#e,0,-1,1,1,this.ProjectionMatrix)}set Size([t,e]){this.#t=t,this.#e=e,this.UpdateProjectionMatrix()}set Width(t){this.#t=t,this.UpdateProjectionMatrix()}get Width(){return this.#t}set Height(t){this.#e=t,this.UpdateProjectionMatrix()}get Height(){return this.#e}}function T(){const h=new Float32Array([0,0,30,0,0,150,30,150,30,0,100,0,30,30,100,30,30,60,70,60,30,90,70,90]),t=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11]);return{vertexData:h,indexData:t}}/**
 * @module Matrix Math
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Math
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-math.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.2.0
 * @license MIT
 */(async function(h){let t;h.style.backgroundPosition="-1.5px -1.5px, -1.5px -1.5px, -1px -1px, -1px -1px",h.style.backgroundSize="100px 100px, 100px 100px, 10px 10px, 10px 10px",h.style.backgroundColor="#000",h.style.backgroundImage=`
        linear-gradient(       #666 1.5px, transparent 1.5px),
        linear-gradient(90deg, #666 1.5px, transparent 1.5px),
        linear-gradient(       #333 1px,   transparent 1px),
        linear-gradient(90deg, #333 1px,   transparent 1px)
    `;try{t=new(await O.Renderer(h,"Matrix Math",{alphaMode:"premultiplied"}))}catch(a){alert(a)}const e=new E,r=new GUI().onChange(p),i=new t.Pipeline,{vertexData:n,indexData:l}=T(),c=i.CreateShaderModule(A),o=new L({radius:75,indexFormat:"uint32"}),x={min:-360,max:360,step:1,converters:GUI.converters.radToDeg},f={translation:[150,100],rotation:M.DegreesToRadians(30),scale:[1,1],objects:1};r.add(f.translation,"0",0,1e3).name("translation.x"),r.add(f.translation,"1",0,1e3).name("translation.y"),r.add(f,"rotation",x),r.add(f.scale,"0",-5,5).name("scale.x"),r.add(f.scale,"1",-5,5).name("scale.y"),r.add(f,"objects",1,5,1).name("objects"),await t.AddPipeline(i,{fragment:i.CreateFragmentState(c),vertex:i.CreateVertexState(c,o.GetPositionBufferLayout(i))});const m=new P;o.IndexData=l,o.VertexData=n;const d=Array.from({length:5}).map(()=>{const a=new G(o,new w(m.Random()));return a.SetRenderPipeline(i),a.Origin=[50,75],a});for(let a=0;a<4;++a)d[a].Add(d[a+1]);function p(){for(let a=0;a<f.objects;++a){const{translation:S,rotation:g,scale:B}=f;d[a].Transform=[S,g,B],d[a].UpdateWorldMatrix(),d[a].UpdateProjectionMatrix(e.ProjectionMatrix),d[a].SetPipelineData(),t.Render(!1)}t.Submit()}new ResizeObserver(a=>{for(const S of a){const{inlineSize:g,blockSize:B}=S.contentBoxSize[0];t.SetCanvasSize(g,B),e.Size=[g,B]}p()}).observe(document.body)})(document.getElementById("lesson"));
