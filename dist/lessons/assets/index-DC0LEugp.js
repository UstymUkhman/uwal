import{U as i}from"./index-BEcPMtkb.js";var j="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;output.position=vec4f(position*scale+offset,0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Vertex Buffers
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Vertex Buffers
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-vertex-buffers.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.3
 * @license MIT
 */(async function(l){let e;try{e=new(await i.RenderPipeline(l,"Vertex Buffers"))}catch(r){alert(r)}const w=0,F=1,D=0,x=100,v=[],p=e.CreateRenderPassDescriptor(e.CreateColorAttachment(void 0,"clear","store",[.3,.3,.3,1])),U=e.CreateShaderModule(j),m=e.CreateRenderPipeline({fragment:e.CreateFragmentState(U),vertex:e.CreateVertexState(U,"vertex",[{arrayStride:4+2*Float32Array.BYTES_PER_ELEMENT,attributes:[e.CreateVertexBufferAttribute("float32x2"),e.CreateVertexBufferAttribute("unorm8x4",4,8)]},{arrayStride:4+2*Float32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[e.CreateVertexBufferAttribute("unorm8x4",1),e.CreateVertexBufferAttribute("float32x2",2,4)]},{stepMode:"instance",arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[e.CreateVertexBufferAttribute("float32x2",3)]}])}),P=4+2*Float32Array.BYTES_PER_ELEMENT,b=2*Float32Array.BYTES_PER_ELEMENT,g=P*x,y=b*x,{vertexData:A,indexData:V}=L({innerRadius:.25,outerRadius:.5}),T=e.CreateBuffer({label:"Vertex Buffer",size:A.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.WriteBuffer(T,A);const h=e.CreateBuffer({label:"Constant Vertex Buffer",size:g,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),_=e.CreateBuffer({label:"Variable Vertex Buffer",size:y,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});e.SetVertexBuffers([T,h,_]);const R=e.CreateBuffer({label:"Index Buffer",size:V.byteLength,usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST});e.WriteBuffer(R,V),e.SetIndexBuffer(R);{const r=new Uint8Array(g),t=new Float32Array(r.buffer);for(let n=0;n<x;++n){const a=P*n,B=a/4;r.set([u(255),u(255),u(255),255],a+w),t.set([u(-.9,.9),u(-.9,.9)],B+F),v.push({scale:u(.2,.5)})}e.WriteBuffer(h,t)}const z=new Float32Array(y/Float32Array.BYTES_PER_ELEMENT),Y=V.length;function L({endAngle:r=Math.PI*2,subdivisions:t=24,innerRadius:n=0,outerRadius:a=1,startAngle:B=0}){const N=(t+1)*2,E=new Float32Array(N*3),d=new Uint8Array(E.buffer);let C=0,S=8;const M=(f,s,o)=>{E[C++]=f,E[C++]=s,d[S++]=o[0]*255,d[S++]=o[1]*255,d[S++]=o[2]*255,S+=9,C+=1},I=[1,1,1],W=[.1,.1,.1],X=r-B;for(let f=0;f<=t;f++){const s=B+f*X/t,o=Math.cos(s),O=Math.sin(s);M(o*a,O*a,W),M(o*n,O*n,I)}const c=new Uint32Array(t*6);for(let f=0,s=0;s<t;s++){const o=s*2;c[f++]=o+1,c[f++]=o+3,c[f++]=o+2,c[f++]=o+2,c[f++]=o+0,c[f++]=o+1}return{vertexData:E,indexData:c}}function u(r=0,t=1){return t===void 0&&(t=r,r=0),Math.random()*(t-r)+r}function G(){i.SetCanvasSize(l.width,l.height);const r=i.AspectRatio;p.colorAttachments[0].view=i.CurrentTextureView,v.forEach(({scale:t},n)=>{const a=b/4*n;z.set([t/r,t],a+D)}),e.WriteBuffer(_,z),e.Render(p,m,[Y,x])}new ResizeObserver(r=>{for(const t of r){const{inlineSize:n,blockSize:a}=t.contentBoxSize[0];i.SetCanvasSize(n,a)}G()}).observe(l)})(document.getElementById("lesson"));
