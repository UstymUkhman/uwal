{"version":3,"file":"uwal.umd.cjs","sources":["../lib/Constants.js","../lib/Errors.js","../lib/pipeline/BasePipeline.js","../lib/pipeline/RenderPipeline.js","../lib/pipeline/ComputePipeline.js","../lib/UWAL.js"],"sourcesContent":["/** @param {Record<string, unknown>} values */\nfunction CreateConstantObject(values)\n{\n    /** @type {object} */ const constants = {};\n\n    for (let value in values)\n        constants[value] = { value: values[value] };\n\n    return Object.freeze(Object.create(null, constants));\n}\n\n/**\n * @typedef {\"DEVICE_LOST\"} EventType\n * @type {Readonly<Record<EventType, string>>}\n */\nexport const EVENT = CreateConstantObject(\n{\n    DEVICE_LOST: \"Device::Lost\"\n});\n\n/**\n * @typedef {\"WEBGPU_NOT_SUPPORTED\"      |\n *           \"ADAPTER_NOT_FOUND\"         |\n *           \"DEVICE_NOT_FOUND\"          |\n *           \"DEVICE_NOT_REQUESTED\"      |\n *           \"DEVICE_LOST\"               |\n *           \"CANVAS_NOT_FOUND\"          |\n *           \"CONTEXT_NOT_FOUND\"         |\n *           \"COMMAND_ENCODER_NOT_FOUND\"\n * } ErrorCause\n *\n * @type {Readonly<Record<ErrorCause, ErrorCause>>}\n */\nexport const ERROR = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: \"WEBGPU_NOT_SUPPORTED\",\n    ADAPTER_NOT_FOUND: \"ADAPTER_NOT_FOUND\",\n    DEVICE_NOT_FOUND: \"DEVICE_NOT_FOUND\",\n    DEVICE_NOT_REQUESTED: \"DEVICE_NOT_REQUESTED\",\n    DEVICE_LOST: \"DEVICE_LOST\",\n    CANVAS_NOT_FOUND: \"CANVAS_NOT_FOUND\",\n    CONTEXT_NOT_FOUND: \"CONTEXT_NOT_FOUND\",\n    COMMAND_ENCODER_NOT_FOUND: \"COMMAND_ENCODER_NOT_FOUND\"\n});\n\n/** @type {Readonly<Record<ErrorCause, string>>} */\nexport const ERROR_MESSAGE = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: \"WebGPU is not supported in this browser.\",\n    ADAPTER_NOT_FOUND: \"Failed to get a GPUAdapter.\",\n    DEVICE_NOT_FOUND: \"Failed to get a GPUDevice.\",\n    DEVICE_NOT_REQUESTED: \"GPUDevice was not requested.\",\n    DEVICE_LOST: \"WebGPU device was lost.\",\n    CANVAS_NOT_FOUND: \"Failed to get a WebGPU canvas.\",\n    CONTEXT_NOT_FOUND: \"Failed to get a WebGPU context.\",\n    COMMAND_ENCODER_NOT_FOUND: \"Failed to get a GPUCommandEncoder.\"\n});\n\n/** @type {Readonly<Record<ErrorCause, number>>} */\nexport const ERROR_CAUSE = CreateConstantObject(\n{\n    WEBGPU_NOT_SUPPORTED: 0,\n    ADAPTER_NOT_FOUND: 1,\n    DEVICE_NOT_FOUND: 2,\n    DEVICE_NOT_REQUESTED: 3,\n    DEVICE_LOST: 4,\n    CANVAS_NOT_FOUND: 5,\n    CONTEXT_NOT_FOUND: 6,\n    COMMAND_ENCODER_NOT_FOUND: 7\n});\n","import { ERROR_MESSAGE, ERROR_CAUSE } from \"@/Constants\";\n\n/**\n * @param {import(\"@/Constants\").ErrorCause} warning\n * @param {string} [message = undefined]\n */\nexport function ThrowWarning(warning, message)\n{\n    console.warn(ERROR_MESSAGE[warning] + (message ?? \"\"));\n}\n\n/**\n * @param {import(\"@/Constants\").ErrorCause} error\n * @param {string} [message = undefined]\n */\nexport function ThrowError(error, message)\n{\n    throw new Error(ERROR_MESSAGE[error] + (message ?? \"\"), { cause: ERROR_CAUSE[error] });\n}\n","import { ThrowError, ThrowWarning } from \"@/Errors\";\nimport { ERROR } from \"@/Constants\";\n\n/** @abstract */\nexport default class BasePipeline\n{\n    /** @type {string} */ #CommandEncoderLabel;\n\n    /** @protected @type {GPUDevice} */ Device;\n    /** @protected @type {GPUBindGroup[]} */ BindGroups = [];\n    /** @type {GPUCommandEncoder | undefined} */ #CommandEncoder;\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     */\n    constructor(device, commandEncoderLabel)\n    {\n        !device && ThrowError(ERROR.DEVICE_NOT_REQUESTED);\n\n        this.Device = device;\n        this.#CommandEncoderLabel = commandEncoderLabel;\n    }\n\n    /**\n     * @typedef {Object} BufferDescriptor\n     * @property {GPUSize64} size\n     * @property {GPUBufferUsageFlags} usage\n     * @property {string} [label = undefined]\n     * @property {boolean} [mappedAtCreation = undefined]\n     * @param {BufferDescriptor} descriptor\n     */\n    CreateBuffer(descriptor)\n    {\n        return this.Device.createBuffer(descriptor);\n    }\n\n    /**\n     * @param {GPUBuffer} buffer\n     * @param {BufferSource | SharedArrayBuffer} data\n     * @param {GPUSize64} [bufferOffset = 0]\n     * @param {GPUSize64} [dataOffset = undefined]\n     * @param {GPUSize64} [size = undefined]\n     */\n    WriteBuffer(buffer, data, bufferOffset = 0, dataOffset, size)\n    {\n        this.Device.queue.writeBuffer(buffer, bufferOffset, data, dataOffset, size);\n    }\n\n    /**\n     * @param {GPUBuffer} source\n     * @param {GPUBuffer} destination\n     * @param {GPUSize64} size\n     * @param {GPUSize64} [sourceOffset = 0]\n     * @param {GPUSize64} [destinationOffset = 0]\n     */\n    CopyBufferToBuffer(source, destination, size, sourceOffset = 0, destinationOffset = 0)\n    {\n        this.CommandEncoder.copyBufferToBuffer(source, sourceOffset, destination, destinationOffset, size);\n    }\n\n    /**\n     * @param {string | string[]} shader\n     * @param {string} [label = \"\"]\n     * @param {any} [sourceMap = undefined]\n     * @param {GPUShaderModuleCompilationHint[]} [hints = undefined]\n     */\n    CreateShaderModule(shader, label = \"\", sourceMap, hints)\n    {\n        const code = Array.isArray(shader) ? shader.join(\"\\n\\n\") : shader;\n        return this.Device.createShaderModule({ label, code, sourceMap, compilationHints: hints });\n    }\n\n    /** @param {GPUBindingResource | GPUBindingResource[]} resources */\n    CreateBindGroupEntries(resources)\n    {\n        return Array.isArray(resources)\n            ? resources.map((resource, binding) => ({ binding, resource }))\n            : [{ binding: 0, resource: resources }];\n    }\n\n    /**\n     * @typedef {Object} BindGroupDescriptor\n     * @property {GPUBindGroupLayout} layout\n     * @property {Iterable<GPUBindGroupEntry>} entries\n     * @property {string} [label = undefined]\n     * @param {BindGroupDescriptor} descriptor\n     */\n    CreateBindGroup(descriptor)\n    {\n        return this.Device.createBindGroup(descriptor);\n    }\n\n    /** @param {GPUBindGroup | GPUBindGroup[]} bindGroups */\n    AddBindGroups(bindGroups)\n    {\n        this.BindGroups = Array.isArray(bindGroups) ? bindGroups : [bindGroups];\n    }\n\n    CreateCommandEncoder()\n    {\n        return this.#CommandEncoder = this.Device.createCommandEncoder({ label: this.#CommandEncoderLabel });\n    }\n\n    SubmitCommandBuffer()\n    {\n        this.Device.queue.submit([this.CommandEncoder.finish()]);\n    }\n\n    /** @protected */\n    get CommandEncoder()\n    {\n        if (!this.#CommandEncoder)\n        {\n            const message = ` ${this.#CommandEncoderLabel && `Label: \"${this.#CommandEncoderLabel}\". `}`;\n            ThrowWarning(ERROR.COMMAND_ENCODER_NOT_FOUND, message + \"Creating a new one.\");\n            return this.CreateCommandEncoder();\n        }\n\n        return this.#CommandEncoder;\n    }\n}\n","import { BasePipeline } from \"@/pipeline\";\n\nexport default class RenderPipeline extends BasePipeline\n{\n    /** @type {GPUTextureFormat} */ #PreferredCanvasFormat;\n    /** @type {GPURenderPassEncoder | undefined} */ #CurrentPass;\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     * @param {GPUTextureFormat} [preferredFormat = undefined]\n     */\n    constructor(device, commandEncoderLabel, preferredFormat)\n    {\n        super(device, commandEncoderLabel);\n        this.#PreferredCanvasFormat = preferredFormat;\n    }\n\n    /**\n     * @param {GPUTextureView} [view = undefined]\n     * @param {GPULoadOp} [loadOp = \"load\"]\n     * @param {GPUStoreOp} [storeOp = \"store\"]\n     * @param {GPUColor} [clearValue = undefined]\n     * @param {GPUTextureView} [resolveTarget = undefined]\n     * @param {GPUIntegerCoordinate} [depthSlice = undefined]\n     */\n    CreateColorAttachment(view, loadOp = \"load\", storeOp = \"store\", clearValue, resolveTarget, depthSlice)\n    {\n        return { view, loadOp, storeOp, clearValue, resolveTarget, depthSlice };\n    }\n\n    /**\n     * @param {GPURenderPassColorAttachment | GPURenderPassColorAttachment[]} colorAttachments\n     * @param {string} [label = \"\"]\n     * @param {GPURenderPassDepthStencilAttachment} [depthStencilAttachment = undefined]\n     * @param {GPUQuerySet} [occlusionQuerySet = undefined]\n     * @param {GPURenderPassTimestampWrites} [timestampWrites = undefined]\n     * @param {GPUSize64} [maxDrawCount = undefined]\n     */\n    CreateRenderPassDescriptor(\n        colorAttachments, label = \"\", depthStencilAttachment, occlusionQuerySet, timestampWrites, maxDrawCount\n    ) {\n        colorAttachments = Array.isArray(colorAttachments) ? colorAttachments : [colorAttachments];\n        return { colorAttachments, label, depthStencilAttachment, occlusionQuerySet, timestampWrites, maxDrawCount };\n    }\n\n    /**\n     * @param {GPUShaderModule} module\n     * @param {string} [entry = \"vertex\"]\n     * @param {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     * @param {Iterable<GPUVertexBufferLayout | null>} [buffers = undefined]\n     */\n    CreateVertexState(module, entry = \"vertex\", constants, buffers)\n    {\n        return { module, entryPoint: entry, constants, buffers };\n    }\n\n    /**\n     * @param {GPUShaderModule} module\n     * @param {string} [entry = \"fragment\"]\n     * @param {Iterable<GPUColorTargetState | null>} [targets = [undefined]]\n     * @param {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     */\n    CreateFragmentState(module, entry = \"fragment\", targets, constants)\n    {\n        targets ??= [{ format: this.#PreferredCanvasFormat }];\n        return { module, entryPoint: entry, targets, constants };\n    }\n\n    /**\n     * @typedef {Object} RenderPipelineDescriptor\n     * @property {GPUVertexState} vertex\n     * @property {string} [label = undefined]\n     * @property {GPUFragmentState} [fragment = undefined]\n     * @property {GPUPipelineLayout | GPUAutoLayoutMode} [layout = \"auto\"]\n     * @property {GPUPrimitiveState} [primitive = undefined]\n     * @property {GPUDepthStencilState} [depthStencil = undefined]\n     * @property {GPUMultisampleState} [multisample = undefined]\n     * @param {RenderPipelineDescriptor} descriptor\n     */\n    CreateRenderPipeline(descriptor)\n    {\n        const layout = descriptor.layout ?? \"auto\";\n        return this.Device.createRenderPipeline({ ...descriptor, layout });\n    }\n\n    /**\n     * @param {GPURenderPassDescriptor} descriptor\n     * @param {GPURenderPipeline} pipeline\n     * @typedef {Object} DrawParams\n     * @property {GPUSize32} vertexCount\n     * @property {GPUSize32} [instanceCount = undefined]\n     * @property {GPUSize32} [firstVertex = undefined]\n     * @property {GPUSize32} [firstInstance = undefined]\n     * @param {DrawParams | GPUSize32} drawParams\n     * @param {boolean} [submit = true]\n     */\n    Render(descriptor, pipeline, drawParams, submit = true)\n    {\n        if (!this.#CurrentPass)\n        {\n            const encoder = this.CreateCommandEncoder();\n            this.#CurrentPass = encoder.beginRenderPass(descriptor);\n            this.#CurrentPass.setPipeline(pipeline);\n        }\n\n        for (let g = 0, l = this.BindGroups.length; g < l; ++g)\n            this.#CurrentPass.setBindGroup(g, this.BindGroups[g]);\n\n        drawParams = typeof drawParams === \"number\"\n            ? { vertexCount: drawParams }\n            : drawParams;\n\n        this.#CurrentPass.draw(\n            drawParams.vertexCount,\n            drawParams.instanceCount,\n            drawParams.firstVertex,\n            drawParams.firstInstance\n        );\n\n        if (submit)\n        {\n            this.#CurrentPass.end();\n            this.#CurrentPass = undefined;\n            this.SubmitCommandBuffer();\n        }\n    }\n\n    get CurrentPass()\n    {\n        return this.#CurrentPass;\n    }\n}\n","import { BasePipeline } from \"@/pipeline\";\n\nexport default class ComputePipeline extends BasePipeline\n{\n    /** @type {number[]} */ #Workgroups = [1];\n\n    /**\n     * @param {GPUDevice} [device = undefined]\n     * @param {string} [commandEncoderLabel = \"\"]\n     */\n    constructor(device, commandEncoderLabel)\n    {\n        super(device, commandEncoderLabel);\n    }\n\n    /**\n     * @param {string} [label = \"\"]\n     * @param {GPUQuerySet} [querySet = undefined]\n     * @param {GPUSize32} [beginningOfPassWriteIndex = undefined]\n     * @param {GPUSize32} [endOfPassWriteIndex = undefined]\n     */\n    CreateComputePassDescriptor(label = \"\", querySet, beginningOfPassWriteIndex, endOfPassWriteIndex)\n    {\n        return {\n            label,\n            timestampWrites: querySet\n                ? { querySet, beginningOfPassWriteIndex, endOfPassWriteIndex }\n                : undefined\n        };\n    }\n\n    /**\n     * @typedef {Object} ComputePipelineDescriptor\n     * @property {GPUShaderModule} module\n     * @property {string} [entry = \"compute\"]\n     * @property {string} [label = undefined]\n     * @property {GPUPipelineLayout | GPUAutoLayoutMode} [layout = \"auto\"]\n     * @property {Record<string, GPUPipelineConstantValue>} [constants = undefined]\n     * @param {ComputePipelineDescriptor} descriptor\n     */\n    CreateComputePipeline(descriptor)\n    {\n        const layout = descriptor.layout ?? \"auto\";\n        return this.Device.createComputePipeline({ label: descriptor.label, layout, compute: descriptor });\n    }\n\n    /**\n     * @param {GPUComputePipeline} pipeline\n     * @param {GPUComputePassDescriptor} [descriptor = undefined]\n     */\n    Compute(pipeline, descriptor)\n    {\n        const pass = this.CommandEncoder.beginComputePass(descriptor);\n\n        pass.setPipeline(pipeline);\n\n        for (let g = 0, l = this.BindGroups.length; g < l; ++g)\n            pass.setBindGroup(g, this.BindGroups[g]);\n\n        // @ts-ignore\n        pass.dispatchWorkgroups(...this.#Workgroups);\n        pass.end();\n    }\n\n    /** @param {number | number[]} workgroups */\n    set Workgroups(workgroups)\n    {\n        this.#Workgroups = Array.isArray(workgroups) ? workgroups : [workgroups];\n    }\n}\n","/**\n * @module UWAL\n * @author Ustym Ukhman <ustym.ukhman@gmail.com>\n * @description Unopinionated WebGPU Abstraction Library\n * @version 0.0.1\n * @license MIT\n */\n\nimport { RenderPipeline, ComputePipeline } from \"@/pipeline\";\nimport { ERROR, EVENT } from \"@/Constants\";\nimport { ThrowError } from \"@/Errors\";\n\nexport default class UWAL\n{\n    /** @type {GPUAdapter | null} */ static #Adapter = null;\n    /** @type {GPUDevice | null} */ static #Device = null;\n\n    /** @type {HTMLCanvasElement} */ static #Canvas;\n    /** @type {GPUCanvasContext} */ static #Context;\n\n    /** @type {GPUTextureFormat} */ static #PreferredCanvasFormat;\n\n    /** @type {GPURequestAdapterOptions} */ static #AdapterOptions =\n    {\n        powerPreference: undefined, forceFallbackAdapter: false\n    }\n\n    /** @type {GPUDeviceDescriptor} */ static #DeviceDescriptor =\n    {\n        label: \"\", requiredFeatures: [], requiredLimits: {}\n    }\n\n    /** @type {((detail: GPUDeviceLostInfo) => unknown) | undefined} */ static OnDeviceLost;\n\n    /** @param {GPUPowerPreference} [powerPreference = undefined] */\n    static SetAdapterOptions(powerPreference = undefined, forceFallbackAdapter = false)\n    {\n        UWAL.#AdapterOptions.powerPreference = powerPreference;\n        UWAL.#AdapterOptions.forceFallbackAdapter = forceFallbackAdapter;\n    }\n\n    /**\n     * @param {Iterable<GPUFeatureName>} [requiredFeatures = []]\n     * @param {Record<string, GPUSize64>} [requiredLimits = {}]\n     */\n    static SetDeviceDescriptor(label = \"\", requiredFeatures = [], requiredLimits = {})\n    {\n        UWAL.#DeviceDescriptor.label = label;\n        UWAL.#DeviceDescriptor.requiredFeatures = requiredFeatures;\n        UWAL.#DeviceDescriptor.requiredLimits = requiredLimits;\n    }\n\n    static SetCanvasSize(width = innerWidth, height = innerHeight)\n    {\n        !UWAL.#Canvas && ThrowError(ERROR.CANVAS_NOT_FOUND);\n        !UWAL.#Device && ThrowError(ERROR.DEVICE_NOT_FOUND);\n\n        const { maxTextureDimension2D } = UWAL.#Device.limits;\n\n        width = Math.max(1, Math.min(width, maxTextureDimension2D));\n        height = Math.max(1, Math.min(height, maxTextureDimension2D));\n\n        if (UWAL.#Canvas.width !== width || UWAL.#Canvas.height !== height)\n        {\n            UWAL.#Canvas.height = height;\n            UWAL.#Canvas.width = width;\n        }\n    }\n\n    /**\n     * @param {HTMLCanvasElement} canvas\n     * @param {string} [commandEncoderLabel = \"\"]\n     * @typedef {Object} ConfigurationOptions\n     * @property {GPUTextureFormat} [format = undefined]\n     * @property {GPUTextureUsageFlags} [usage = 0x10] - GPUTextureUsage.RENDER_ATTACHMENT\n     * @property {Iterable<GPUTextureFormat>} [viewFormats = []]\n     * @property {PredefinedColorSpace} [colorSpace = \"srgb\"]\n     * @property {GPUCanvasAlphaMode} [alphaMode = \"opaque\"]\n     * @param {ConfigurationOptions} [options = {}]\n     */\n    static RenderPipeline(canvas, commandEncoderLabel = \"\", options = {})\n    {\n        return (async () =>\n        {\n            const device = await UWAL.Device;\n            const context = canvas.getContext(\"webgpu\");\n\n            !context && ThrowError(ERROR.CONTEXT_NOT_FOUND);\n\n            const preferredFormat = options.format ?? UWAL.#PreferredCanvasFormat;\n            const configuration = { ...options, format: preferredFormat };\n\n            context.configure({ device, ...configuration });\n\n            UWAL.#Canvas = canvas;\n            UWAL.#Context = context;\n\n            return new Proxy(RenderPipeline,\n            {\n                construct(Pipeline)\n                {\n                    return new Pipeline(device, commandEncoderLabel, preferredFormat);\n                }\n            });\n        })();\n    }\n\n    /** @param {string} [commandEncoderLabel = \"\"] */\n    static ComputePipeline(commandEncoderLabel = \"\")\n    {\n        return (async () =>\n        {\n            const device = await UWAL.Device;\n\n            return new Proxy(ComputePipeline,\n            {\n                construct(Pipeline)\n                {\n                    return new Pipeline(device, commandEncoderLabel);\n                }\n            });\n        })();\n    }\n\n    /**\n     * @param {GPUBuffer | GPUBuffer[]} [buffers = undefined]\n     * @param {GPUTexture | GPUTexture[]} [textures = undefined]\n     * @param {GPUQuerySet | GPUQuerySet[]} [querySets = undefined]\n     */\n    static Destroy(buffers, textures, querySets)\n    {\n        // Optionally remove all GPUBuffers:\n        buffers = Array.isArray(buffers) ? buffers : [buffers];\n        buffers.forEach(buffer => buffer?.destroy());\n\n        // Optionally remove all GPUTextures:\n        textures = Array.isArray(textures) ? textures : [textures];\n        textures.forEach(texture => texture?.destroy());\n\n        // Optionally remove all GPUQuerySets:\n        querySets = Array.isArray(querySets) ? querySets : [querySets];\n        querySets.forEach(querySet => querySet?.destroy());\n\n        // Remove GPUCanvasContext configuration:\n        UWAL.#Context?.unconfigure();\n\n        // Destroy GPUDevice:\n        UWAL.#Device?.destroy();\n    }\n\n    static #RequestAdapter()\n    {\n        !navigator.gpu && ThrowError(ERROR.WEBGPU_NOT_SUPPORTED);\n\n        UWAL.#PreferredCanvasFormat = navigator.gpu.getPreferredCanvasFormat();\n\n        return async () =>\n        {\n            const adapter = await navigator.gpu.requestAdapter(UWAL.#AdapterOptions);\n            !adapter && ThrowError(ERROR.ADAPTER_NOT_FOUND);\n            return UWAL.#Adapter = adapter;\n        };\n    }\n\n    static #RequestDevice()\n    {\n        return async () =>\n        {\n            const { requiredFeatures, requiredLimits, label } = UWAL.#DeviceDescriptor;\n\n            const device = await (await UWAL.Adapter).requestDevice({\n                requiredFeatures, requiredLimits, defaultQueue: { label }\n            });\n\n            !device && ThrowError(ERROR.DEVICE_NOT_FOUND);\n            device.lost.then(UWAL.#DeviceLost);\n            return UWAL.#Device = device;\n        };\n    }\n\n    /** @param {GPUDeviceLostInfo} detail */\n    static #DeviceLost(detail)\n    {\n        if (UWAL.OnDeviceLost) return UWAL.OnDeviceLost(detail);\n\n        UWAL.#Canvas.dispatchEvent(new CustomEvent(EVENT.DEVICE_LOST, { detail }));\n\n        const message = (detail.message && ` | Message: ${detail.message}`) ?? \".\";\n\n        // If device is destroyed intentionally, `reason` will be `destroyed`.\n        ThrowError(ERROR.DEVICE_LOST, ` Reason: ${detail.reason}` + message);\n    }\n\n    static get Adapter()\n    {\n        return (async () => UWAL.#Adapter ?? (await UWAL.#RequestAdapter()()))();\n    }\n\n    static get Device()\n    {\n        return (async () => UWAL.#Device ?? (await UWAL.#RequestDevice()()))();\n    }\n\n    /** @returns {HTMLCanvasElement | undefined} */\n    static get Canvas()\n    {\n        return UWAL.#Canvas;\n    }\n\n    /** @returns {GPUCanvasContext | undefined} */\n    static get Context()\n    {\n        return UWAL.#Context;\n    }\n\n    static get AspectRatio()\n    {\n        !UWAL.#Canvas && ThrowError(ERROR.CANVAS_NOT_FOUND);\n        return UWAL.#Canvas.width / UWAL.#Canvas.height;\n    }\n\n    static get CurrentTexture()\n    {\n        return UWAL.#Context.getCurrentTexture();\n    }\n\n    static get CurrentTextureView()\n    {\n        return UWAL.CurrentTexture.createView();\n    }\n\n    static get VERSION()\n    {\n        return VERSION;\n    }\n}\n\nconsole.info(`%cUWAL v${UWAL.VERSION}`, \"background:#005a9c;padding:3px;color:#fff;\");\n"],"names":["CreateConstantObject","values","constants","value","EVENT","ERROR","ERROR_MESSAGE","ERROR_CAUSE","ThrowWarning","warning","message","ThrowError","error","BasePipeline","device","commandEncoderLabel","__privateAdd","_CommandEncoderLabel","__publicField","_CommandEncoder","__privateSet","descriptor","buffer","data","bufferOffset","dataOffset","size","source","destination","sourceOffset","destinationOffset","shader","label","sourceMap","hints","code","resources","resource","binding","bindGroups","__privateGet","RenderPipeline","preferredFormat","_PreferredCanvasFormat","_CurrentPass","view","loadOp","storeOp","clearValue","resolveTarget","depthSlice","colorAttachments","depthStencilAttachment","occlusionQuerySet","timestampWrites","maxDrawCount","module","entry","buffers","targets","layout","pipeline","drawParams","submit","encoder","g","l","ComputePipeline","_Workgroups","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","pass","workgroups","_UWAL","powerPreference","forceFallbackAdapter","_AdapterOptions","requiredFeatures","requiredLimits","_DeviceDescriptor","width","height","_Canvas","_Device","maxTextureDimension2D","canvas","options","context","configuration","_Context","Pipeline","textures","querySets","texture","_a","_b","_Adapter","__privateMethod","_RequestAdapter","RequestAdapter_fn","_RequestDevice","RequestDevice_fn","adapter","_DeviceLost","DeviceLost_fn","detail","UWAL"],"mappings":"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"}